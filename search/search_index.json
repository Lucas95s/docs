{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Automata Network \u00b6 Automata Network is a decentralized service protocol that provides middleware-like services for dApps to achieve traceless privacy, high assurance and frictionless computation. The MEV Wiki \u00b6 Flashboys, Flashbots, Dark Forests and more.. Witness \u00b6 Witness is a privacy-first off-chain governance solution with on-chain execution. Please see the guide to start. ContextFree \u00b6 ContextFree is the canary network of Automata Network. Please see the wallet guide here!","title":"Welcome"},{"location":"#automata-network","text":"Automata Network is a decentralized service protocol that provides middleware-like services for dApps to achieve traceless privacy, high assurance and frictionless computation.","title":"Automata Network"},{"location":"#the-mev-wiki","text":"Flashboys, Flashbots, Dark Forests and more..","title":"The MEV Wiki"},{"location":"#witness","text":"Witness is a privacy-first off-chain governance solution with on-chain execution. Please see the guide to start.","title":"Witness"},{"location":"#contextfree","text":"ContextFree is the canary network of Automata Network. Please see the wallet guide here!","title":"ContextFree"},{"location":"canarynet/getstarted/introduction/","text":"ContextFree Network \u00b6 ContextFree is the Canary Network of Automata\u2019s Mainnet, and this is an important milestone in realizing the technological vision of a privacy middleware platform built for Web 3.0. The launch of ContextFree provides a pre-production environment for real-life learnings to be applied to the eventual rollout of the Mainnet. During this time, users are invited to battle-test the code. Features are rolled out in phases to ensure the stability and security of the blockchain. This documentation homepage offers the necessary resources to learn about ContextFree, guides and tools to contribute to the Canary Network, either as a user looking to explore the blockchain, or to participate by running a node. Here are some background information to get you started: Network Parameters \u00b6 Basic \u00b6 Config Parameter Expected block time 6 seconds Epoch duration 4 hours Era duration 24 hours Account prefix 11820 Tokens \u00b6 CTX are ContextFree tokens, and do not have any monetary value. Users can request for free CTX tokens by heading over to our faucet . The initial circulation amount of CTX is set at 1 billion, and will be minted on demand. Roadmap \u00b6 ContextFree launch progress mimics and follows the Roadmap , with faster iteration. All upgrades will be recorded in this documentation. Features \u00b6 2021-09-30 Initial launch ContextFree was launched on September 30, 2021, in Proof of Authority mode. All nodes are held by the Automata team, with most functionalities disabled. 2021-10-09 Token Economics Features related to Transfer, Staking and Token Bridge have been enabled on October 9, 2021. 2021-10-12 NPoS Nominated Proof of Stake has been enabled on October 12, 2021, and public validators will be able to join the network. Resources \u00b6 Name Value Dashboard https://dashboard.ata.network HTTP RPC Endpoint https://cf-rpc.ata.network Websockets RPC Endpoint wss://cf-api.ata.network","title":"Introduction"},{"location":"canarynet/getstarted/introduction/#contextfree-network","text":"ContextFree is the Canary Network of Automata\u2019s Mainnet, and this is an important milestone in realizing the technological vision of a privacy middleware platform built for Web 3.0. The launch of ContextFree provides a pre-production environment for real-life learnings to be applied to the eventual rollout of the Mainnet. During this time, users are invited to battle-test the code. Features are rolled out in phases to ensure the stability and security of the blockchain. This documentation homepage offers the necessary resources to learn about ContextFree, guides and tools to contribute to the Canary Network, either as a user looking to explore the blockchain, or to participate by running a node. Here are some background information to get you started:","title":"ContextFree Network"},{"location":"canarynet/getstarted/introduction/#network-parameters","text":"","title":"Network Parameters"},{"location":"canarynet/getstarted/introduction/#basic","text":"Config Parameter Expected block time 6 seconds Epoch duration 4 hours Era duration 24 hours Account prefix 11820","title":"Basic"},{"location":"canarynet/getstarted/introduction/#tokens","text":"CTX are ContextFree tokens, and do not have any monetary value. Users can request for free CTX tokens by heading over to our faucet . The initial circulation amount of CTX is set at 1 billion, and will be minted on demand.","title":"Tokens"},{"location":"canarynet/getstarted/introduction/#roadmap","text":"ContextFree launch progress mimics and follows the Roadmap , with faster iteration. All upgrades will be recorded in this documentation.","title":"Roadmap"},{"location":"canarynet/getstarted/introduction/#features","text":"2021-09-30 Initial launch ContextFree was launched on September 30, 2021, in Proof of Authority mode. All nodes are held by the Automata team, with most functionalities disabled. 2021-10-09 Token Economics Features related to Transfer, Staking and Token Bridge have been enabled on October 9, 2021. 2021-10-12 NPoS Nominated Proof of Stake has been enabled on October 12, 2021, and public validators will be able to join the network.","title":"Features"},{"location":"canarynet/getstarted/introduction/#resources","text":"Name Value Dashboard https://dashboard.ata.network HTTP RPC Endpoint https://cf-rpc.ata.network Websockets RPC Endpoint wss://cf-api.ata.network","title":"Resources"},{"location":"canarynet/node/node-type/","text":"Type of Nodes \u00b6 Before an introduction to the distinct type of nodes, it is important to understand a few concepts: * Genesis block: defined by a chain spec file, which describes the initial status of a chain, including the initial wasm, balances, authority set and so on. * Extrinsics: a piece of information that comes from outside the chain and is included in a block, which will change the state of chain. * Events: a piece of information comes from inside the chain, which may trigger some operation and change the state of chain. The chain starts from a initial state, and updated by Extrinsics or Events . Assume the current block height is N, a validator will takes the chain state at block N and apply changes on top of it, to construct the block N+1. Archive node \u00b6 Archive Nodes keeps all the historical state in storage. So it is convenient to use a archive node to query the state of a certain block height. For example, you can get the balance of Alice at block 20, or get the validator number at block 1024. As a result, running a archive node needs more disk space. Generally, archive nodes are used when you need to know the past states. Full node \u00b6 Full nodes keeps states of genesis block and serveral recently blocks in storage. By default, blocks which is older than 256 from the latest finalized block will be discarded. Besides, full node keeps extrinsics for all past blocks, so it can rebuild the chain without additional information. Full nodes need less disk space than archive node and is used when you just want to read the recently state of chain, submit or validate extrinsics. For running full node or archive node, please refer here . Light node \u00b6 Light nodes has only the runtime and current state, does not keep any of the historical state or extrinsics. Light nodes are useful for resource limited devices. Validator \u00b6 Validator is a special kind of archive node. Like archive nodes, validators keep all the historical state in storage. More importantly, validators are participants of the chain, which are responsible for validate blocks, voting for finality and so on. Validators will be rewarded for maintaining the chain and slashed for misbehavior. For running validator node, please refer here .","title":"Node Types"},{"location":"canarynet/node/node-type/#type-of-nodes","text":"Before an introduction to the distinct type of nodes, it is important to understand a few concepts: * Genesis block: defined by a chain spec file, which describes the initial status of a chain, including the initial wasm, balances, authority set and so on. * Extrinsics: a piece of information that comes from outside the chain and is included in a block, which will change the state of chain. * Events: a piece of information comes from inside the chain, which may trigger some operation and change the state of chain. The chain starts from a initial state, and updated by Extrinsics or Events . Assume the current block height is N, a validator will takes the chain state at block N and apply changes on top of it, to construct the block N+1.","title":"Type of Nodes"},{"location":"canarynet/node/node-type/#archive-node","text":"Archive Nodes keeps all the historical state in storage. So it is convenient to use a archive node to query the state of a certain block height. For example, you can get the balance of Alice at block 20, or get the validator number at block 1024. As a result, running a archive node needs more disk space. Generally, archive nodes are used when you need to know the past states.","title":"Archive node"},{"location":"canarynet/node/node-type/#full-node","text":"Full nodes keeps states of genesis block and serveral recently blocks in storage. By default, blocks which is older than 256 from the latest finalized block will be discarded. Besides, full node keeps extrinsics for all past blocks, so it can rebuild the chain without additional information. Full nodes need less disk space than archive node and is used when you just want to read the recently state of chain, submit or validate extrinsics. For running full node or archive node, please refer here .","title":"Full node"},{"location":"canarynet/node/node-type/#light-node","text":"Light nodes has only the runtime and current state, does not keep any of the historical state or extrinsics. Light nodes are useful for resource limited devices.","title":"Light node"},{"location":"canarynet/node/node-type/#validator","text":"Validator is a special kind of archive node. Like archive nodes, validators keep all the historical state in storage. More importantly, validators are participants of the chain, which are responsible for validate blocks, voting for finality and so on. Validators will be rewarded for maintaining the chain and slashed for misbehavior. For running validator node, please refer here .","title":"Validator"},{"location":"canarynet/node/run-full-node/","text":"Run Full Node \u00b6 Introduction \u00b6 According to description in Type of Nodes , you can run Full Node, Archive Node or Validator Node on ContextFree Network. In this section, we briefly introduce how to run Full Node or Archive Node For running Validator Node , please refer to the next section . Preparation \u00b6 Dependencies \u00b6 Install Docker Please go to this link to download the docker engine for your Operating System accordingly. Create a Local Directory To Store the Chain Data \u00b6 You may need sudo permission to run the following commands. Firstly create a folder to store the synchronized on-chain data mkdir /chain Change the ownership and permission of your local storage directory to current user sudo chown -R $(id -u):$(id -g) /chain Launch Node \u00b6 Launch Full Node \u00b6 Run the following command to launch a Full Node, you may need sudo permission: docker run -it \\ -v \"/chain:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -d \\ atactr/automata:contextfree-v0.1.0-rc4 \\ --node-type full \\ --name <YOUR_NODE_NAME> Which will return the c_ontainer ID of your node <YOUR_NODE_NAME> can be anything, but it's recommended to have something unique to make it easier to identify your node. Launch Archive Node \u00b6 Run the following command to launch a Archive Node, you may need sudo permission: docker run -it \\ -v \"/chain:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -d \\ atactr/automata:contextfree-v0.1.0-rc4 \\ --node-type archive \\ --name <YOUR_NODE_NAME> Which will return the container ID of your node <YOUR_NODE_NAME> can be anything, but it's recommended to have something unique to make it easier to identify your node. Check Launch Status \u00b6 Check whether your node downloading blocks by checking the logs docker logs --follow <YOUR_CONTAINER_ID> If it works fine, the beginning of the log should look like Take note of your node identity behind \"Local node identity is: ...\" . This will be very important for identifying your node on the Telemetry, as the node name can be duplicated. Notice that you should have a non-zero number of \"peers\" connected as shown in the image above. If the logs saying \"Error while dialing /dns/...\" , don't be panic, normally it may take a few minutes for the node to connect to the Telemetry server, after that the error will stop popping up.","title":"Run Full Node"},{"location":"canarynet/node/run-full-node/#run-full-node","text":"","title":"Run Full Node"},{"location":"canarynet/node/run-full-node/#introduction","text":"According to description in Type of Nodes , you can run Full Node, Archive Node or Validator Node on ContextFree Network. In this section, we briefly introduce how to run Full Node or Archive Node For running Validator Node , please refer to the next section .","title":"Introduction"},{"location":"canarynet/node/run-full-node/#preparation","text":"","title":"Preparation"},{"location":"canarynet/node/run-full-node/#dependencies","text":"Install Docker Please go to this link to download the docker engine for your Operating System accordingly.","title":"Dependencies"},{"location":"canarynet/node/run-full-node/#create-a-local-directory-to-store-the-chain-data","text":"You may need sudo permission to run the following commands. Firstly create a folder to store the synchronized on-chain data mkdir /chain Change the ownership and permission of your local storage directory to current user sudo chown -R $(id -u):$(id -g) /chain","title":"Create a Local Directory To Store the Chain Data"},{"location":"canarynet/node/run-full-node/#launch-node","text":"","title":"Launch Node"},{"location":"canarynet/node/run-full-node/#launch-full-node","text":"Run the following command to launch a Full Node, you may need sudo permission: docker run -it \\ -v \"/chain:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -d \\ atactr/automata:contextfree-v0.1.0-rc4 \\ --node-type full \\ --name <YOUR_NODE_NAME> Which will return the c_ontainer ID of your node <YOUR_NODE_NAME> can be anything, but it's recommended to have something unique to make it easier to identify your node.","title":"Launch Full Node"},{"location":"canarynet/node/run-full-node/#launch-archive-node","text":"Run the following command to launch a Archive Node, you may need sudo permission: docker run -it \\ -v \"/chain:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -d \\ atactr/automata:contextfree-v0.1.0-rc4 \\ --node-type archive \\ --name <YOUR_NODE_NAME> Which will return the container ID of your node <YOUR_NODE_NAME> can be anything, but it's recommended to have something unique to make it easier to identify your node.","title":"Launch Archive Node"},{"location":"canarynet/node/run-full-node/#check-launch-status","text":"Check whether your node downloading blocks by checking the logs docker logs --follow <YOUR_CONTAINER_ID> If it works fine, the beginning of the log should look like Take note of your node identity behind \"Local node identity is: ...\" . This will be very important for identifying your node on the Telemetry, as the node name can be duplicated. Notice that you should have a non-zero number of \"peers\" connected as shown in the image above. If the logs saying \"Error while dialing /dns/...\" , don't be panic, normally it may take a few minutes for the node to connect to the Telemetry server, after that the error will stop popping up.","title":"Check Launch Status"},{"location":"canarynet/node/run-validator/","text":"Run A Validator \u00b6 Introduction \u00b6 You may want to run a validator, which means if you are elected into the validator set, you will be able to earn rewards. To run a validator, you need to run a validator node and stake some tokens, we will show you how to do it step by step. Steps \u00b6 Install Dependencies \u00b6 Install Docker Please go to this link to download the docker engine for your Operating System accordingly. Create a Local Directory To Store the Chain Data \u00b6 You may need sudo permission to run the following commands. Firstly create a folder to store the synchronized on-chain data mkdir /chain Change the ownership and permission of your local storage directory to current user sudo chown -R $(id -u):$(id -g) /chain Launch the Validator Node \u00b6 Run the following command to launch a validator node, you may need sudo permission: docker run -it \\ -v \"/chain:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -d \\ atactr/automata:contextfree-v0.1.0-rc4 \\ --node-type validator \\ --name <YOUR_NODE_NAME> Which will return the container ID of your node <YOUR_NODE_NAME> can be anything, but it's recommended to have something unique to make it easier to identify your node. Check Launch Status \u00b6 Check whether your node downloading blocks by checking the logs docker logs --follow <YOUR_CONTAINER_ID> If it works fine, the beginning of the log should look like Take note of your node identity behind \"Local node identity is: ...\" . This will be very important for identifying your node on the Telemetry, as the node name can be duplicated. Notice that you should have a non-zero number of \"peers\" connected as shown in the image above. If the logs saying \"Error while dialing /dns/...\" , don't be panic, normally it may take a few minutes for the node to connect to the Telemetry server, after that the error will stop popping up. Get Session Keys Of Your Node \u00b6 Run the following command Install curl in your docker container: docker exec -t -u root <YOUR_CONTAINER_ID> bash -c 'apt-get update | apt-get -y install curl' Fetch Session Keys from your container: docker exec -t <YOUR_CONTAINER_ID> curl http://127.0.0.1:9933 -H \"Content-Type:application/json;charset=utf-8\" -d '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"author_rotateKeys\", \"params\": [] }' You will get a response like this { \"jsonrpc\": \"2.0\", \"result\":\"0xc05a9d093e4db4c1bde31977716e7a0a39d6f3d1f1bf749e7fec8371147de730af6860aeef81a11130c9fcd317b96e736f6c36141c28f382a18f9faf6e7df797eaa951ead00d12db10937003f0956e3d3444d1774d452ed045dbc1b84d1bf1471abf5d77bf5033845f01be1188a852c6f0ba703042b4d06d14314841c1096c50\", \"id\":1 } The content after \"result\" is the session keys of your validator node Set Up Accounts \u00b6 For running a validator, you need to set up two accounts: Stash account : This account holds funds bonded for staking, but delegates some functions to the Controller account. It can be kept in a cold wallet, meaning it can stays offline all the time. Controller account : This account acts on behalf of the Stash account, signalling decisions and necessary execution for staking. It only needs enough funds to pay transaction fees. For more details, refer to Polkadot Keys . For how to create accounts in ContextFree, you can refer here . Get Token \u00b6 Your Stash account and Controller account need to be funded with some native token If you already had some native token on other account, you can simply transfer to the stash and controller accounts you have created, using the dashboard by opening the Transfer page under the Accounts tab. If you don't have any native token, visit Get Token from Faucet to get some native token. Alternatively, if you have some ContextFree ERC20 token , you can follow the Token Bridge user guide to convert it into native token. Stake Tokens \u00b6 Visit the Automata Dashboard Go to the Staking section. Set Stash and Controller. Choose the stash account and controller account accordingly, set the value for staking and press Bond to submit the transaction. Set Session Keys \u00b6 Click Session Keys and set the session keys you got previously. If you are nominating someone, you need to stop nominating or you will not be able to set session keys. Set Validate Parameters \u00b6 Click Validate Set the value of reward commission percentage , which is the rate that your validator will be commissioned with. The remaining rewards will be split among your nominators. Besides, you can choose to accept nominating or not. Joining Validator Set \u00b6 If you go to the \"Staking\" tab, you will see a list of active validators currently running on the network. At the top of the page, it shows the number of validator slots that are available as well as the number of nodes that have signaled their intention to be a validator. You can go to the \"Waiting\" tab to double check to see whether your node is listed there. The validator set is refreshed every era. In the next era, if there is a slot available and your node is selected to join the validator set, your node will become an active validator. Until then, it will remain in the waiting queue. If your validator is not selected to become part of the validator set, it will remain in the waiting queue until it is. There is no need to re-start if you are not selected for the validator set in a particular era. However, it may be necessary to increase the number of native token staked or seek out nominators for your validator in order to join the validator set. Congratuation \u00b6 If you have followed all of these steps, and been selected to be a part of the validator set, you are now running a ContextFree validator!","title":"Join as Validator"},{"location":"canarynet/node/run-validator/#run-a-validator","text":"","title":"Run A Validator"},{"location":"canarynet/node/run-validator/#introduction","text":"You may want to run a validator, which means if you are elected into the validator set, you will be able to earn rewards. To run a validator, you need to run a validator node and stake some tokens, we will show you how to do it step by step.","title":"Introduction"},{"location":"canarynet/node/run-validator/#steps","text":"","title":"Steps"},{"location":"canarynet/node/run-validator/#install-dependencies","text":"Install Docker Please go to this link to download the docker engine for your Operating System accordingly.","title":"Install Dependencies"},{"location":"canarynet/node/run-validator/#create-a-local-directory-to-store-the-chain-data","text":"You may need sudo permission to run the following commands. Firstly create a folder to store the synchronized on-chain data mkdir /chain Change the ownership and permission of your local storage directory to current user sudo chown -R $(id -u):$(id -g) /chain","title":"Create a Local Directory To Store the Chain Data"},{"location":"canarynet/node/run-validator/#launch-the-validator-node","text":"Run the following command to launch a validator node, you may need sudo permission: docker run -it \\ -v \"/chain:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -d \\ atactr/automata:contextfree-v0.1.0-rc4 \\ --node-type validator \\ --name <YOUR_NODE_NAME> Which will return the container ID of your node <YOUR_NODE_NAME> can be anything, but it's recommended to have something unique to make it easier to identify your node.","title":"Launch the Validator Node"},{"location":"canarynet/node/run-validator/#check-launch-status","text":"Check whether your node downloading blocks by checking the logs docker logs --follow <YOUR_CONTAINER_ID> If it works fine, the beginning of the log should look like Take note of your node identity behind \"Local node identity is: ...\" . This will be very important for identifying your node on the Telemetry, as the node name can be duplicated. Notice that you should have a non-zero number of \"peers\" connected as shown in the image above. If the logs saying \"Error while dialing /dns/...\" , don't be panic, normally it may take a few minutes for the node to connect to the Telemetry server, after that the error will stop popping up.","title":"Check Launch Status"},{"location":"canarynet/node/run-validator/#get-session-keys-of-your-node","text":"Run the following command Install curl in your docker container: docker exec -t -u root <YOUR_CONTAINER_ID> bash -c 'apt-get update | apt-get -y install curl' Fetch Session Keys from your container: docker exec -t <YOUR_CONTAINER_ID> curl http://127.0.0.1:9933 -H \"Content-Type:application/json;charset=utf-8\" -d '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"author_rotateKeys\", \"params\": [] }' You will get a response like this { \"jsonrpc\": \"2.0\", \"result\":\"0xc05a9d093e4db4c1bde31977716e7a0a39d6f3d1f1bf749e7fec8371147de730af6860aeef81a11130c9fcd317b96e736f6c36141c28f382a18f9faf6e7df797eaa951ead00d12db10937003f0956e3d3444d1774d452ed045dbc1b84d1bf1471abf5d77bf5033845f01be1188a852c6f0ba703042b4d06d14314841c1096c50\", \"id\":1 } The content after \"result\" is the session keys of your validator node","title":"Get Session Keys Of Your Node"},{"location":"canarynet/node/run-validator/#set-up-accounts","text":"For running a validator, you need to set up two accounts: Stash account : This account holds funds bonded for staking, but delegates some functions to the Controller account. It can be kept in a cold wallet, meaning it can stays offline all the time. Controller account : This account acts on behalf of the Stash account, signalling decisions and necessary execution for staking. It only needs enough funds to pay transaction fees. For more details, refer to Polkadot Keys . For how to create accounts in ContextFree, you can refer here .","title":"Set Up Accounts"},{"location":"canarynet/node/run-validator/#get-token","text":"Your Stash account and Controller account need to be funded with some native token If you already had some native token on other account, you can simply transfer to the stash and controller accounts you have created, using the dashboard by opening the Transfer page under the Accounts tab. If you don't have any native token, visit Get Token from Faucet to get some native token. Alternatively, if you have some ContextFree ERC20 token , you can follow the Token Bridge user guide to convert it into native token.","title":"Get Token"},{"location":"canarynet/node/run-validator/#stake-tokens","text":"Visit the Automata Dashboard Go to the Staking section. Set Stash and Controller. Choose the stash account and controller account accordingly, set the value for staking and press Bond to submit the transaction.","title":"Stake Tokens"},{"location":"canarynet/node/run-validator/#set-session-keys","text":"Click Session Keys and set the session keys you got previously. If you are nominating someone, you need to stop nominating or you will not be able to set session keys.","title":"Set Session Keys"},{"location":"canarynet/node/run-validator/#set-validate-parameters","text":"Click Validate Set the value of reward commission percentage , which is the rate that your validator will be commissioned with. The remaining rewards will be split among your nominators. Besides, you can choose to accept nominating or not.","title":"Set Validate Parameters"},{"location":"canarynet/node/run-validator/#joining-validator-set","text":"If you go to the \"Staking\" tab, you will see a list of active validators currently running on the network. At the top of the page, it shows the number of validator slots that are available as well as the number of nodes that have signaled their intention to be a validator. You can go to the \"Waiting\" tab to double check to see whether your node is listed there. The validator set is refreshed every era. In the next era, if there is a slot available and your node is selected to join the validator set, your node will become an active validator. Until then, it will remain in the waiting queue. If your validator is not selected to become part of the validator set, it will remain in the waiting queue until it is. There is no need to re-start if you are not selected for the validator set in a particular era. However, it may be necessary to increase the number of native token staked or seek out nominators for your validator in order to join the validator set.","title":"Joining Validator Set"},{"location":"canarynet/node/run-validator/#congratuation","text":"If you have followed all of these steps, and been selected to be a part of the validator set, you are now running a ContextFree validator!","title":"Congratuation"},{"location":"canarynet/userguide/accounts/","text":"Accounts \u00b6 This document introduce you to the basics of ContextFree accounts. Account basic \u00b6 The address format used in ContextFree network is SS58 , which is a modification of Base-58-check from Bitcoin with some miner changes. More details can be found on the Substrate github wiki . Network Address type prefix Leading characters Example(Alice) Automata Network 2349 aA ContextFree Network 11820 a7 a7SvTrjvshEMePMEZpEkYMekuZMPpDwMNqfUx8N8ScEEQYfM8 FiniteState Network 13107 at ateYGxACWo2Yu8wVi7RGJQsEQLAB25xbAHkSRpzTqMabJ38zx Substrate default 42 5 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY As we known, the secret seed of account Alice is: 0xe5be9a5092b81bca64be81d212e7f2f9eba183bb7a90954f7b76361f6edb5c0a . In ContextFree network, the address of Alice will be a7SvTrjvshEMePMEZpEkYMekuZMPpDwMNqfUx8N8ScEEQYfM8 . But all addresses above are merely different representations of the same public key in a private-public keypair. In another word, the account in ContextFree network is compatible with other substrate-based chains. Create account \u00b6 There are several ways to create an ContextFree account, we will suggest you to use our official blockchain explorer . Create account using explorer \u00b6 Open official blockchain explorer of Automata, check the connected network on the left upper corner of web page. If the connected network is not ContextFree Network , click and choose Automata ContextFree in TEST NETWORKS . Click Accounts in the top menu and choose Accounts , you will enter the accounts page. Then click Add account and start to create a new account. You will see a auto generated mnemonic in the popup box, please copy this mnemonic and save it safely. Enter an alias for this account and create a password, we suggest you to use a strong and unique password. Click Save and we finish the process of creating an account. The newly created account will be show in the list, and there will be a auto downloaded file which describe the details of this account. Import existing account \u00b6 The process of importing an existing account into blockchain explorer is similar to the process of creating one. We will show you how to import the well known Alice account. 1. Override the auto generated Mnemonic or Raw seed with mnemonic or seed of your existing account. 2. Create an alias and enter the password, the imported account will be show in the list. Wallet \u00b6 Please refer to Wallet tutorial if you want to create and manage accounts in polkadot extention.","title":"Accounts"},{"location":"canarynet/userguide/accounts/#accounts","text":"This document introduce you to the basics of ContextFree accounts.","title":"Accounts"},{"location":"canarynet/userguide/accounts/#account-basic","text":"The address format used in ContextFree network is SS58 , which is a modification of Base-58-check from Bitcoin with some miner changes. More details can be found on the Substrate github wiki . Network Address type prefix Leading characters Example(Alice) Automata Network 2349 aA ContextFree Network 11820 a7 a7SvTrjvshEMePMEZpEkYMekuZMPpDwMNqfUx8N8ScEEQYfM8 FiniteState Network 13107 at ateYGxACWo2Yu8wVi7RGJQsEQLAB25xbAHkSRpzTqMabJ38zx Substrate default 42 5 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY As we known, the secret seed of account Alice is: 0xe5be9a5092b81bca64be81d212e7f2f9eba183bb7a90954f7b76361f6edb5c0a . In ContextFree network, the address of Alice will be a7SvTrjvshEMePMEZpEkYMekuZMPpDwMNqfUx8N8ScEEQYfM8 . But all addresses above are merely different representations of the same public key in a private-public keypair. In another word, the account in ContextFree network is compatible with other substrate-based chains.","title":"Account basic"},{"location":"canarynet/userguide/accounts/#create-account","text":"There are several ways to create an ContextFree account, we will suggest you to use our official blockchain explorer .","title":"Create account"},{"location":"canarynet/userguide/accounts/#create-account-using-explorer","text":"Open official blockchain explorer of Automata, check the connected network on the left upper corner of web page. If the connected network is not ContextFree Network , click and choose Automata ContextFree in TEST NETWORKS . Click Accounts in the top menu and choose Accounts , you will enter the accounts page. Then click Add account and start to create a new account. You will see a auto generated mnemonic in the popup box, please copy this mnemonic and save it safely. Enter an alias for this account and create a password, we suggest you to use a strong and unique password. Click Save and we finish the process of creating an account. The newly created account will be show in the list, and there will be a auto downloaded file which describe the details of this account.","title":"Create account using explorer"},{"location":"canarynet/userguide/accounts/#import-existing-account","text":"The process of importing an existing account into blockchain explorer is similar to the process of creating one. We will show you how to import the well known Alice account. 1. Override the auto generated Mnemonic or Raw seed with mnemonic or seed of your existing account. 2. Create an alias and enter the password, the imported account will be show in the list.","title":"Import existing account"},{"location":"canarynet/userguide/accounts/#wallet","text":"Please refer to Wallet tutorial if you want to create and manage accounts in polkadot extention.","title":"Wallet"},{"location":"canarynet/userguide/get-test-token/","text":"Get Test Token \u00b6 This is a guide on how to claim test token on the ContextFree Assume you have set up your wallet account, if not, please refer to here Use Automata Faucet \u00b6 Visit the Automata Faucet , you may need to login via Twitter account to get access to the faucet page. Get ContextFree Native Token \u00b6 Input your canary network wallet address under this tab, and press Submit . Then 10 CTX native token will be sent to your address, you can check on the Automata Dashboard . Notice: You can request funding for your address for once per 24 hours. Get ContextFree ERC20 Token on Ropsten Testnet \u00b6 Input your Ropsten ETH address under this tab, and press Submit . Then 10 CTX ERC20 token will be sent to your Ropsten address, you can check on Ropsten Explorer . However the ERC20 token cannot be utilized as native token on the canary network, you can follow the instruction here to use the Automata Token Bridge to convert it into the ContextFree native token. Notice: You can request funding for your address for once per 24 hours.","title":"Get Test Token"},{"location":"canarynet/userguide/get-test-token/#get-test-token","text":"This is a guide on how to claim test token on the ContextFree Assume you have set up your wallet account, if not, please refer to here","title":"Get Test Token"},{"location":"canarynet/userguide/get-test-token/#use-automata-faucet","text":"Visit the Automata Faucet , you may need to login via Twitter account to get access to the faucet page.","title":"Use Automata Faucet"},{"location":"canarynet/userguide/get-test-token/#get-contextfree-native-token","text":"Input your canary network wallet address under this tab, and press Submit . Then 10 CTX native token will be sent to your address, you can check on the Automata Dashboard . Notice: You can request funding for your address for once per 24 hours.","title":"Get ContextFree Native Token"},{"location":"canarynet/userguide/get-test-token/#get-contextfree-erc20-token-on-ropsten-testnet","text":"Input your Ropsten ETH address under this tab, and press Submit . Then 10 CTX ERC20 token will be sent to your Ropsten address, you can check on Ropsten Explorer . However the ERC20 token cannot be utilized as native token on the canary network, you can follow the instruction here to use the Automata Token Bridge to convert it into the ContextFree native token. Notice: You can request funding for your address for once per 24 hours.","title":"Get ContextFree ERC20 Token on Ropsten Testnet"},{"location":"canarynet/userguide/setupwallet/","text":"ContextFree Network Wallet Setup Guide \u00b6 This is a guide on how to get onto the Automata Canary Net for Chrome users(recommended). Go to website url - 'Dashboard.ata.network' You should reach a website which looks like the picture below. Hover over the Accounts taskbar and click on Accounts. Picture showing what is needed to be clicked. You should then reach this page. Then you must click on the link called polkadot-js extension on the page. This will direct you to an extension which needs to be downloaded. You should then add this to chrome. You must then click on the plugin to create an account. This process is very easy and just requires you to record your seed phrase, which should be noted to ensure you have a way to restore control of your account, create a username and then a password. You will then have an account. The account should look like this in the plugin. Once you have created your account, it will be necessary to refresh your page on Dashboard.ata.network. This will then prompt you to authorise polkadot{.js}, which you should approve. What the Authorize prompt looks like. After you have allowed the application access, you should then click on the settings tab at the top of the screen. Click on Settings. Then click on Metadata. Then click on update metadata. This will give you another prompt from polkadot{.js} asking to add the metadata to your extension instance. Click \u2018yes, do this metadata update\u2019 After you have done this, click on the polkadot{.js} plugin again. After this click on the three dots next to your account, click on the drop down box which currently says \u2018Allow Use On Any Chain\u2019 and change it to \u2018ContextFree Network.\u2019 After you have done this, refresh your page and click on Accounts again. If there is no exclamation mark next to your account then everything should be set up correctly. It should look like this. However, if there is an exclamation mark, then ensure that you have followed all the steps above. If you believe you have done all the steps properly, try the whole process once more and if you are still having problems then get in touch with us. If you have problems it would look like this. Now that you have set up everything, complete our google form with your name, email, Discord username, Telegram handle and your ContextFree Network wallet address and we will airdrop you some $CTX tokens for you to take part in the upcoming Canary Games. To participate in the Canary Games, register now with this form .","title":"Set up Wallet"},{"location":"canarynet/userguide/setupwallet/#contextfree-network-wallet-setup-guide","text":"This is a guide on how to get onto the Automata Canary Net for Chrome users(recommended). Go to website url - 'Dashboard.ata.network' You should reach a website which looks like the picture below. Hover over the Accounts taskbar and click on Accounts. Picture showing what is needed to be clicked. You should then reach this page. Then you must click on the link called polkadot-js extension on the page. This will direct you to an extension which needs to be downloaded. You should then add this to chrome. You must then click on the plugin to create an account. This process is very easy and just requires you to record your seed phrase, which should be noted to ensure you have a way to restore control of your account, create a username and then a password. You will then have an account. The account should look like this in the plugin. Once you have created your account, it will be necessary to refresh your page on Dashboard.ata.network. This will then prompt you to authorise polkadot{.js}, which you should approve. What the Authorize prompt looks like. After you have allowed the application access, you should then click on the settings tab at the top of the screen. Click on Settings. Then click on Metadata. Then click on update metadata. This will give you another prompt from polkadot{.js} asking to add the metadata to your extension instance. Click \u2018yes, do this metadata update\u2019 After you have done this, click on the polkadot{.js} plugin again. After this click on the three dots next to your account, click on the drop down box which currently says \u2018Allow Use On Any Chain\u2019 and change it to \u2018ContextFree Network.\u2019 After you have done this, refresh your page and click on Accounts again. If there is no exclamation mark next to your account then everything should be set up correctly. It should look like this. However, if there is an exclamation mark, then ensure that you have followed all the steps above. If you believe you have done all the steps properly, try the whole process once more and if you are still having problems then get in touch with us. If you have problems it would look like this. Now that you have set up everything, complete our google form with your name, email, Discord username, Telegram handle and your ContextFree Network wallet address and we will airdrop you some $CTX tokens for you to take part in the upcoming Canary Games. To participate in the Canary Games, register now with this form .","title":"ContextFree Network Wallet Setup Guide"},{"location":"canarynet/userguide/token-bridge/","text":"Automata ContextFree Token Bridge Tutorial \u00b6 Introduction \u00b6 A cross-chain bridge is a connection that allows the transfer of tokens from one chain to another. Both chains can have different protocols and rules, but the bridge provides a compatible way to interoperate securely on both sides. The Automata team has set up a cross-chain token bridge for ContextFree between EVM ( Ropsten testnet ) and Substrate-based chains( ContextFree canary network ) by adopting one of the currently available solutions ChainBridge built by ChainSafe . Tutorial \u00b6 Transfer ERC20 Token to Native Token \u00b6 Preparation \u00b6 To use the Automata Token Bridge, please ensure your explorer is Chrome and the following is installed: Metamask Wallet Extension Visit Automata Token Bridge . Click Connect on the prompted page. Set Up MetaMask \u00b6 Click Use Ethereum Wallet . Select MetaMask . Then you may need may need to enter password to unlock the MetaMask wallet extension if it hasn't been open for a while. Change the network in MetaMask to Ropsten Test Network . If you don't see the CTX token showing up in the assets, press Import tokens , enter the following specifications and press Add Custom Token : Token Contract Address: 0x8289b901CAC48EbBB1B5cb0049d1459EA1240EF7 Token Symbol: CTX Token Decimal: 18 Then Import Tokens , if you already had some CTX token, the balance will be showed. Let's go back to the web page for the token bridge, by now it should look like this: If not you can click Connect and repeat the above steps. Use the Bridge App \u00b6 Make sure the following fields are correct: Home network: Ethereum Ropsten . Destination Network: Automata ContextFree . Get some CTX ERC20 token if the balance is 0, please refer here . Make sure you have enough ETH on Ropsten Testnet to pay for the BridgeFee and transaction Gas Fee. If not, you can use Ropsten Ethereum Faucet to get some airdrop. Enter the amount of CTX you want to transfer. For the Destination Address, make sure that: the address starts with a7 . the address is valid by trying Add Contact on Automata Dashboard. double check the destination address is correct, once your token were sent to a wrong address it can never be claimed back. If everything looks okay, press Start transfer , confirm the Pre-flight check and press Start Transfer again. Then a MetaMask notification will be popped up to let you allow the website to spend your CTX token, press Confirm . Wait a moment for that transaction to be confirmed Another MetaMask notification will be prompted, which is to send a transaction to trigger the actual cross-chain bridging transfer, press Confirm . Then you should be able to see this In Transit , it usually takes a few minutes to finish the transferring, please be patient. Once the transferring has been completed, it will show Transfer completed Congratulations! You have completed your first cross-chain token transfer on Automata ContextFree! Go check the balance of the destination address on Automata Dashboard . If you can't see it, try Add contact in the Address book . Transfer Native Token to ERC20 Token \u00b6 Preparation \u00b6 To use the Automata Token Bridge, please ensure your explorer is Chrome and the following is installed: Polkadot{.js} Wallet Extension Visit Automata Token Bridge . Click Connect on the prompted page. Set Up Polkadot{.js} \u00b6 Click Use Substrate Wallet . Authorize the application to access the wallet by pressing Yes, allow this application access on the popped up Polkadot.js notification. If you haven't set up your wallet addresses, please refer here . Use the Bridge App \u00b6 After connecting you Substrate wallet and setting up your Polkadot.js wallet extension, the Token Bridge App should be like this: Click Select an account , you should be able to see a list of addresses starting with a7 , which are ContextFree addresses injected from your Polkadot.js wallet extension. Select the address you want to transfer native token from, the page now should look like: Make sure the following fields are correct: Select account: The address of your native token sender. Destination Network: Ethereum Ropsten . Get some native CTX test token if the balance is 0, please refer here . Make sure you have enough balance to pay for the Bridge Fee and the total amount to transfer. Fill in the Destination Address , which will be an Ethereum address on Ropsten Test Network starting with 0x . Press Start transfer , you will be required to input the password to sign the transaction. Wait for your transfer to complete, it may take a few minutes. After the webpage showing Transfer completed . You can go to Ethereum Ropsten Explorer to check the balance of ContextFree ERC20 Token of your destination address.","title":"Use Token Bridge"},{"location":"canarynet/userguide/token-bridge/#automata-contextfree-token-bridge-tutorial","text":"","title":"Automata ContextFree Token Bridge Tutorial"},{"location":"canarynet/userguide/token-bridge/#introduction","text":"A cross-chain bridge is a connection that allows the transfer of tokens from one chain to another. Both chains can have different protocols and rules, but the bridge provides a compatible way to interoperate securely on both sides. The Automata team has set up a cross-chain token bridge for ContextFree between EVM ( Ropsten testnet ) and Substrate-based chains( ContextFree canary network ) by adopting one of the currently available solutions ChainBridge built by ChainSafe .","title":"Introduction"},{"location":"canarynet/userguide/token-bridge/#tutorial","text":"","title":"Tutorial"},{"location":"canarynet/userguide/token-bridge/#transfer-erc20-token-to-native-token","text":"","title":"Transfer ERC20 Token to Native Token"},{"location":"canarynet/userguide/token-bridge/#preparation","text":"To use the Automata Token Bridge, please ensure your explorer is Chrome and the following is installed: Metamask Wallet Extension Visit Automata Token Bridge . Click Connect on the prompted page.","title":"Preparation"},{"location":"canarynet/userguide/token-bridge/#set-up-metamask","text":"Click Use Ethereum Wallet . Select MetaMask . Then you may need may need to enter password to unlock the MetaMask wallet extension if it hasn't been open for a while. Change the network in MetaMask to Ropsten Test Network . If you don't see the CTX token showing up in the assets, press Import tokens , enter the following specifications and press Add Custom Token : Token Contract Address: 0x8289b901CAC48EbBB1B5cb0049d1459EA1240EF7 Token Symbol: CTX Token Decimal: 18 Then Import Tokens , if you already had some CTX token, the balance will be showed. Let's go back to the web page for the token bridge, by now it should look like this: If not you can click Connect and repeat the above steps.","title":"Set Up MetaMask"},{"location":"canarynet/userguide/token-bridge/#use-the-bridge-app","text":"Make sure the following fields are correct: Home network: Ethereum Ropsten . Destination Network: Automata ContextFree . Get some CTX ERC20 token if the balance is 0, please refer here . Make sure you have enough ETH on Ropsten Testnet to pay for the BridgeFee and transaction Gas Fee. If not, you can use Ropsten Ethereum Faucet to get some airdrop. Enter the amount of CTX you want to transfer. For the Destination Address, make sure that: the address starts with a7 . the address is valid by trying Add Contact on Automata Dashboard. double check the destination address is correct, once your token were sent to a wrong address it can never be claimed back. If everything looks okay, press Start transfer , confirm the Pre-flight check and press Start Transfer again. Then a MetaMask notification will be popped up to let you allow the website to spend your CTX token, press Confirm . Wait a moment for that transaction to be confirmed Another MetaMask notification will be prompted, which is to send a transaction to trigger the actual cross-chain bridging transfer, press Confirm . Then you should be able to see this In Transit , it usually takes a few minutes to finish the transferring, please be patient. Once the transferring has been completed, it will show Transfer completed Congratulations! You have completed your first cross-chain token transfer on Automata ContextFree! Go check the balance of the destination address on Automata Dashboard . If you can't see it, try Add contact in the Address book .","title":"Use the Bridge App"},{"location":"canarynet/userguide/token-bridge/#transfer-native-token-to-erc20-token","text":"","title":"Transfer Native Token to ERC20 Token"},{"location":"canarynet/userguide/token-bridge/#preparation_1","text":"To use the Automata Token Bridge, please ensure your explorer is Chrome and the following is installed: Polkadot{.js} Wallet Extension Visit Automata Token Bridge . Click Connect on the prompted page.","title":"Preparation"},{"location":"canarynet/userguide/token-bridge/#set-up-polkadotjs","text":"Click Use Substrate Wallet . Authorize the application to access the wallet by pressing Yes, allow this application access on the popped up Polkadot.js notification. If you haven't set up your wallet addresses, please refer here .","title":"Set Up Polkadot{.js}"},{"location":"canarynet/userguide/token-bridge/#use-the-bridge-app_1","text":"After connecting you Substrate wallet and setting up your Polkadot.js wallet extension, the Token Bridge App should be like this: Click Select an account , you should be able to see a list of addresses starting with a7 , which are ContextFree addresses injected from your Polkadot.js wallet extension. Select the address you want to transfer native token from, the page now should look like: Make sure the following fields are correct: Select account: The address of your native token sender. Destination Network: Ethereum Ropsten . Get some native CTX test token if the balance is 0, please refer here . Make sure you have enough balance to pay for the Bridge Fee and the total amount to transfer. Fill in the Destination Address , which will be an Ethereum address on Ropsten Test Network starting with 0x . Press Start transfer , you will be required to input the password to sign the transaction. Wait for your transfer to complete, it may take a few minutes. After the webpage showing Transfer completed . You can go to Ethereum Ropsten Explorer to check the balance of ContextFree ERC20 Token of your destination address.","title":"Use the Bridge App"},{"location":"conveyor/overview/","text":"Automata Conveyor \u00b6 Automata Conveyor is a service that ingests and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering. When transactions are fed into Conveyor, it determines the order of the incoming transactions and makes it impossible for block producers to perform the following: Inject new transactions into the Conveyor output: The inserted transactions bypassing Conveyor is detectable by anyone because of signature mismatch. Delete ordered transactions: Transactions accepted by Conveyor are broadcasted everywhere so transactions cannot be deleted unless ALL block producers are colluding and censoring the transactions at the same time. From the DEX\u2019s perspective, they can choose to accept either Ordered transactions from Automata\u2019s Conveyor which is free from transaction reordering and other front-running transactions Other unordered transactions (which include front-running etc) that may negatively impact their users","title":"Overview"},{"location":"conveyor/overview/#automata-conveyor","text":"Automata Conveyor is a service that ingests and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering. When transactions are fed into Conveyor, it determines the order of the incoming transactions and makes it impossible for block producers to perform the following: Inject new transactions into the Conveyor output: The inserted transactions bypassing Conveyor is detectable by anyone because of signature mismatch. Delete ordered transactions: Transactions accepted by Conveyor are broadcasted everywhere so transactions cannot be deleted unless ALL block producers are colluding and censoring the transactions at the same time. From the DEX\u2019s perspective, they can choose to accept either Ordered transactions from Automata\u2019s Conveyor which is free from transaction reordering and other front-running transactions Other unordered transactions (which include front-running etc) that may negatively impact their users","title":"Automata Conveyor"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/","text":"Controller \u00b6 The prevention of anti-front-running is implemented by requiring that all method calls to the DEX must be only invoked by the Geode. The user submits a request to the Geode by signing the message without spending gas. The Geode later delegates that request to the DEX for a fee that is deducted from the output token. constructor() \u00b6 constructor ( address _relayer , address _router , address _factory ); Initializes the Controller, Uniswap Factory, and Router contracts and assigns a relayer. relayers \u00b6 mapping ( address => bool ) public relayers ; Key-value pair map that keeps track of the trusted relayers. Parameter Type key address Input address value bool True : address is a trusted relayer. False : otherwise uniswapV2TrustedPair \u00b6 mapping ( address => bool ) public uniswapV2TrustedPair ; Key-value pair map that keeps track of the trusted Uniswap token pair addresses . Parameter Type key address Input address value bool True : address is a trusted pair. False : otherwise relayerOnly() \u00b6 modifier relayerOnly (); Verifies msg.sender is a trusted relayer address, otherwise reverts the function call. setRelayer() \u00b6 function setRelayer ( address _relayer ) public onlyOwner () Assigns the input address as a trusted relayer, can only be invoked by the contract owner. Parameter Type _relayer address Input address isTrustedUniswapV2Pair() \u00b6 function isTrustedUniswapV2Pair ( address pair ) external override returns ( bool ); Checks the input address to determine whether it is a trusted Uniswap pair address or not, returns bool . Parameter Type pair address Input address addTrustedUniswapV2Pair() \u00b6 function addTrustedUniswapV2Pair ( address pair ) public onlyOwner (); Adds the input address as a trusted Uniswap pair address, can only be invoked by the contract owner. Parameter Type pair address Input address removeTrustedUniswapV2Pair() \u00b6 function removeTrustedUniswapV2Pair ( address pair ) public onlyOwner (); Removes the pair address from the uniswapV2TrustedPair map, can only be invoked by the contract owner. Parameter Type pair address Input address gTokenTransferFrom() \u00b6 function gTokenTransferFrom ( address asset , address from , address to , uint256 amount ) public relayerOnly (); Transfers ERC20 tokens from a sender address to a recipient address, can only be invoked by a relayer. Parameter Type asset address The address of the ERC20 token from address Sender address to address Recipient address amount uint256 Amount of tokens to be transferred uniswapV2AddLiquidity() \u00b6 function uniswapV2AddLiquidity ( address from , address tokenA , address tokenB , uint256 amountADesired , uint256 amountBDesired , uint256 amountAMin , uint256 amountBMin , address to , uint256 deadline , bool gasIsTokenA ) public relayerOnly (); This method initially checks for either token A or B balance (depending on gasIsTokenA ), to make sure that the user could pay for gas. Then, deducts the token amount, which is transferred to the relayer. Supplies the token pair to the Uniswap liquidity pool, can only be invoked by a relayer and input tokens must be both wrapped tokens. Any leftover tokens that are not added to the liquidity pool will be refunded to the sender. Parameter Type from address The sender address tokenA address Wrapped Token A address tokenB address Wrapped Token B address amountADesired uint256 The amount of A added to the liquidity pool if the B/A price <= ( amountofBDesired / amountofADesired ) price amountBDesired uint256 The amount of B added to the liquidity pool if the A/B price <= ( amountofADesired / amountofBDesired ) price amountAMin uint256 Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired amountBMin uint256 Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired to address The recipient address of the liquidity token. In this project, it is most likely the sender's address, since they provided liquidity, they should be entitled to getting rewarded with liquidity tokens deadline uint256 Unix timestamp after which the transaction is reverted gasIsTokenA bool User to pay gas in Token A or Token B uniswapV2SwapExactTokensForTokens() \u00b6 function uniswapV2SwapExactTokensForTokens ( address from , uint256 amountIn , uint256 amountOutMin , address [] calldata path , address to , uint256 deadline ) public relayerOnly (); This method initially checks for the balance of the input token, to make sure that the user could pay for gas. Then after the swapping of tokens, deducts the output token amount, which is transferred to the relayer. Swaps an exact amount of input tokens for as much of output tokens as possible, can only be invoked by a relayer. Any leftover tokens that are not swapped will be refunded to the sender. Parameter Type from address The sender address amountIn uint256 The amount of input tokens to be sent amountOutMin uint256 The minimum amount of tokens that must be received, otherwise the transaction reverts path address[] An array of token addresses. path.length >= 2 to address Recipient of the output tokens. In this project, it is also the sender's address deadline uint256 Unix timestamp after which the transaction is reverted uniswapV2SwapTokensForExactTokens() \u00b6 function uniswapV2SwapTokensForExactTokens ( address from , uint256 amountIn , uint256 amountOutMin , address [] calldata path , address to , uint256 deadline ) public relayerOnly (); This method initially checks for the balance of the input token, to make sure that the user could pay for gas. Then after the swapping of tokens, deducts the output token amount, which is transferred to the relayer. Swaps an amount of input tokens for exact amount of output tokens, can only be invoked by a relayer. Any leftover tokens that are not swapped will be refunded to the sender. Parameter Type from address The sender address amountInMax uint256 The minimum amount of tokens that must be sent, otherwise the transaction reverts amountOut uint256 The amount of output tokens to be sents path address[] An array of token addresses. path.length >= 2 to address Recipient of the output tokens. In this project, it is also the sender's address deadline uint256 Unix timestamp after which the transaction is reverted","title":"Controller"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#controller","text":"The prevention of anti-front-running is implemented by requiring that all method calls to the DEX must be only invoked by the Geode. The user submits a request to the Geode by signing the message without spending gas. The Geode later delegates that request to the DEX for a fee that is deducted from the output token.","title":"Controller"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#constructor","text":"constructor ( address _relayer , address _router , address _factory ); Initializes the Controller, Uniswap Factory, and Router contracts and assigns a relayer.","title":"constructor()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#relayers","text":"mapping ( address => bool ) public relayers ; Key-value pair map that keeps track of the trusted relayers. Parameter Type key address Input address value bool True : address is a trusted relayer. False : otherwise","title":"relayers"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#uniswapv2trustedpair","text":"mapping ( address => bool ) public uniswapV2TrustedPair ; Key-value pair map that keeps track of the trusted Uniswap token pair addresses . Parameter Type key address Input address value bool True : address is a trusted pair. False : otherwise","title":"uniswapV2TrustedPair"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#relayeronly","text":"modifier relayerOnly (); Verifies msg.sender is a trusted relayer address, otherwise reverts the function call.","title":"relayerOnly()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#setrelayer","text":"function setRelayer ( address _relayer ) public onlyOwner () Assigns the input address as a trusted relayer, can only be invoked by the contract owner. Parameter Type _relayer address Input address","title":"setRelayer()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#istrusteduniswapv2pair","text":"function isTrustedUniswapV2Pair ( address pair ) external override returns ( bool ); Checks the input address to determine whether it is a trusted Uniswap pair address or not, returns bool . Parameter Type pair address Input address","title":"isTrustedUniswapV2Pair()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#addtrusteduniswapv2pair","text":"function addTrustedUniswapV2Pair ( address pair ) public onlyOwner (); Adds the input address as a trusted Uniswap pair address, can only be invoked by the contract owner. Parameter Type pair address Input address","title":"addTrustedUniswapV2Pair()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#removetrusteduniswapv2pair","text":"function removeTrustedUniswapV2Pair ( address pair ) public onlyOwner (); Removes the pair address from the uniswapV2TrustedPair map, can only be invoked by the contract owner. Parameter Type pair address Input address","title":"removeTrustedUniswapV2Pair()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#gtokentransferfrom","text":"function gTokenTransferFrom ( address asset , address from , address to , uint256 amount ) public relayerOnly (); Transfers ERC20 tokens from a sender address to a recipient address, can only be invoked by a relayer. Parameter Type asset address The address of the ERC20 token from address Sender address to address Recipient address amount uint256 Amount of tokens to be transferred","title":"gTokenTransferFrom()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#uniswapv2addliquidity","text":"function uniswapV2AddLiquidity ( address from , address tokenA , address tokenB , uint256 amountADesired , uint256 amountBDesired , uint256 amountAMin , uint256 amountBMin , address to , uint256 deadline , bool gasIsTokenA ) public relayerOnly (); This method initially checks for either token A or B balance (depending on gasIsTokenA ), to make sure that the user could pay for gas. Then, deducts the token amount, which is transferred to the relayer. Supplies the token pair to the Uniswap liquidity pool, can only be invoked by a relayer and input tokens must be both wrapped tokens. Any leftover tokens that are not added to the liquidity pool will be refunded to the sender. Parameter Type from address The sender address tokenA address Wrapped Token A address tokenB address Wrapped Token B address amountADesired uint256 The amount of A added to the liquidity pool if the B/A price <= ( amountofBDesired / amountofADesired ) price amountBDesired uint256 The amount of B added to the liquidity pool if the A/B price <= ( amountofADesired / amountofBDesired ) price amountAMin uint256 Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired amountBMin uint256 Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired to address The recipient address of the liquidity token. In this project, it is most likely the sender's address, since they provided liquidity, they should be entitled to getting rewarded with liquidity tokens deadline uint256 Unix timestamp after which the transaction is reverted gasIsTokenA bool User to pay gas in Token A or Token B","title":"uniswapV2AddLiquidity()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#uniswapv2swapexacttokensfortokens","text":"function uniswapV2SwapExactTokensForTokens ( address from , uint256 amountIn , uint256 amountOutMin , address [] calldata path , address to , uint256 deadline ) public relayerOnly (); This method initially checks for the balance of the input token, to make sure that the user could pay for gas. Then after the swapping of tokens, deducts the output token amount, which is transferred to the relayer. Swaps an exact amount of input tokens for as much of output tokens as possible, can only be invoked by a relayer. Any leftover tokens that are not swapped will be refunded to the sender. Parameter Type from address The sender address amountIn uint256 The amount of input tokens to be sent amountOutMin uint256 The minimum amount of tokens that must be received, otherwise the transaction reverts path address[] An array of token addresses. path.length >= 2 to address Recipient of the output tokens. In this project, it is also the sender's address deadline uint256 Unix timestamp after which the transaction is reverted","title":"uniswapV2SwapExactTokensForTokens()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#uniswapv2swaptokensforexacttokens","text":"function uniswapV2SwapTokensForExactTokens ( address from , uint256 amountIn , uint256 amountOutMin , address [] calldata path , address to , uint256 deadline ) public relayerOnly (); This method initially checks for the balance of the input token, to make sure that the user could pay for gas. Then after the swapping of tokens, deducts the output token amount, which is transferred to the relayer. Swaps an amount of input tokens for exact amount of output tokens, can only be invoked by a relayer. Any leftover tokens that are not swapped will be refunded to the sender. Parameter Type from address The sender address amountInMax uint256 The minimum amount of tokens that must be sent, otherwise the transaction reverts amountOut uint256 The amount of output tokens to be sents path address[] An array of token addresses. path.length >= 2 to address Recipient of the output tokens. In this project, it is also the sender's address deadline uint256 Unix timestamp after which the transaction is reverted","title":"uniswapV2SwapTokensForExactTokens()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/","text":"gToken \u00b6 The goal of gTokens is to achieve front-running resistance on DEXs such as Uniswap. When two different gTokens are swapped, users can rest assured that the swapping transaction will not be attacked by front-running bots or malicious miners. This is achieved by inheriting the ERC20 contract, with modified function methods. Methods such as transferFrom() requires that it has to be invoked only from a trusted relayer. constructor() \u00b6 constructor ( address _token , address _controller ); Initializes the contract, then wraps the ERC20 token and assigns the Controller contract instance. Parameter Type _token address The ERC20 Token Address _controller address The address of the Controller instance onlyController() \u00b6 modifier onlyController (); Verifies msg.sender is the Controller address. Otherwise, reverts function calls. setController() \u00b6 function setController ( address _controller ) public onlyOwner (); Sets the Controller instance, can only be invoked by the contract owner. Parameter Type _controller address The address of the Controller instance transferFrom() \u00b6 function transferFrom ( address sender , address recipient , uint256 amount ) public override returns ( bool ); Transfers gTokens from a given address to the recipient. The sender is always the address of the Controller , the transaction is not necessarily originated from the Controller contract itself, as long as the origin address is one of the trusted relayers. For the direct call method, see internalTransferFrom() . Parameter Type sender address The address of a trusted relayer recipient address The recipient's address, most likely a token pair address. For example, an address returned by Uniswap's getPair(tokenA, tokenB) . amount uint256 The amount of token to be transferred. This method reverts if it is not invoked from a trusted relayer. Otherwise, returns true. transfer() \u00b6 function transfer ( address recipient , uint256 amount ) public override returns ( bool ); Transfers gTokens to a recipient. This method can only be invoked by a trusted token pair. Parameter Type recipient address The recipient's address amount uint256 The amount of token to be transferred internalTransferFrom() \u00b6 function internalTransferFrom ( address sender , address recipient , uint256 amount ) public onlyController (); Transfers gTokens from a given address to the recipient, similar to transferFrom() . This method can only be invoked directly from the Controller contract. Parameter Type sender address The sender's address recipient address The recipient's address amount uint256 The amount of token to be transferred deposit() \u00b6 function deposit ( uint256 amount ) public ; Wraps ERC20 token to a gToken. The gToken smart contract stores an amount of ERC20 token as a reserve and mints the same amount of wrapped ERC20 token. Parameter Type amount uint256 The amount of token to be transferred withdraw() \u00b6 function withdraw ( uint256 amount ) public ; Withdraws ERC20 token from the smart contract and burns the wrapped token. Parameter Type amount uint256 The amount of token to be transferred","title":"gToken"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#gtoken","text":"The goal of gTokens is to achieve front-running resistance on DEXs such as Uniswap. When two different gTokens are swapped, users can rest assured that the swapping transaction will not be attacked by front-running bots or malicious miners. This is achieved by inheriting the ERC20 contract, with modified function methods. Methods such as transferFrom() requires that it has to be invoked only from a trusted relayer.","title":"gToken"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#constructor","text":"constructor ( address _token , address _controller ); Initializes the contract, then wraps the ERC20 token and assigns the Controller contract instance. Parameter Type _token address The ERC20 Token Address _controller address The address of the Controller instance","title":"constructor()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#onlycontroller","text":"modifier onlyController (); Verifies msg.sender is the Controller address. Otherwise, reverts function calls.","title":"onlyController()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#setcontroller","text":"function setController ( address _controller ) public onlyOwner (); Sets the Controller instance, can only be invoked by the contract owner. Parameter Type _controller address The address of the Controller instance","title":"setController()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#transferfrom","text":"function transferFrom ( address sender , address recipient , uint256 amount ) public override returns ( bool ); Transfers gTokens from a given address to the recipient. The sender is always the address of the Controller , the transaction is not necessarily originated from the Controller contract itself, as long as the origin address is one of the trusted relayers. For the direct call method, see internalTransferFrom() . Parameter Type sender address The address of a trusted relayer recipient address The recipient's address, most likely a token pair address. For example, an address returned by Uniswap's getPair(tokenA, tokenB) . amount uint256 The amount of token to be transferred. This method reverts if it is not invoked from a trusted relayer. Otherwise, returns true.","title":"transferFrom()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#transfer","text":"function transfer ( address recipient , uint256 amount ) public override returns ( bool ); Transfers gTokens to a recipient. This method can only be invoked by a trusted token pair. Parameter Type recipient address The recipient's address amount uint256 The amount of token to be transferred","title":"transfer()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#internaltransferfrom","text":"function internalTransferFrom ( address sender , address recipient , uint256 amount ) public onlyController (); Transfers gTokens from a given address to the recipient, similar to transferFrom() . This method can only be invoked directly from the Controller contract. Parameter Type sender address The sender's address recipient address The recipient's address amount uint256 The amount of token to be transferred","title":"internalTransferFrom()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#deposit","text":"function deposit ( uint256 amount ) public ; Wraps ERC20 token to a gToken. The gToken smart contract stores an amount of ERC20 token as a reserve and mints the same amount of wrapped ERC20 token. Parameter Type amount uint256 The amount of token to be transferred","title":"deposit()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#withdraw","text":"function withdraw ( uint256 amount ) public ; Withdraws ERC20 token from the smart contract and burns the wrapped token. Parameter Type amount uint256 The amount of token to be transferred","title":"withdraw()"},{"location":"conveyor/conveyorv1/automata-conveyor-overview/","text":"Overview \u00b6 Automata Conveyor is an anti-front-running service that ingests and outputs transactions in a determined order. Automata Conveyor currently has the following components: gToken smart contract : inherits the ERC20 contract with modified function methods that must be invoked by trusted Geode-provided addresses. Controller smart contract : interacts with the users and facilitates the transfer of gTokens. External calls to any functions in the contract from any addresses other than the trusted relayers will be reverted. Automata Conciliator : TBA The following is an overview of the architecture. Note The Geode is an on-chain computation resource provided by the Automata network. Smart Contract Call Graph \u00b6 The following call graph details the interaction among smart contracts.","title":"Overview"},{"location":"conveyor/conveyorv1/automata-conveyor-overview/#overview","text":"Automata Conveyor is an anti-front-running service that ingests and outputs transactions in a determined order. Automata Conveyor currently has the following components: gToken smart contract : inherits the ERC20 contract with modified function methods that must be invoked by trusted Geode-provided addresses. Controller smart contract : interacts with the users and facilitates the transfer of gTokens. External calls to any functions in the contract from any addresses other than the trusted relayers will be reverted. Automata Conciliator : TBA The following is an overview of the architecture. Note The Geode is an on-chain computation resource provided by the Automata network.","title":"Overview"},{"location":"conveyor/conveyorv1/automata-conveyor-overview/#smart-contract-call-graph","text":"The following call graph details the interaction among smart contracts.","title":"Smart Contract Call Graph"},{"location":"conveyor/conveyorv1/fee-contract/","text":"Fee.sol \u00b6 The contract fetches real-time price feed from Chainlink Oracles and converts the gas fee amount to an equivalent token price. admin \u00b6 mapping ( address => bool ) admins ; Key-value pair map that keeps track of the contract admin. Parameter Type key address input addresses value bool True: the address is an admin, False: otherwise priceContracts \u00b6 mapping ( bytes => address ) public priceContracts ; Key-value pair map that stores the address of a Chainlink pricefeed oracle contract. Parameter Type key bytes The input price feed index, with the format: <network>-<token>-eth . For example, to query the USDC/ETH price from the Mainnet, enter main-usdc-eth value address The Chainlink oracle address tokensMap \u00b6 mapping ( address => bytes ) public tokensMap ; Key-value pair mapping tokens to their contract addresses. Parameter Type key address The ERC20 token address value bytes The input price feed index, as defined in priceContracts constructor() \u00b6 constructor () public ; Assigns the deployer as a default admin, and pre-assigns the following price feed: main-usdc-eth main-uni-eth kovan-usdc-eth onlyAdmin() \u00b6 modifier onlyAdmin (); Verifies msg.sender is a contract admin. modifyAdmin() \u00b6 function modifyAdmin ( address input , bool isAdmin ) public onlyAdmin (); Adds or removes admin privilege to or from the input address. Parameter Type input address The input address to be given or revoked admin privilege isAdmin bool true : assigns admin, false : revokes admin addPriceFeed() \u00b6 function addPriceFeed ( string memory priceIndex , address feed , address token ) public onlyAdmin (); Adds a new price feed, then maps to the token address. It can only be invoked by an admin. To find more oracle addresses, check out the Chainlink docs . Parameter Type priceIndex string The input price feed index, as defined in priceContracts feed address The address of the Chainlink price feed token address The ERC20 token address gasPrice() \u00b6 function getPrice ( address token ) public view returns ( int256 ); Gets the real time price data from Chainlink in 18 decimals. Parameter Type token address The ERC20 Token address calculateGasInTokens() \u00b6 function calculateGasInTokens ( address token , uint256 gas , uint256 weiPerToken ) public view returns ( uint256 ) Returns the amount of tokens equivalent to the gas fee. Parameter Type token address The ERC20 token address gas uint256 The gas fee weiPerToken uint256 The Wei amount per token","title":"`Fee.sol`"},{"location":"conveyor/conveyorv1/fee-contract/#feesol","text":"The contract fetches real-time price feed from Chainlink Oracles and converts the gas fee amount to an equivalent token price.","title":"Fee.sol"},{"location":"conveyor/conveyorv1/fee-contract/#admin","text":"mapping ( address => bool ) admins ; Key-value pair map that keeps track of the contract admin. Parameter Type key address input addresses value bool True: the address is an admin, False: otherwise","title":"admin"},{"location":"conveyor/conveyorv1/fee-contract/#pricecontracts","text":"mapping ( bytes => address ) public priceContracts ; Key-value pair map that stores the address of a Chainlink pricefeed oracle contract. Parameter Type key bytes The input price feed index, with the format: <network>-<token>-eth . For example, to query the USDC/ETH price from the Mainnet, enter main-usdc-eth value address The Chainlink oracle address","title":"priceContracts"},{"location":"conveyor/conveyorv1/fee-contract/#tokensmap","text":"mapping ( address => bytes ) public tokensMap ; Key-value pair mapping tokens to their contract addresses. Parameter Type key address The ERC20 token address value bytes The input price feed index, as defined in priceContracts","title":"tokensMap"},{"location":"conveyor/conveyorv1/fee-contract/#constructor","text":"constructor () public ; Assigns the deployer as a default admin, and pre-assigns the following price feed: main-usdc-eth main-uni-eth kovan-usdc-eth","title":"constructor()"},{"location":"conveyor/conveyorv1/fee-contract/#onlyadmin","text":"modifier onlyAdmin (); Verifies msg.sender is a contract admin.","title":"onlyAdmin()"},{"location":"conveyor/conveyorv1/fee-contract/#modifyadmin","text":"function modifyAdmin ( address input , bool isAdmin ) public onlyAdmin (); Adds or removes admin privilege to or from the input address. Parameter Type input address The input address to be given or revoked admin privilege isAdmin bool true : assigns admin, false : revokes admin","title":"modifyAdmin()"},{"location":"conveyor/conveyorv1/fee-contract/#addpricefeed","text":"function addPriceFeed ( string memory priceIndex , address feed , address token ) public onlyAdmin (); Adds a new price feed, then maps to the token address. It can only be invoked by an admin. To find more oracle addresses, check out the Chainlink docs . Parameter Type priceIndex string The input price feed index, as defined in priceContracts feed address The address of the Chainlink price feed token address The ERC20 token address","title":"addPriceFeed()"},{"location":"conveyor/conveyorv1/fee-contract/#gasprice","text":"function getPrice ( address token ) public view returns ( int256 ); Gets the real time price data from Chainlink in 18 decimals. Parameter Type token address The ERC20 Token address","title":"gasPrice()"},{"location":"conveyor/conveyorv1/fee-contract/#calculategasintokens","text":"function calculateGasInTokens ( address token , uint256 gas , uint256 weiPerToken ) public view returns ( uint256 ) Returns the amount of tokens equivalent to the gas fee. Parameter Type token address The ERC20 token address gas uint256 The gas fee weiPerToken uint256 The Wei amount per token","title":"calculateGasInTokens()"},{"location":"conveyor/conveyorv1/fee/","text":"Fee System \u00b6 Overview: \u00b6 1) The user submits a request to the Geode to perform a transaction. For example, swapping 100 gUSDC for 100 gDAI. swapExactTokensForTokens() Transitioning to Step 2: The Geode verifies that the amount of input token (USDC) is sufficient to pay for gas. The Geode can do this by simply calling the getPrice() method from Fee.sol to get USDC/ETH price in 18 decimals. For example, 1 USDC = 0.000361 ETH would yield 361000000000000. After Geode confirmed the user meets the minimum fee requirement, see step 2. 2) The Geode estimates the gas limit and the gas price. The Controller would capture this information to perform another input token check on step 3. 3) After the Controller finalizes the gas fee check, the Controller sends the transaction to UniswapRouter02 to perform the swap. The Geode would pay the gas fee \"out of pocket\" here, to be reimbursed later on step 4. Then, calculates the actual amount of gas consumption at this point. 4) Let's say the fast gas price is 49 gWei, with an average gas limit of 200,000 to perform a swap, the total gas fee (at the time of writing this) is 0.0098 ETH. The Controller then automatically allocates 25.48 gDAI to reimburse the Geode (or locks it in the contract itself). The user gets the remaining 74.52 gDAI. Price Feed oracles that are available on Chainlink \u00b6 Click here to find the oracle addresses for the following exchange rates. Ethereum Mainnet \u00b6 1INCH / ETH AAVE / ETH ALPHA / ETH AMPL / ETH ANT / ETH BADGER / ETH BAL / ETH BAND / ETH BAT / ETH BNB / ETH BNT / ETH BTC / ETH BUSD / ETH BZRX / ETH CEL / ETH COMP / ETH COVER / ETH CREAM / ETH CRO / ETH CRV / ETH DAI / ETH DPI / ETH ENJ / ETH FIL / ETH FTM / ETH FTT / ETH GRT / ETH HEGIC / ETH HUSD / ETH KNC / ETH KP3R / ETH LINK / ETH LON / ETH LRC / ETH MANA / ETH MKR / ETH MLN / ETH MTA / ETH NMR / ETH OCEAN / ETH OGN / ETH OMG / ETH ORN / ETH PAX / ETH PAXG / ETH PERP / ETH RAI / ETH RARI / ETH REN / ETH REP / ETH RGT / ETH RLC / ETH RUNE / ETH SFI / ETH SNX / ETH SRM / ETH SUSD / ETH SUSHI / ETH TUSD / ETH UMA / ETH UNI / ETH USDC / ETH USDT / ETH UST / ETH WNXM / ETH WOM / ETH YFI / ETH YFII / ETH ZRX / ETH","title":"Fee System"},{"location":"conveyor/conveyorv1/fee/#fee-system","text":"","title":"Fee System"},{"location":"conveyor/conveyorv1/fee/#overview","text":"1) The user submits a request to the Geode to perform a transaction. For example, swapping 100 gUSDC for 100 gDAI. swapExactTokensForTokens() Transitioning to Step 2: The Geode verifies that the amount of input token (USDC) is sufficient to pay for gas. The Geode can do this by simply calling the getPrice() method from Fee.sol to get USDC/ETH price in 18 decimals. For example, 1 USDC = 0.000361 ETH would yield 361000000000000. After Geode confirmed the user meets the minimum fee requirement, see step 2. 2) The Geode estimates the gas limit and the gas price. The Controller would capture this information to perform another input token check on step 3. 3) After the Controller finalizes the gas fee check, the Controller sends the transaction to UniswapRouter02 to perform the swap. The Geode would pay the gas fee \"out of pocket\" here, to be reimbursed later on step 4. Then, calculates the actual amount of gas consumption at this point. 4) Let's say the fast gas price is 49 gWei, with an average gas limit of 200,000 to perform a swap, the total gas fee (at the time of writing this) is 0.0098 ETH. The Controller then automatically allocates 25.48 gDAI to reimburse the Geode (or locks it in the contract itself). The user gets the remaining 74.52 gDAI.","title":"Overview:"},{"location":"conveyor/conveyorv1/fee/#price-feed-oracles-that-are-available-on-chainlink","text":"Click here to find the oracle addresses for the following exchange rates.","title":"Price Feed oracles that are available on Chainlink"},{"location":"conveyor/conveyorv1/fee/#ethereum-mainnet","text":"1INCH / ETH AAVE / ETH ALPHA / ETH AMPL / ETH ANT / ETH BADGER / ETH BAL / ETH BAND / ETH BAT / ETH BNB / ETH BNT / ETH BTC / ETH BUSD / ETH BZRX / ETH CEL / ETH COMP / ETH COVER / ETH CREAM / ETH CRO / ETH CRV / ETH DAI / ETH DPI / ETH ENJ / ETH FIL / ETH FTM / ETH FTT / ETH GRT / ETH HEGIC / ETH HUSD / ETH KNC / ETH KP3R / ETH LINK / ETH LON / ETH LRC / ETH MANA / ETH MKR / ETH MLN / ETH MTA / ETH NMR / ETH OCEAN / ETH OGN / ETH OMG / ETH ORN / ETH PAX / ETH PAXG / ETH PERP / ETH RAI / ETH RARI / ETH REN / ETH REP / ETH RGT / ETH RLC / ETH RUNE / ETH SFI / ETH SNX / ETH SRM / ETH SUSD / ETH SUSHI / ETH TUSD / ETH UMA / ETH UNI / ETH USDC / ETH USDT / ETH UST / ETH WNXM / ETH WOM / ETH YFI / ETH YFII / ETH ZRX / ETH","title":"Ethereum Mainnet"},{"location":"conveyor/conveyorv2/design/","text":"ConveyorV2 Design \u00b6 Summary \u00b6 ConveyorV2 is an upgrade of Automata's ConveyorV1 to support a better user experience. Tokens that are traded in the ConveyorV2 liquidity pools enjoy the MEV protection and transaction ordering enforcement capabilities without the need to wrap existing ERC20 tokens into gTokens. Similar with ConveyorV1 (formerly known as GTokens), users must sign an EIP712 message to authorize Geode to submit a transaction on the user's behalf. Users would still enjoy the benefit of gasless trading, meaning they are not required to hold native tokens like MATIC or BNB to pay for gas. However, users are subjected to pay a service fee with an acceptable form of ERC20 tokens, such as DAI, USDC or ATA tokens. Codebase \u00b6 The ConveyorV2 smart contracts are a fork of UniswapV2. To learn more about the DEX protocol, read the UniswapV2 docs . There are certain modifications applied to the contracts. Check out the next section for details. Comparison between the UniswapV2 Protocol and ConveyorV2 \u00b6 This section highlights the modification that has been applied to the DEX protocol contracts. ConveyorV2Pair \u00b6 The addition of the onlyRouter() modifier. This modifier guards the mint() , burn() and swap() methods, such that it is made callable by the Router contract only. This modifier is the most viable for enforcing MEV protection, because it prevents any other addresses from bypassing our relayers to perform sandwich attacks. ConveyorV2Factory \u00b6 The router() address variable, the ConveyorV2Pair contract uses this value to match with the caller address. If the caller address does not match with router() , then the pair contract rejects the transaction. Using this approach also allows the \"upgradeability\" of the router. After the deployment of a newer version of the Router contract, the owner of the DEX can invoke the setRouter() method to map it to the new router address. At this point, all existing pair contracts would only accept function calls from the new Router contract. ConveyorV2Router01 \u00b6 The ConveyorV2 router introduces the ability for gasless trading. The user signs the EIP712 message, which is then submitted to the trusted relayer. The trusted relayer then executes the executeMetaTx() method, and pays gas on the user's behalf. After completion of execution, the Forwarder contract collects a service fee from the user to compensate for gas. Check out the ERC20Forwarder section to learn more about the Forwarder contract. In an unlikely event when the relayer service is not available, the protocol owner can disable the meta-transaction functionality by invoking the metaSwitch() method to toggle the metaOnly modifier. This would allow users to directly interact with the router contract as a temporary workaround for such an extenuating circumstance. ERC20 Forwarder \u00b6 The gas forwarder contract enables meta-transaction executions, which allows gas relayers to be compensated for the gas payment with ERC20 tokens. The gas forwarder contract has the ability to calculate a better estimation of the actual gas usage, including transactions that are being reverted. This way, the relayers are only compensated for the equivalent amount of ERC20 token in gas usage. constructor() \u00b6 Initializes the contract and assigns msg.sender as the default feeHolder . The feeHolder is the recipient of the ERC20 fee payment. setConstantFee() \u00b6 function setConstantFee ( uint256 _newConstantFee ) public onlyOwner Updates the constantFee value, defaults at 21000. Requires owner() privilege. Parameter Type _newConstantFee uint256 constant gas limit value setTransferFee() \u00b6 function setTransferFee ( uint256 _newTransferFee ) public onlyOwner Updates the ERC20 transfer gas limit, the transferFee value, defaults at 65000. Requires owner() privilege. Parameter Type _newTransfeFee uint256 ERC20 transfer limit value setRelayer() \u00b6 function setRelayer ( address _relayer , bool _trusted ) public onlyOwner Assigns or revokes relayer role. Requires owner() privilege. Parameter Type _relayer address Relayer address _trusted bool True: grant authorization; false: revoke authorization setFeeHolder() \u00b6 function setFeeHolder ( address _feeHolder ) public onlyOwner Transfers feeHolder role over to the input address. Requires owner() privilege. Parameter Type _feeHolder address Fee holder address MetaTransaction \u00b6 struct MetaTransaction { address from ; address feeToken ; uint256 maxTokenAmount ; uint256 deadline ; uint256 nonce ; bytes data ; bytes32 hashedPayload ; } Parameter Type from address the user's address feeToken address The address of the ERC20 fee token maxAmountToken uint256 The maximum amount of fee tokens that the users are willing to pay for the meta-tx deadline uint256 Meta-transactions that are executed past the deadline will be reverted nonce uint256 Replay protection data bytes The encoded function data that is to be executed hashedPayload bytes32 EIP712-compliant hash struct executeMetaTx() \u00b6 function executeMetaTx ( MetaTransaction memory metatx , string memory domainName , uint256 tokenPricePerNativeToken , uint256 feeOffset , SIGNATURE_TYPE memory sig ) public relayerOnly This function executes the encoded function data, as defined in MetaTransaction.data . It calculates the amount of gas consumption within the enveloped function call and charges the user the fee amount that is based on the token/ETH price tokenPricePerNativeToken . This value is given by the Geode, calculated by an aggregation of token prices fetched from multiple sources. There are certain situations that could cause the transaction to revert, which the relayers will not be compensated for gas fee. The point of reverts are: Insufficient fee token balance Insufficient maxAmountToken Invalid EIP 712 signature Out of gas error Parameter Type metatx MetaTransaction The meta-transaction body domainName string The EIP712 domain name tokenPricePerNativeToken uint256 ERC20 token price per ETH feeOffset uint256 An additional amount of token to be taken into consideration when verifying the user's balance sig SIGNATURE_TYPR The user's EIP712 signature MetaStatus \u00b6 event MetaStatus ( address sender , bool success , string error ) The executeMetaTx logs the event to indicate the status of the meta-tx. Execution failure within the meta-tx will not cause the function to revert. To view the error logs of a meta transaction, the client can simply listen for the error message emitted by this event. Parameter Type sender address user address success bool status of the meta-tx error string reason of a reverted meta-tx","title":"ConveyorV2 Design"},{"location":"conveyor/conveyorv2/design/#conveyorv2-design","text":"","title":"ConveyorV2 Design"},{"location":"conveyor/conveyorv2/design/#summary","text":"ConveyorV2 is an upgrade of Automata's ConveyorV1 to support a better user experience. Tokens that are traded in the ConveyorV2 liquidity pools enjoy the MEV protection and transaction ordering enforcement capabilities without the need to wrap existing ERC20 tokens into gTokens. Similar with ConveyorV1 (formerly known as GTokens), users must sign an EIP712 message to authorize Geode to submit a transaction on the user's behalf. Users would still enjoy the benefit of gasless trading, meaning they are not required to hold native tokens like MATIC or BNB to pay for gas. However, users are subjected to pay a service fee with an acceptable form of ERC20 tokens, such as DAI, USDC or ATA tokens.","title":"Summary"},{"location":"conveyor/conveyorv2/design/#codebase","text":"The ConveyorV2 smart contracts are a fork of UniswapV2. To learn more about the DEX protocol, read the UniswapV2 docs . There are certain modifications applied to the contracts. Check out the next section for details.","title":"Codebase"},{"location":"conveyor/conveyorv2/design/#comparison-between-the-uniswapv2-protocol-and-conveyorv2","text":"This section highlights the modification that has been applied to the DEX protocol contracts.","title":"Comparison between the UniswapV2 Protocol and ConveyorV2"},{"location":"conveyor/conveyorv2/design/#conveyorv2pair","text":"The addition of the onlyRouter() modifier. This modifier guards the mint() , burn() and swap() methods, such that it is made callable by the Router contract only. This modifier is the most viable for enforcing MEV protection, because it prevents any other addresses from bypassing our relayers to perform sandwich attacks.","title":"ConveyorV2Pair"},{"location":"conveyor/conveyorv2/design/#conveyorv2factory","text":"The router() address variable, the ConveyorV2Pair contract uses this value to match with the caller address. If the caller address does not match with router() , then the pair contract rejects the transaction. Using this approach also allows the \"upgradeability\" of the router. After the deployment of a newer version of the Router contract, the owner of the DEX can invoke the setRouter() method to map it to the new router address. At this point, all existing pair contracts would only accept function calls from the new Router contract.","title":"ConveyorV2Factory"},{"location":"conveyor/conveyorv2/design/#conveyorv2router01","text":"The ConveyorV2 router introduces the ability for gasless trading. The user signs the EIP712 message, which is then submitted to the trusted relayer. The trusted relayer then executes the executeMetaTx() method, and pays gas on the user's behalf. After completion of execution, the Forwarder contract collects a service fee from the user to compensate for gas. Check out the ERC20Forwarder section to learn more about the Forwarder contract. In an unlikely event when the relayer service is not available, the protocol owner can disable the meta-transaction functionality by invoking the metaSwitch() method to toggle the metaOnly modifier. This would allow users to directly interact with the router contract as a temporary workaround for such an extenuating circumstance.","title":"ConveyorV2Router01"},{"location":"conveyor/conveyorv2/design/#erc20-forwarder","text":"The gas forwarder contract enables meta-transaction executions, which allows gas relayers to be compensated for the gas payment with ERC20 tokens. The gas forwarder contract has the ability to calculate a better estimation of the actual gas usage, including transactions that are being reverted. This way, the relayers are only compensated for the equivalent amount of ERC20 token in gas usage.","title":"ERC20 Forwarder"},{"location":"conveyor/conveyorv2/design/#constructor","text":"Initializes the contract and assigns msg.sender as the default feeHolder . The feeHolder is the recipient of the ERC20 fee payment.","title":"constructor()"},{"location":"conveyor/conveyorv2/design/#setconstantfee","text":"function setConstantFee ( uint256 _newConstantFee ) public onlyOwner Updates the constantFee value, defaults at 21000. Requires owner() privilege. Parameter Type _newConstantFee uint256 constant gas limit value","title":"setConstantFee()"},{"location":"conveyor/conveyorv2/design/#settransferfee","text":"function setTransferFee ( uint256 _newTransferFee ) public onlyOwner Updates the ERC20 transfer gas limit, the transferFee value, defaults at 65000. Requires owner() privilege. Parameter Type _newTransfeFee uint256 ERC20 transfer limit value","title":"setTransferFee()"},{"location":"conveyor/conveyorv2/design/#setrelayer","text":"function setRelayer ( address _relayer , bool _trusted ) public onlyOwner Assigns or revokes relayer role. Requires owner() privilege. Parameter Type _relayer address Relayer address _trusted bool True: grant authorization; false: revoke authorization","title":"setRelayer()"},{"location":"conveyor/conveyorv2/design/#setfeeholder","text":"function setFeeHolder ( address _feeHolder ) public onlyOwner Transfers feeHolder role over to the input address. Requires owner() privilege. Parameter Type _feeHolder address Fee holder address","title":"setFeeHolder()"},{"location":"conveyor/conveyorv2/design/#metatransaction","text":"struct MetaTransaction { address from ; address feeToken ; uint256 maxTokenAmount ; uint256 deadline ; uint256 nonce ; bytes data ; bytes32 hashedPayload ; } Parameter Type from address the user's address feeToken address The address of the ERC20 fee token maxAmountToken uint256 The maximum amount of fee tokens that the users are willing to pay for the meta-tx deadline uint256 Meta-transactions that are executed past the deadline will be reverted nonce uint256 Replay protection data bytes The encoded function data that is to be executed hashedPayload bytes32 EIP712-compliant hash struct","title":"MetaTransaction"},{"location":"conveyor/conveyorv2/design/#executemetatx","text":"function executeMetaTx ( MetaTransaction memory metatx , string memory domainName , uint256 tokenPricePerNativeToken , uint256 feeOffset , SIGNATURE_TYPE memory sig ) public relayerOnly This function executes the encoded function data, as defined in MetaTransaction.data . It calculates the amount of gas consumption within the enveloped function call and charges the user the fee amount that is based on the token/ETH price tokenPricePerNativeToken . This value is given by the Geode, calculated by an aggregation of token prices fetched from multiple sources. There are certain situations that could cause the transaction to revert, which the relayers will not be compensated for gas fee. The point of reverts are: Insufficient fee token balance Insufficient maxAmountToken Invalid EIP 712 signature Out of gas error Parameter Type metatx MetaTransaction The meta-transaction body domainName string The EIP712 domain name tokenPricePerNativeToken uint256 ERC20 token price per ETH feeOffset uint256 An additional amount of token to be taken into consideration when verifying the user's balance sig SIGNATURE_TYPR The user's EIP712 signature","title":"executeMetaTx()"},{"location":"conveyor/conveyorv2/design/#metastatus","text":"event MetaStatus ( address sender , bool success , string error ) The executeMetaTx logs the event to indicate the status of the meta-tx. Execution failure within the meta-tx will not cause the function to revert. To view the error logs of a meta transaction, the client can simply listen for the error message emitted by this event. Parameter Type sender address user address success bool status of the meta-tx error string reason of a reverted meta-tx","title":"MetaStatus"},{"location":"mev/examples/","text":"Attack Examples \u00b6 Front-Running \u00b6 Front-running is the process by which an adversary observes transactions on the network layer and then acts upon this information by, for instance, issuing a competing transaction, with the hope that this transaction is mined before a victim transaction e.g. Transaction A is broadcasted with a higher gas price than an already pending transaction B so that A gets mined before B. Sandwich Attacks \u00b6 Alice wants to buy a Token A on a Decentralised Exchange (DEX) that uses an automated market maker (AMM) model. An adversary which sees Alice\u2019s transaction can create two of its own transactions which it inserts before and after Alice\u2019s transaction (sandwiching it). The adversary\u2019s first transaction buys Token A, which pushes up the price for Alice\u2019s transaction, and then the third transaction is the adversary\u2019s transaction to sell Token A (now at a higher price) at a profit. Back-Running \u00b6 Back-running occurs when a transaction sender wishes to have their transaction ordered immediately after some unconfirmed \"target transaction\". Example: A back-running bot that back-runs new token listings. Bot monitors the Ethereum mempool for new pairs being created on Uniswap. If it finds a new pair the bot places a buy transaction immediately behind the initial liquidity. The bot swoops in and buys as many tokens as possible (but not all of them as there needs to be an opportunity for others to buy tokens as well).The bot then waits for the price to go up as other traders buy the token from Uniswap and proceeds to sell back the tokens at a higher price. The key in this strategy is to be the first to buy tokens, but only after the token has been launched. 1 In order to maximise their changes of being mined immediately after their target, a typical backrunner will send many identical transactions, with gas price identical to that of the target transaction, sometimes from different accounts, in order to increase the chances that one of their transactions is ordered after the target but before any competitor. Liquidations \u00b6 Back-running strategies also apply to liquidations whereby a transaction sender wishes to be the first to liquidate a loan right after a price oracle update (which will allow liquidation to be triggered). Fixed spread liquidation used by Compound, Aave, and dYdX allows a liquidator to purchase collateral at a fixed discount when repaying debt. Strategy 1 A detects a liquidation opportunity at block B (i.e., after the execution of B). A then issues a liquidation transaction T, which is expected to be mined in the next block B +1. A attempts to destructively front-run other competing liquidators by setting high transaction fees for his liquidation transaction T. Strategy 2 A observes a transaction T, which will create a liquidation opportunity (e.g., an oracle price update transaction which will render a collateralized debt liquidatable). A then back-runs T with a liquidation transaction T A to avoid the transaction fee bidding competition. The auction liquidation allows a liquidator to start an auction that lasts for a pre-configured period (e.g., 6 hours). Competing liquidators can engage and bid on the collateral price. Time-Bandit Attacks \u00b6 Time-bandit attacks are attacks where miners rewrite blockchain history to steal funds allocated by smart contracts in the past. If block rewards are small enough compared to MEV, it can be rational for miners to destabilize consensus. Imagine there are two miners, Sam and Dan, who are paid a $100 reward for each block they find. Sam has found 3 blocks, the first of which contained a $10,000 arbitrage opportunity. Now Dan has a choice: he can either mine on top of Sam\u2019s 3 blocks, or he can attempt to re-mine the first block in order to take the Uniswap arbitrage for himself. The $10,000 is much more lucrative than the $100 block reward, and Dan is more rational than honest, so he decides to re-mine the first block. While Dan\u2019s at it, since the current longest chain is height 3, he also re-mines the second and third blocks (and captures any MEV that was in those, too). After the re-organization, Dan owns the longest chain and he and Sam can progress from the third block. The Uncle Bandit Attack \u00b6 Bundles are groups of transactions Flashbots users submit. Those transactions must be included in the order submitted, and either the whole bundle is included, or nothing is. A bundle should never be split up. Robert Miller found that for a specific bundle, only the \"Buy\" part of a sandwich bundle submitted had landed on-chain, and right after that Buy someone else had inserted a 7 gas transaction that arbitraged it. How? In Ethereum occasionally two blocks are mined at roughly the same time, and only one block can be added to the chain. The other gets \"uncled\" or orphaned. Anyone can access transactions in an uncled block and some of the transactions may not have ended up in the non-uncled block. In a way some transactions end up in a sort of mempool like state: they are now public as a part of the uncled block and perhaps still valid too. A Sandwicher's bundle was included in an uncled block. An attacker saw this, grabbed only the Buy part of the Sandwich, threw away the rest, and added an arbitrage after. The attacker then submitted that as a bundle, which was then mined. Instead of seeing something late in time and rewinding it (time-bandit attack), the uncle bandit attack is when an attacker sees something in an uncle and brings it forward. This also shows that attacks extend beyond the mempool and into uncled blocks as well. https://amanusk.medium.com/the-fastest-draw-on-the-blockchain-bzrx-example-6bd19fabdbe1 \u21a9","title":"Attack Examples"},{"location":"mev/examples/#attack-examples","text":"","title":"Attack Examples"},{"location":"mev/examples/#front-running","text":"Front-running is the process by which an adversary observes transactions on the network layer and then acts upon this information by, for instance, issuing a competing transaction, with the hope that this transaction is mined before a victim transaction e.g. Transaction A is broadcasted with a higher gas price than an already pending transaction B so that A gets mined before B.","title":"Front-Running"},{"location":"mev/examples/#sandwich-attacks","text":"Alice wants to buy a Token A on a Decentralised Exchange (DEX) that uses an automated market maker (AMM) model. An adversary which sees Alice\u2019s transaction can create two of its own transactions which it inserts before and after Alice\u2019s transaction (sandwiching it). The adversary\u2019s first transaction buys Token A, which pushes up the price for Alice\u2019s transaction, and then the third transaction is the adversary\u2019s transaction to sell Token A (now at a higher price) at a profit.","title":"Sandwich Attacks"},{"location":"mev/examples/#back-running","text":"Back-running occurs when a transaction sender wishes to have their transaction ordered immediately after some unconfirmed \"target transaction\". Example: A back-running bot that back-runs new token listings. Bot monitors the Ethereum mempool for new pairs being created on Uniswap. If it finds a new pair the bot places a buy transaction immediately behind the initial liquidity. The bot swoops in and buys as many tokens as possible (but not all of them as there needs to be an opportunity for others to buy tokens as well).The bot then waits for the price to go up as other traders buy the token from Uniswap and proceeds to sell back the tokens at a higher price. The key in this strategy is to be the first to buy tokens, but only after the token has been launched. 1 In order to maximise their changes of being mined immediately after their target, a typical backrunner will send many identical transactions, with gas price identical to that of the target transaction, sometimes from different accounts, in order to increase the chances that one of their transactions is ordered after the target but before any competitor.","title":"Back-Running"},{"location":"mev/examples/#liquidations","text":"Back-running strategies also apply to liquidations whereby a transaction sender wishes to be the first to liquidate a loan right after a price oracle update (which will allow liquidation to be triggered). Fixed spread liquidation used by Compound, Aave, and dYdX allows a liquidator to purchase collateral at a fixed discount when repaying debt. Strategy 1 A detects a liquidation opportunity at block B (i.e., after the execution of B). A then issues a liquidation transaction T, which is expected to be mined in the next block B +1. A attempts to destructively front-run other competing liquidators by setting high transaction fees for his liquidation transaction T. Strategy 2 A observes a transaction T, which will create a liquidation opportunity (e.g., an oracle price update transaction which will render a collateralized debt liquidatable). A then back-runs T with a liquidation transaction T A to avoid the transaction fee bidding competition. The auction liquidation allows a liquidator to start an auction that lasts for a pre-configured period (e.g., 6 hours). Competing liquidators can engage and bid on the collateral price.","title":"Liquidations"},{"location":"mev/examples/#time-bandit-attacks","text":"Time-bandit attacks are attacks where miners rewrite blockchain history to steal funds allocated by smart contracts in the past. If block rewards are small enough compared to MEV, it can be rational for miners to destabilize consensus. Imagine there are two miners, Sam and Dan, who are paid a $100 reward for each block they find. Sam has found 3 blocks, the first of which contained a $10,000 arbitrage opportunity. Now Dan has a choice: he can either mine on top of Sam\u2019s 3 blocks, or he can attempt to re-mine the first block in order to take the Uniswap arbitrage for himself. The $10,000 is much more lucrative than the $100 block reward, and Dan is more rational than honest, so he decides to re-mine the first block. While Dan\u2019s at it, since the current longest chain is height 3, he also re-mines the second and third blocks (and captures any MEV that was in those, too). After the re-organization, Dan owns the longest chain and he and Sam can progress from the third block.","title":"Time-Bandit Attacks"},{"location":"mev/examples/#the-uncle-bandit-attack","text":"Bundles are groups of transactions Flashbots users submit. Those transactions must be included in the order submitted, and either the whole bundle is included, or nothing is. A bundle should never be split up. Robert Miller found that for a specific bundle, only the \"Buy\" part of a sandwich bundle submitted had landed on-chain, and right after that Buy someone else had inserted a 7 gas transaction that arbitraged it. How? In Ethereum occasionally two blocks are mined at roughly the same time, and only one block can be added to the chain. The other gets \"uncled\" or orphaned. Anyone can access transactions in an uncled block and some of the transactions may not have ended up in the non-uncled block. In a way some transactions end up in a sort of mempool like state: they are now public as a part of the uncled block and perhaps still valid too. A Sandwicher's bundle was included in an uncled block. An attacker saw this, grabbed only the Buy part of the Sandwich, threw away the rest, and added an arbitrage after. The attacker then submitted that as a bundle, which was then mined. Instead of seeing something late in time and rewinding it (time-bandit attack), the uncle bandit attack is when an attacker sees something in an uncle and brings it forward. This also shows that attacks extend beyond the mempool and into uncled blocks as well. https://amanusk.medium.com/the-fastest-draw-on-the-blockchain-bzrx-example-6bd19fabdbe1 \u21a9","title":"The Uncle Bandit Attack"},{"location":"mev/introduction/","text":"Introduction \u00b6 This is a public resource for learning about Miner Extractable Value . We cover a range of topics including the key concepts, research on this the topic, different approaches to tackling this issue and also Automata Network's approach. Tip Find any errors? Click the icon on each page to contribute. Want to share your feedback? Contact us here . What is Miner Extractable Value? \u00b6 When one sends a transaction on the blockchain, there is a delay between the time when the transaction is broadcast to the network and when it is actually mined into a block. During this period, transactions sit in a pending transaction pool called the mempool where contents are visible to everyone. Arbitrageurs and miners can monitor the mempool and find opportunities to maximize their own profits e.g. by frontrunning transactions. If a front-runner is a miner, they can also reorder or even censor transactions. Miner Extractable Value refers to the amount of profit that can be extracted from reordering and censoring transactions on the blockchain. Why does this matter 1 ? \u00b6 MEV can harm users \u00b6 MEV is an invisible tax that miners can collect from users. MEV can destabilize Ethereum \u00b6 If block rewards are small enough compared to MEV, it can be rational for miners to destabilize consensus by reordering or censoring transactions. Just how bad is the problem? \u00b6 The Flashbots Dashboard tracks Extracted MEV over time. It is estimated that >$500M has been extracted since 1st January 2020. Dune Analytics tracks Gas consumption by back-running bots. According to https://research.paradigm.xyz/MEV \u21a9","title":"Introduction"},{"location":"mev/introduction/#introduction","text":"This is a public resource for learning about Miner Extractable Value . We cover a range of topics including the key concepts, research on this the topic, different approaches to tackling this issue and also Automata Network's approach. Tip Find any errors? Click the icon on each page to contribute. Want to share your feedback? Contact us here .","title":"Introduction"},{"location":"mev/introduction/#what-is-miner-extractable-value","text":"When one sends a transaction on the blockchain, there is a delay between the time when the transaction is broadcast to the network and when it is actually mined into a block. During this period, transactions sit in a pending transaction pool called the mempool where contents are visible to everyone. Arbitrageurs and miners can monitor the mempool and find opportunities to maximize their own profits e.g. by frontrunning transactions. If a front-runner is a miner, they can also reorder or even censor transactions. Miner Extractable Value refers to the amount of profit that can be extracted from reordering and censoring transactions on the blockchain.","title":"What is Miner Extractable Value?"},{"location":"mev/introduction/#why-does-this-matter1","text":"","title":"Why does this matter1?"},{"location":"mev/introduction/#mev-can-harm-users","text":"MEV is an invisible tax that miners can collect from users.","title":"MEV can harm users"},{"location":"mev/introduction/#mev-can-destabilize-ethereum","text":"If block rewards are small enough compared to MEV, it can be rational for miners to destabilize consensus by reordering or censoring transactions.","title":"MEV can destabilize Ethereum"},{"location":"mev/introduction/#just-how-bad-is-the-problem","text":"The Flashbots Dashboard tracks Extracted MEV over time. It is estimated that >$500M has been extracted since 1st January 2020. Dune Analytics tracks Gas consumption by back-running bots. According to https://research.paradigm.xyz/MEV \u21a9","title":"Just how bad is the problem?"},{"location":"mev/misc/","text":"Miscellaneous \u00b6 What Happens when Ethereum moves to Proof-of-Stake? \u00b6 The move from PoW to PoS consensus means the Ethereum network becomes secured by a set validators, who stake their ETH and vote on consensus, as opposed to miners who run mining equipment to solve for the proof of work. This change of consensus is set to happen likely some time in 2021. Some have suggested that this means Miner Extractable Value will become Validator Extractable Value. This is an ongoing discussion and you can follow this here https://hackmd.io/@flashbots/ryuH4gn7d From Paradigm's piece \"On Staking Pools and Staking Derivatives\" - Staking pools and their staking derivatives are subject to similar market realities as MEV extraction, in the sense that their existence is inevitable. Institutional staking pools (e.g. exchanges) may have social and reputational constraints that prevent them from extracting certain forms of MEV. This allows smaller staking firms and decentralized pools without these constraints to provide higher returns for their stakers. This could turn the decentralization premium for using a decentralized staking pool into a decentralization discount. https://research.paradigm.xyz/staking Other Academic Papers \u00b6 Tesseract Tesseract proposes a front-running resistant exchange relying on Intel SGX as a trusted execution environment. https://eprint.iacr.org/2017/1153.pdf Calypso Enables a blockchain to hold and manage secrets on-chain with the convenient property that it is able to protect against front-running. https://eprint.iacr.org/2018/209.pdf","title":"Miscellaneous"},{"location":"mev/misc/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"mev/misc/#what-happens-when-ethereum-moves-to-proof-of-stake","text":"The move from PoW to PoS consensus means the Ethereum network becomes secured by a set validators, who stake their ETH and vote on consensus, as opposed to miners who run mining equipment to solve for the proof of work. This change of consensus is set to happen likely some time in 2021. Some have suggested that this means Miner Extractable Value will become Validator Extractable Value. This is an ongoing discussion and you can follow this here https://hackmd.io/@flashbots/ryuH4gn7d From Paradigm's piece \"On Staking Pools and Staking Derivatives\" - Staking pools and their staking derivatives are subject to similar market realities as MEV extraction, in the sense that their existence is inevitable. Institutional staking pools (e.g. exchanges) may have social and reputational constraints that prevent them from extracting certain forms of MEV. This allows smaller staking firms and decentralized pools without these constraints to provide higher returns for their stakers. This could turn the decentralization premium for using a decentralized staking pool into a decentralization discount. https://research.paradigm.xyz/staking","title":"What Happens when Ethereum moves to Proof-of-Stake?"},{"location":"mev/misc/#other-academic-papers","text":"Tesseract Tesseract proposes a front-running resistant exchange relying on Intel SGX as a trusted execution environment. https://eprint.iacr.org/2017/1153.pdf Calypso Enables a blockchain to hold and manage secrets on-chain with the convenient property that it is able to protect against front-running. https://eprint.iacr.org/2018/209.pdf","title":"Other Academic Papers"},{"location":"mev/resource-list/","text":"Resource List \u00b6 Name Type What Is Miner-Extractable Value (MEV)? Article Miners, Front-Running-as-a-Service Is Theft Article MEV and Me Article Ethereum is a Dark Forest Article Escaping the Dark Forest Article Ethereum Blockspace: Who Gets What and Why Article The fastest draw on the Blockchain: Ethereum Backrunning Article Security of Interoperability Presentation Gas Wars: Understanding Ethereum's Mempool & Miner Extractable Value Podcast Smart Contract Security - Incentives Beyond the Launch by Phil Daian (Devcon4) Video Enter the Dark Forest: the terrifying world of MEV and Flash bots Video Frontrunning in Decentralized Exchanges, Miner Extractable Value, and Consensus Instability Video How To Get Front-Run on Ethereum mainnet Video Flash Boys 2.0: Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges Research Paper Quantifying Blockchain Extractable Value: How dark is the forest? Research Paper High-Frequency Trading on Decentralized On-Chain Exchanges Research Paper Frontrunner Jones and the Raiders of the Dark Forest: An Empirical Study of Frontrunning on the Ethereum Blockchain Research Paper","title":"Resource List"},{"location":"mev/resource-list/#resource-list","text":"Name Type What Is Miner-Extractable Value (MEV)? Article Miners, Front-Running-as-a-Service Is Theft Article MEV and Me Article Ethereum is a Dark Forest Article Escaping the Dark Forest Article Ethereum Blockspace: Who Gets What and Why Article The fastest draw on the Blockchain: Ethereum Backrunning Article Security of Interoperability Presentation Gas Wars: Understanding Ethereum's Mempool & Miner Extractable Value Podcast Smart Contract Security - Incentives Beyond the Launch by Phil Daian (Devcon4) Video Enter the Dark Forest: the terrifying world of MEV and Flash bots Video Frontrunning in Decentralized Exchanges, Miner Extractable Value, and Consensus Instability Video How To Get Front-Run on Ethereum mainnet Video Flash Boys 2.0: Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges Research Paper Quantifying Blockchain Extractable Value: How dark is the forest? Research Paper High-Frequency Trading on Decentralized On-Chain Exchanges Research Paper Frontrunner Jones and the Raiders of the Dark Forest: An Empirical Study of Frontrunning on the Ethereum Blockchain Research Paper","title":"Resource List"},{"location":"mev/terms-and-concepts/","text":"Terms and Concepts \u00b6 DeFi \u00b6 DeFi is a subset of finance-focused decentralized protocols that operate autonomously on blockchain-based smart contracts. The total value locked in DeFi amounts to >$50B USD 1 . Automated Market Maker \u00b6 A type of Decentralised Exchange. Contrary to traditional limit order-book-based exchanges (which maintain a list of bids and asks for an asset pair), AMM exchanges maintain a pool of capital (a liquidity pool) with at least two assets. A smart contract governs the rules by which traders can purchase and sell assets from the liquidity pool. The most common AMM mechanism is a constant product AMM, where the product of an asset \\(x\\) and asset \\(y\\) in a pool have to abide by a constant \\(k\\) . Examples of AMM Exchanges include Uniswap , Sushiswap , Balancer . Lending Platforms \u00b6 Debt is an essential tool in DeFi. As DeFi applications typically operate without Know Your Customer (KYC), the borrower\u2019s debt must be over-collateralized. Hence, a borrower must collateralize (lock) 150% of the value that the borrower wishes to lend out. The collateral acts as a security to the lender if the borrower doesn\u2019t pay back the debt. Examples of lending platforms include Aave and Compound . Arbitrage \u00b6 Arbitrage is the simultaneous purchase and sale of the same asset in different markets in order to profit from differences in the asset's listed price. Slippage \u00b6 Slippage is defined as the move in the price of a security between the time you decided to transact in it and the time your order was in the market. When performing a trade on an AMM, the expected execution price may differ from the real execution price because the expected price depends on a past blockchain state, which may change between the transaction creation and its execution \u2014 e.g., due to front-running transactions. Liquidations \u00b6 In Lending Platforms, if the collateral value decreases and the collateralization ratio falls below 150%, the collateral can be freed up for liquidation. Liquidators can then purchase the collateral at a discount to repay the debt. Priority gas auctions (PGAs) \u00b6 As pure arbitrage opportunities offer unconditional revenue, bots often compete against each other by bidding up transaction fees (gas) in PGAs which drives up fees for other users. Transaction Ordering \u00b6 Blockchains typically prescribe specific rules for consensus, but there are only loose requirements for miners on how to order transactions within a block. Many attacks are centered around how miners order transactions within blocks. https://defipulse.com/ \u21a9","title":"Terms and Concepts"},{"location":"mev/terms-and-concepts/#terms-and-concepts","text":"","title":"Terms and Concepts"},{"location":"mev/terms-and-concepts/#defi","text":"DeFi is a subset of finance-focused decentralized protocols that operate autonomously on blockchain-based smart contracts. The total value locked in DeFi amounts to >$50B USD 1 .","title":"DeFi"},{"location":"mev/terms-and-concepts/#automated-market-maker","text":"A type of Decentralised Exchange. Contrary to traditional limit order-book-based exchanges (which maintain a list of bids and asks for an asset pair), AMM exchanges maintain a pool of capital (a liquidity pool) with at least two assets. A smart contract governs the rules by which traders can purchase and sell assets from the liquidity pool. The most common AMM mechanism is a constant product AMM, where the product of an asset \\(x\\) and asset \\(y\\) in a pool have to abide by a constant \\(k\\) . Examples of AMM Exchanges include Uniswap , Sushiswap , Balancer .","title":"Automated Market Maker"},{"location":"mev/terms-and-concepts/#lending-platforms","text":"Debt is an essential tool in DeFi. As DeFi applications typically operate without Know Your Customer (KYC), the borrower\u2019s debt must be over-collateralized. Hence, a borrower must collateralize (lock) 150% of the value that the borrower wishes to lend out. The collateral acts as a security to the lender if the borrower doesn\u2019t pay back the debt. Examples of lending platforms include Aave and Compound .","title":"Lending Platforms"},{"location":"mev/terms-and-concepts/#arbitrage","text":"Arbitrage is the simultaneous purchase and sale of the same asset in different markets in order to profit from differences in the asset's listed price.","title":"Arbitrage"},{"location":"mev/terms-and-concepts/#slippage","text":"Slippage is defined as the move in the price of a security between the time you decided to transact in it and the time your order was in the market. When performing a trade on an AMM, the expected execution price may differ from the real execution price because the expected price depends on a past blockchain state, which may change between the transaction creation and its execution \u2014 e.g., due to front-running transactions.","title":"Slippage"},{"location":"mev/terms-and-concepts/#liquidations","text":"In Lending Platforms, if the collateral value decreases and the collateralization ratio falls below 150%, the collateral can be freed up for liquidation. Liquidators can then purchase the collateral at a discount to repay the debt.","title":"Liquidations"},{"location":"mev/terms-and-concepts/#priority-gas-auctions-pgas","text":"As pure arbitrage opportunities offer unconditional revenue, bots often compete against each other by bidding up transaction fees (gas) in PGAs which drives up fees for other users.","title":"Priority gas auctions (PGAs)"},{"location":"mev/terms-and-concepts/#transaction-ordering","text":"Blockchains typically prescribe specific rules for consensus, but there are only loose requirements for miners on how to order transactions within a block. Many attacks are centered around how miners order transactions within blocks. https://defipulse.com/ \u21a9","title":"Transaction Ordering"},{"location":"mev/trick-the-bots/","text":"Attempts to Trick Bots \u00b6 Salmonella \u00b6 Salmonella intentionally exploits the generalised nature of front-running setups. The goal of sandwich trading is to exploit the slippage of unintended victims, so this strategy turns the tables on the exploiters. It\u2019s a regular ERC20 token, which behaves exactly like any other ERC20 token in normal use-cases. However, it has some special logic to detect when anyone other than the specified owner is transacting it, and in these situations it only returns 10% of the specified amount - despite emitting event logs which match a trade of the full amount. Kattana \u00b6 The Kattana team included a trap for front-running bots during their token listing. There is a line in the code that disallows the front-runner from selling all tokens. So a front-runner paid 68 ETH to the miner and ended up with tokens he wasn't able to sell. Another attempt to trick bots \u00b6 Background \u00b6 Instead of users paying transaction fees via gas prices, Flashbots users pay fees via a smart contract call which transfers ETH to a miner. Miners receive bundles of transaction from users and include the bundle that pays them the most. Users love this because they only pay for transactions that are included and they can determine the fee that they are going to pay. Sandwich bots watch the mempool for users buying on DEXes and sandwich them: running the price up before the victim buys and dumping after for a profit. Those 3 txs (buy, victim transaction, sell) make up a bundle. Note the Sandwich sell transaction contains the smart contract payment to the miner. It's important that payment goes to the miner on the sell transaction! That should only happen after the bot has secured profit from selling the tokens bought in their front-run. If that sell fails then there is no payment to the miner, and thus their bundle shouldn't be included To be even more secure, bots will simulate their transactions on local infrastructure. Bots won't send transactions unless the simulation goes well. Paying transaction fees only on the sell transaction of a sandwich should defend against this. No profit, no payment. Simulation vs Reality \u00b6 Some really smart people found weaknesses among all of these defenses. The first defense was that simulation was done with an ERC20 transfer function that checked to see if the block was a mined by Flashbots' miners, and if so it transfers way less out. Local simulations look fine but do not work in production. The second defense - Payment only on a sell transaction \u00b6 Again: Sandwich bots make miner payment conditional on profit. That was broken by making the ERC20 token pay the miner. Thus even with the Sandwich bot sell failing, the miner would still get paid! Here's what actually happened: Sandwich bot gets baited and buys 100 ETH of the poisonous token. Poisonous token owner's bait triggers custom transfer function, which pays 0.1 ETH to the miner Sandwich bot's sell doesn't work because of the poisonous token. As the sandwich bot submitted these three transactions in a bundle all three were included: the successful buy, the bait, and the failed sell. The poisonous ERC20's payment via the custom transfer was what incentivized a miner to include it! It is estimated that the first person to do this made about 100 ETH. You can see the poisoned ERC20 Uniswap transactions here . From Victim to Predator \u00b6 One of their victims was one the most successful Flashbots bot operators, and they immediately sprung into action. In a short period of time the victim turned into an apex predator. They launched a similar but slightly different ERC20 (YOLOchain), and ended up successfully baiting many more sandwichers. They made 300 ETH doing so!","title":"Attempts to Trick the Bots"},{"location":"mev/trick-the-bots/#attempts-to-trick-bots","text":"","title":"Attempts to Trick Bots"},{"location":"mev/trick-the-bots/#salmonella","text":"Salmonella intentionally exploits the generalised nature of front-running setups. The goal of sandwich trading is to exploit the slippage of unintended victims, so this strategy turns the tables on the exploiters. It\u2019s a regular ERC20 token, which behaves exactly like any other ERC20 token in normal use-cases. However, it has some special logic to detect when anyone other than the specified owner is transacting it, and in these situations it only returns 10% of the specified amount - despite emitting event logs which match a trade of the full amount.","title":"Salmonella"},{"location":"mev/trick-the-bots/#kattana","text":"The Kattana team included a trap for front-running bots during their token listing. There is a line in the code that disallows the front-runner from selling all tokens. So a front-runner paid 68 ETH to the miner and ended up with tokens he wasn't able to sell.","title":"Kattana"},{"location":"mev/trick-the-bots/#another-attempt-to-trick-bots","text":"","title":"Another attempt to trick bots"},{"location":"mev/trick-the-bots/#background","text":"Instead of users paying transaction fees via gas prices, Flashbots users pay fees via a smart contract call which transfers ETH to a miner. Miners receive bundles of transaction from users and include the bundle that pays them the most. Users love this because they only pay for transactions that are included and they can determine the fee that they are going to pay. Sandwich bots watch the mempool for users buying on DEXes and sandwich them: running the price up before the victim buys and dumping after for a profit. Those 3 txs (buy, victim transaction, sell) make up a bundle. Note the Sandwich sell transaction contains the smart contract payment to the miner. It's important that payment goes to the miner on the sell transaction! That should only happen after the bot has secured profit from selling the tokens bought in their front-run. If that sell fails then there is no payment to the miner, and thus their bundle shouldn't be included To be even more secure, bots will simulate their transactions on local infrastructure. Bots won't send transactions unless the simulation goes well. Paying transaction fees only on the sell transaction of a sandwich should defend against this. No profit, no payment.","title":"Background"},{"location":"mev/trick-the-bots/#simulation-vs-reality","text":"Some really smart people found weaknesses among all of these defenses. The first defense was that simulation was done with an ERC20 transfer function that checked to see if the block was a mined by Flashbots' miners, and if so it transfers way less out. Local simulations look fine but do not work in production.","title":"Simulation vs Reality"},{"location":"mev/trick-the-bots/#the-second-defense-payment-only-on-a-sell-transaction","text":"Again: Sandwich bots make miner payment conditional on profit. That was broken by making the ERC20 token pay the miner. Thus even with the Sandwich bot sell failing, the miner would still get paid! Here's what actually happened: Sandwich bot gets baited and buys 100 ETH of the poisonous token. Poisonous token owner's bait triggers custom transfer function, which pays 0.1 ETH to the miner Sandwich bot's sell doesn't work because of the poisonous token. As the sandwich bot submitted these three transactions in a bundle all three were included: the successful buy, the bait, and the failed sell. The poisonous ERC20's payment via the custom transfer was what incentivized a miner to include it! It is estimated that the first person to do this made about 100 ETH. You can see the poisoned ERC20 Uniswap transactions here .","title":"The second defense - Payment only on a sell transaction"},{"location":"mev/trick-the-bots/#from-victim-to-predator","text":"One of their victims was one the most successful Flashbots bot operators, and they immediately sprung into action. In a short period of time the victim turned into an apex predator. They launched a similar but slightly different ERC20 (YOLOchain), and ended up successfully baiting many more sandwichers. They made 300 ETH doing so!","title":"From Victim to Predator"},{"location":"mev/solutions/approaches/","text":"Different approaches to tackling the MEV problem \u00b6 There are largely 2 schools of thought when it comes to approaching the MEV problem Offense - MEV is here to stay so let's find a way to extract and democratize it. Defense - MEV is bad so let's try to prevent it. As such we have put approaches into 2 categories Front-running as a Service (FaaS) or MEV Auctions (MEVA) MEV Minimization/Prevention At Automata Network we are in the Defense camp. Our solution Conveyor ingests transactions and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering.","title":"Different Approaches"},{"location":"mev/solutions/approaches/#different-approaches-to-tackling-the-mev-problem","text":"There are largely 2 schools of thought when it comes to approaching the MEV problem Offense - MEV is here to stay so let's find a way to extract and democratize it. Defense - MEV is bad so let's try to prevent it. As such we have put approaches into 2 categories Front-running as a Service (FaaS) or MEV Auctions (MEVA) MEV Minimization/Prevention At Automata Network we are in the Defense camp. Our solution Conveyor ingests transactions and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering.","title":"Different approaches to tackling the MEV problem"},{"location":"mev/solutions/faas-or-meva/","text":"Front-running as a Service (FaaS) or MEV Auctions (MEVA) \u00b6 In a FaaS or MEVA system, MEV is extracted in a variety of ways such as miners auctioning off the right to front-run users. Vitalik Buterin - Centralizing MEV extraction is good because it quarantines a revenue stream that could otherwise drive centralization in other sectors. Phil Daian, co-author of Flash Boys 2.0 - In this article, I\u2019m going to go deep into my personal arguments for why extracting MEV in cryptocurrencies isn\u2019t like theft, why it is a critical metric for network security in any distributed system secured by economic incentives (yes, including centralized ones), and what we should do about MEV in the next 3-5 years as a community. Private Transactions \u00b6 Typically, transactions are broadcast to the mempool where they remain pending until miners pick them and add to the block. Private transactions however, are only visible to the pool and are not broadcast to other nodes (pay more for faster transactions). Examples include 1inch Exchange's Stealth Transactions , Taichi Network and BloXroute . Private Transactions offered by Taichi Network bloXroute Labs has a wide range of offerings and their core competency is low global latency for DeFi (8% of blocks mined within 1 sec). Note For the other side of the coin, here is bloXroute Labs' take on why private mempools are not necessarily bad 1 : Front-runners don't need these services to outpace regular users, who are slower by seconds. They need it to outpace one another, where improving speed 0.8->0.15 sec matters. When a transaction is privately sent to pools other frontrunners can't attempt to front-run it. This helps avoid fierce escalation of fees. Links https://docs.bloxroute.com/apis/frontrunning-protection BackRunMe by bloXroute \u00b6 BackRunMe is a service that allows users to submit private transactions (e.g. protection against frontrunning and sandwich attacks) while allowing searchers to backrun the transaction via MEV IF it produces an arbitrage profit. If it doesn't generate an arbitrage profit it is processed as a regular private transaction. BackRunMe, gives a portion of this additional profit back to the user. The profit sharing ratio is as follows: 50% to miners, 25% to users, 20% to searchers and 5% to bloXroute. Users can use MetaMask directly on BackRunMe to trade on Uniswap or Sushiswap. Links https://backrunme.com/#/swap https://medium.com/bloxroute/there-is-light-in-the-dark-forest-2d7b77f4ca2d Flashbots \u00b6 Flashbots is a research and development organization formed to mitigate the negative externalities and existential risks posed by MEV. They aim to Democratize MEV Extraction through MEV-Geth, which enables a sealed-bid block space auction mechanism for communicating transaction order preference. ELI5 https://twitter.com/_silto_/status/1381292907567722498 Flashbots created an ETH node for miners, that not only watches the mempool like any other node, but also connects to a relayer (a server) operated by Flashbots. This MEV-Relay is a kind of parallel channel that directly connects miners to bots that want their transactions included. The transactions that the bots want to include are sent through the MEV-Relay as bundles containing: the transactions to execute a tip to the miner, coming as an ETH transfer These transactions use a 0 gwei gas price, as the payment to the miner is included in the transaction itself as the tip. Since these transactions are sent through a parallel private relay, it reduces the mempool bidding war, failed transactions bloating the blockchain, and overall gas cost for users. Links GitHub: https://github.com/flashbots Research: https://github.com/flashbots/mev-research Monthly Meetings: https://github.com/flashbots/pm API: https://blocks.flashbots.net/ Discord: https://discord.gg/7hvTycdNcK Medium: https://medium.com/flashbots https://medium.com/flashbots/frontrunning-the-mev-crisis-40629a613752 https://medium.com/flashbots/quantifying-mev-introducing-mev-explore-v0-5ccbee0f6d02 https://ethresear.ch/t/flashbots-frontrunning-the-mev-crisis/8251 mistX by alchemist \u00b6 mistX is a DEX that enables end users to send transactions through Flashbots bundles. All transactions are gasless. However, instead of paying gas to the miners mistX users pay miners a bribe/tip in ETH. The tip is either included in the trade or comes from the user's wallet. The exchange utilises Flashbots and as such transactions processed via mistX do not publish user transaction information to a public mempool, but instead bundle transactions together. This hides the information from front-runners and thus prevents transactions from being manipulated, front-run, or sandwiched. Links https://app.mistx.io/#/exchange KeeperDAO \u00b6 KeeperDAO is similar to a mining pool for Keepers. By incentivizing a game theory optimal strategy for cooperation among on-chain arbitrageurs, KeeperDAO provides an efficient mechanism for large scale arbitrage and liquidation trades on all DeFi protocols. The Hiding Game \u00b6 One of the 3 games that has been built. The Hiding Game refers to the cooperation between users and keepers to \u201chide\u201d MEV by wrapping trades/debt in specialised on-chain contracts. These contracts restrict profit extracting opportunities to KeeperDAO itself. Here's the ELI5 \u00b6 Users route their trades and loans through KeeperDAO, which attempts to extract any arbitrage or liquidation profit available. Those profits are returned back to the user in $ROOK tokens, and profits go into a pool controlled by $ROOK holders. By giving KeeperDAO priority access to arbitrage and liquidations, the Hiding Game maximizes the profits available from these opportunities. kCompound (Phase 2 of the Hiding Game) \u00b6 kCompound is the second phase of the Hiding Game. KeeperDAO posts collateral to save your position from being publicly liquidated. Instead, you get privately liquidated. KeeperDAO keeper will then find the best price for your collateral, targeting a 5% profit margin. This profit will then be split between you, the keeper, and the KeeperDAO treasury, meaning that kCompound borrowers will receive a portion of the profits from their own liquidation. Links https://keeperdao.com/#/ Wiki: https://github.com/keeperdao/docs/wiki kCompound: https://medium.com/keeperdao/introducing-kcompound-a23511c847a0 ArcherSwap \u00b6 Archerswap is a new DEX extension for Uniswap and Sushiswap that prevents frontrunning and offers traders zero slippage and zero cost cancellation swaps. This enables users to set slippage tolerance to 0%. Miners will only be paid if \"acceptance criteria\" are met, so any transaction that fails is not included on chain. One is for searchers to submit Flashbots-compatible bundles. The other is the Archer Relay Network (powers Archerswap) where users can submit private transactions and be protected from malicious MEV. Links https://swap.archerdao.io/#/swap Optimism \u00b6 Optimism are the original proposers of MEVA. MEV Auction (MEVA) is created in which the winner of the auction has the right to reorder submitted transactions and insert their own, as long as they do not delay any specific transaction by more than N blocks. Implementing the Auction \u00b6 The auction is able to extract MEV from miners by separating two functions 1) Transaction inclusion; and 2) transaction ordering. In order to implement MEVA roles are defined. Block producers determine transaction inclusion, and Sequencers determine transaction ordering. Block producers - Transaction Inclusion \u00b6 Block proposers are most analogous to traditional blockchain miners. Instead of proposing blocks with an ordering, they simply propose a set of transactions to eventually be included before N blocks. Sequencers - Transaction Ordering \u00b6 Sequencers are elected by a smart contract managed auction run by the block producers called the MEVA contract. This auction assigns the right to sequence the last N transactions. If, within a timeout the sequencer has not submitted an ordering which is included by block proposers, a new sequencer is elected. Implementation on Layer 2 \u00b6 It is possible to enshrine this MEVA contract directly on layer 1 (L1) blockchain consensus protocols. However, it is also possible to non-invasively add this mechanism in layer 2 (L2) and use it to manage Optimistic Rollup transactio ordering. In L2, L1 miners are repurposed and utilized as block proposers. MEVA contract is implemented and designated a single sequencer at a time. Links https://optimism.io/ https://ethresear.ch/t/mev-auction-auctioning-transaction-ordering-rights-as-a-solution-to-miner-extractable-value/6788 https://docs.google.com/presentation/d/1RaF1byflrLF3yUjd-5vXDZB1ZIRofVeK3JYVD6NPr30/edit#slide=id.gc9bdacc472_0_96 MiningDAO \u00b6 MiningDAO is building a decentralized and transparent protocol for block formation that aims to pass 100% of MEV to miners. Anyone with an Ethereum address can propose the next block to be mined (via a block sealhash), and attach a bounty for successfully mining it. The mining pools would then mine on the highest-bounty proposal. One is for searchers to submit Flashbots-compatible bundles. The other is the Archer Relay Network (powers Archerswap) where users can submit private transactions and be protected from malicious MEV. Links https://miningdao.io https://medium.com/mining-dao/introducing-miningdao-1e469626f7ad BackBone Cabal \u00b6 BackBone Cabal is a strategy that aims to extract MEV from SushiSwap. Profits are redistributed back to users who submitted trades in the first place in the form of eliminating their transaction cost (up to 90%). YCabal creates a virtualized mempool (i.e. a MEV-relay network) that aggregates transactions (batching). Users are able to opt in and send transactions to YCabal and in return for not having to pay for gas for their transaction, YCabal batch processes it and takes the arbitrage profit. Risk by inventory price risk is carried by a Vault, where Vault depositers are returned the profit the YCabal realizes. Links https://backbonecabal.com/ Knowledge Base: https://backbone-kb.netlify.app/ SushiSwap Proposal: https://forum.sushiswapclassic.org/t/proposal-ycabal-mev-strategy/3159 https://twitter.com/bloXrouteLabs/status/1357026919905173509 \u21a9","title":"FaaS or MEVA"},{"location":"mev/solutions/faas-or-meva/#front-running-as-a-service-faas-or-mev-auctions-meva","text":"In a FaaS or MEVA system, MEV is extracted in a variety of ways such as miners auctioning off the right to front-run users. Vitalik Buterin - Centralizing MEV extraction is good because it quarantines a revenue stream that could otherwise drive centralization in other sectors. Phil Daian, co-author of Flash Boys 2.0 - In this article, I\u2019m going to go deep into my personal arguments for why extracting MEV in cryptocurrencies isn\u2019t like theft, why it is a critical metric for network security in any distributed system secured by economic incentives (yes, including centralized ones), and what we should do about MEV in the next 3-5 years as a community.","title":"Front-running as a Service (FaaS) or MEV Auctions (MEVA)"},{"location":"mev/solutions/faas-or-meva/#private-transactions","text":"Typically, transactions are broadcast to the mempool where they remain pending until miners pick them and add to the block. Private transactions however, are only visible to the pool and are not broadcast to other nodes (pay more for faster transactions). Examples include 1inch Exchange's Stealth Transactions , Taichi Network and BloXroute . Private Transactions offered by Taichi Network bloXroute Labs has a wide range of offerings and their core competency is low global latency for DeFi (8% of blocks mined within 1 sec). Note For the other side of the coin, here is bloXroute Labs' take on why private mempools are not necessarily bad 1 : Front-runners don't need these services to outpace regular users, who are slower by seconds. They need it to outpace one another, where improving speed 0.8->0.15 sec matters. When a transaction is privately sent to pools other frontrunners can't attempt to front-run it. This helps avoid fierce escalation of fees. Links https://docs.bloxroute.com/apis/frontrunning-protection","title":"Private Transactions"},{"location":"mev/solutions/faas-or-meva/#backrunme-by-bloxroute","text":"BackRunMe is a service that allows users to submit private transactions (e.g. protection against frontrunning and sandwich attacks) while allowing searchers to backrun the transaction via MEV IF it produces an arbitrage profit. If it doesn't generate an arbitrage profit it is processed as a regular private transaction. BackRunMe, gives a portion of this additional profit back to the user. The profit sharing ratio is as follows: 50% to miners, 25% to users, 20% to searchers and 5% to bloXroute. Users can use MetaMask directly on BackRunMe to trade on Uniswap or Sushiswap. Links https://backrunme.com/#/swap https://medium.com/bloxroute/there-is-light-in-the-dark-forest-2d7b77f4ca2d","title":"BackRunMe by bloXroute"},{"location":"mev/solutions/faas-or-meva/#flashbots","text":"Flashbots is a research and development organization formed to mitigate the negative externalities and existential risks posed by MEV. They aim to Democratize MEV Extraction through MEV-Geth, which enables a sealed-bid block space auction mechanism for communicating transaction order preference. ELI5 https://twitter.com/_silto_/status/1381292907567722498 Flashbots created an ETH node for miners, that not only watches the mempool like any other node, but also connects to a relayer (a server) operated by Flashbots. This MEV-Relay is a kind of parallel channel that directly connects miners to bots that want their transactions included. The transactions that the bots want to include are sent through the MEV-Relay as bundles containing: the transactions to execute a tip to the miner, coming as an ETH transfer These transactions use a 0 gwei gas price, as the payment to the miner is included in the transaction itself as the tip. Since these transactions are sent through a parallel private relay, it reduces the mempool bidding war, failed transactions bloating the blockchain, and overall gas cost for users. Links GitHub: https://github.com/flashbots Research: https://github.com/flashbots/mev-research Monthly Meetings: https://github.com/flashbots/pm API: https://blocks.flashbots.net/ Discord: https://discord.gg/7hvTycdNcK Medium: https://medium.com/flashbots https://medium.com/flashbots/frontrunning-the-mev-crisis-40629a613752 https://medium.com/flashbots/quantifying-mev-introducing-mev-explore-v0-5ccbee0f6d02 https://ethresear.ch/t/flashbots-frontrunning-the-mev-crisis/8251","title":"Flashbots"},{"location":"mev/solutions/faas-or-meva/#mistx-by-alchemist","text":"mistX is a DEX that enables end users to send transactions through Flashbots bundles. All transactions are gasless. However, instead of paying gas to the miners mistX users pay miners a bribe/tip in ETH. The tip is either included in the trade or comes from the user's wallet. The exchange utilises Flashbots and as such transactions processed via mistX do not publish user transaction information to a public mempool, but instead bundle transactions together. This hides the information from front-runners and thus prevents transactions from being manipulated, front-run, or sandwiched. Links https://app.mistx.io/#/exchange","title":"mistX by alchemist"},{"location":"mev/solutions/faas-or-meva/#keeperdao","text":"KeeperDAO is similar to a mining pool for Keepers. By incentivizing a game theory optimal strategy for cooperation among on-chain arbitrageurs, KeeperDAO provides an efficient mechanism for large scale arbitrage and liquidation trades on all DeFi protocols.","title":"KeeperDAO"},{"location":"mev/solutions/faas-or-meva/#the-hiding-game","text":"One of the 3 games that has been built. The Hiding Game refers to the cooperation between users and keepers to \u201chide\u201d MEV by wrapping trades/debt in specialised on-chain contracts. These contracts restrict profit extracting opportunities to KeeperDAO itself.","title":"The Hiding Game"},{"location":"mev/solutions/faas-or-meva/#heres-the-eli5","text":"Users route their trades and loans through KeeperDAO, which attempts to extract any arbitrage or liquidation profit available. Those profits are returned back to the user in $ROOK tokens, and profits go into a pool controlled by $ROOK holders. By giving KeeperDAO priority access to arbitrage and liquidations, the Hiding Game maximizes the profits available from these opportunities.","title":"Here's the ELI5"},{"location":"mev/solutions/faas-or-meva/#kcompound-phase-2-of-the-hiding-game","text":"kCompound is the second phase of the Hiding Game. KeeperDAO posts collateral to save your position from being publicly liquidated. Instead, you get privately liquidated. KeeperDAO keeper will then find the best price for your collateral, targeting a 5% profit margin. This profit will then be split between you, the keeper, and the KeeperDAO treasury, meaning that kCompound borrowers will receive a portion of the profits from their own liquidation. Links https://keeperdao.com/#/ Wiki: https://github.com/keeperdao/docs/wiki kCompound: https://medium.com/keeperdao/introducing-kcompound-a23511c847a0","title":"kCompound (Phase 2 of the Hiding Game)"},{"location":"mev/solutions/faas-or-meva/#archerswap","text":"Archerswap is a new DEX extension for Uniswap and Sushiswap that prevents frontrunning and offers traders zero slippage and zero cost cancellation swaps. This enables users to set slippage tolerance to 0%. Miners will only be paid if \"acceptance criteria\" are met, so any transaction that fails is not included on chain. One is for searchers to submit Flashbots-compatible bundles. The other is the Archer Relay Network (powers Archerswap) where users can submit private transactions and be protected from malicious MEV. Links https://swap.archerdao.io/#/swap","title":"ArcherSwap"},{"location":"mev/solutions/faas-or-meva/#optimism","text":"Optimism are the original proposers of MEVA. MEV Auction (MEVA) is created in which the winner of the auction has the right to reorder submitted transactions and insert their own, as long as they do not delay any specific transaction by more than N blocks.","title":"Optimism"},{"location":"mev/solutions/faas-or-meva/#implementing-the-auction","text":"The auction is able to extract MEV from miners by separating two functions 1) Transaction inclusion; and 2) transaction ordering. In order to implement MEVA roles are defined. Block producers determine transaction inclusion, and Sequencers determine transaction ordering.","title":"Implementing the Auction"},{"location":"mev/solutions/faas-or-meva/#block-producers-transaction-inclusion","text":"Block proposers are most analogous to traditional blockchain miners. Instead of proposing blocks with an ordering, they simply propose a set of transactions to eventually be included before N blocks.","title":"Block producers - Transaction Inclusion"},{"location":"mev/solutions/faas-or-meva/#sequencers-transaction-ordering","text":"Sequencers are elected by a smart contract managed auction run by the block producers called the MEVA contract. This auction assigns the right to sequence the last N transactions. If, within a timeout the sequencer has not submitted an ordering which is included by block proposers, a new sequencer is elected.","title":"Sequencers - Transaction Ordering"},{"location":"mev/solutions/faas-or-meva/#implementation-on-layer-2","text":"It is possible to enshrine this MEVA contract directly on layer 1 (L1) blockchain consensus protocols. However, it is also possible to non-invasively add this mechanism in layer 2 (L2) and use it to manage Optimistic Rollup transactio ordering. In L2, L1 miners are repurposed and utilized as block proposers. MEVA contract is implemented and designated a single sequencer at a time. Links https://optimism.io/ https://ethresear.ch/t/mev-auction-auctioning-transaction-ordering-rights-as-a-solution-to-miner-extractable-value/6788 https://docs.google.com/presentation/d/1RaF1byflrLF3yUjd-5vXDZB1ZIRofVeK3JYVD6NPr30/edit#slide=id.gc9bdacc472_0_96","title":"Implementation on Layer 2"},{"location":"mev/solutions/faas-or-meva/#miningdao","text":"MiningDAO is building a decentralized and transparent protocol for block formation that aims to pass 100% of MEV to miners. Anyone with an Ethereum address can propose the next block to be mined (via a block sealhash), and attach a bounty for successfully mining it. The mining pools would then mine on the highest-bounty proposal. One is for searchers to submit Flashbots-compatible bundles. The other is the Archer Relay Network (powers Archerswap) where users can submit private transactions and be protected from malicious MEV. Links https://miningdao.io https://medium.com/mining-dao/introducing-miningdao-1e469626f7ad","title":"MiningDAO"},{"location":"mev/solutions/faas-or-meva/#backbone-cabal","text":"BackBone Cabal is a strategy that aims to extract MEV from SushiSwap. Profits are redistributed back to users who submitted trades in the first place in the form of eliminating their transaction cost (up to 90%). YCabal creates a virtualized mempool (i.e. a MEV-relay network) that aggregates transactions (batching). Users are able to opt in and send transactions to YCabal and in return for not having to pay for gas for their transaction, YCabal batch processes it and takes the arbitrage profit. Risk by inventory price risk is carried by a Vault, where Vault depositers are returned the profit the YCabal realizes. Links https://backbonecabal.com/ Knowledge Base: https://backbone-kb.netlify.app/ SushiSwap Proposal: https://forum.sushiswapclassic.org/t/proposal-ycabal-mev-strategy/3159 https://twitter.com/bloXrouteLabs/status/1357026919905173509 \u21a9","title":"BackBone Cabal"},{"location":"mev/solutions/mev-minimization-prevention/","text":"MEV Minimization/Prevention \u00b6 Conveyor - The Automata Network approach to tackling MEV \u00b6 At Automata, we have created Conveyor , a service that ingests and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering. When transactions are fed into Conveyor, it determines the order of the incoming transactions and makes it impossible for block producers to perform the following: Inject new transactions into the Conveyor output: The inserted transactions bypassing Conveyor is detectable by anyone because of signature mismatch. Delete ordered transactions: Transactions accepted by Conveyor are broadcasted everywhere so transactions cannot be deleted unless ALL block producers are colluding and censoring the transactions at the same time. From the DEX\u2019s perspective, they can choose to accept either Ordered transactions from Automata\u2019s Conveyor which is free from transaction reordering and other front-running transactions Other unordered transactions (which include front-running etc) that may negatively impact their users Why should users trust Conveyor? \u00b6 Automata\u2019s Conveyor runs on a decentralized compute plane backed by many Geode instances. Each Geode instance can be attested so anyone can publicly verify that the Geode is running on a system with genuine hardware (i.e., CPU) and that the Geode application code matches the version that is open-sourced and audited. This provides a strong guarantee that: The Geode code is untampered with The Geode data is inaccessible to even Geode providers (In which case they cannot act on said data to front-run transactions) Importantly, Automata\u2019s Conveyor is a chain-agnostic solution to the MEV issue, and works seamlessly on various platforms \u2014 zero modifications needed. Here\u2019s a demo on how trading pairs on Uniswap can be protected. An industry-first: Oblivious RAM \u00b6 In fully public computation, access pattern leakage is not negligible as everything is exposed. But in privacy-preserving computation, any tiny bit of information leakage becomes a significant issue. Studies have shown that access pattern leakage leads to exposure of sensitive information such as private keys from searchable encryption and trusted computing. This is where the Oblivious RAM algorithm comes into play. Automata\u2019s implementation is the first-of-its-kind in the blockchain industry, providing an exceedingly high degree of privacy in dApps. This greatly reduces the probability of user privacy being leaked even as access patterns are being monitored and analyzed by malicious actors. The Automata team has authored multiple research papers on state-of-the-art ORAM and hardware technologies to enhance the privacy and performance of existing networks. Robust P2P Primitives Using SGX Enclaves RAID 2020 PRO-ORAM: Practical Read-Only Oblivious RAM RAID 2019 OblivP2P: An Oblivious Peer-to-Peer Content Sharing System USENIX Security 2016 Preventing Page Faults from Telling Your Secrets Asia CCS 2016 The Fair Sequencing Service by ChainLink \u00b6 The idea behind FSS is to have an oracle network order the transactions sent to a particular contract SC, including both user transactions and oracle reports. Oracle nodes ingest transactions and then reach consensus on their ordering, rather than allowing a single leader to dictate it. FSS is a framework for implementing ordering policies, of which Aequitas (protocol for order-fairness in addition to consistency and liveness) is one example. It can alternatively support simpler approaches, such as straightforward encryption of transactions, which can then be decrypted in a threshold manner by oracle nodes after ordering. It will also support various policies for inserting oracle reports into a stream of transactions. (It can even support MEV auctions, if desired.) Links Blog post: https://blog.chain.link/chainlink-fair-sequencing-services-enabling-a-provably-fair-defi-ecosystem/ Whitepaper (to be released later) Arbitrum by Offchain Labs \u00b6 Arbitrum is against MEVA and FaaS. 3 Modes of Arbitrum: Single Sequencer: L2 MEV-Potential ( Mainnet Beta ) For Arbitrum\u2019s initial, flagship Mainnet beta release, the Sequencer will be controlled by a single entity. This entity has transaction ordering rights within the narrow / 15 minute window; users are trusting the Sequencer not to frontrun them. Distributed Sequencer With Fair Ordering: L2-MEV-minimized ( Mainnet Final Form ) The Arbitrum flagship chain will eventually have a distributed set of independent parties controlling the Sequencer. They will collectively propose state updates via the first BFT algorithm that enforces fair ordering within consensus (Aequitas) . Here, L2 MEV is only possible if >1/3 of the sequencing-parties maliciously collude, hence \u201cMEV-minimized.\u201d No Sequencer: No L2 MEV A chain can be created in which no permissioned entities have Sequencing rights. Ordering is determined entirely by the Inbox contract; lose the ability to get lower latency than L1, but gain is that no party involved in L2, including Arbitrum validators, has any say in transaction ordering, and thus no L2 MEV enters the picture. Links https://offchainlabs.com/ https://medium.com/offchainlabs/front-running-as-a-service-334c929c945 https://docs.google.com/document/d/1VOACGgTR84XWm5lH5Bki2nBcImi3lVRe2tYxf5F6XbA/edit Vega Protocol \u00b6 Traditionally, fairness in a blockchain has been defined in absolute terms, i.e. once a transaction is seen by a sufficient number of validators, it will be executed in some block, soon. Vega's proposal is to add a module to blockchains that supports the concept of relative fairness so that competing transactions may be sequenced under a known and understood protocol, and not subject to a validator\u2019s discretion. \" If there is a time t such that all honest validators saw a before t and b after t, then a must be scheduled before b\u201d. This is a property that can be assured of at any time with a minimal impact on performance. To get the best combination, their current approach is a hybrid of the two. In normal operation, the protocol will assure block fairness. If the network detects that this causes a bottleneck, it temporarily switches to the timed approach (thus sacrificing a little fairness for performance), before switching back once the bottleneck is resolved. However, Vega will ultimately make the level of fairness customisable by market. Links https://vega.xyz/ https://blog.vega.xyz/new-paper-fairness-and-front-running-an-invitation-for-feedback-cbb39a1a3eb Wendy, the Good Little Fairness Widget: https://vega.xyz/papers/fairness.pdf Video: https://www.youtube.com/watch?v=KjfLj5fhkGQ&t=18s&ab_channel=VegaProtocol CowSwap \u00b6 A collaboration between BalancerLabs and Gnosis, CowSwap is a DEX that leverages batch auctions to provide MEV protection, plus integrate with liquidity sources across DEXs to offer traders the best prices. When two traders each hold an asset the other wants, an order can be settled directly between them without an external market maker or liquidity provider. Any excess is settled in the same transaction with the best available AMM. The transaction is sent by professional \u201csolvers\u201d which set tight slippage bounds. Solvers compete with each other to achieve best prices for the user. Links https://cowswap.exchange/#/swap https://blog.gnosis.pm/introducing-gnosis-protocol-v2-and-balancer-gnosis-protocol-f693b2938ae4 Veedo by StarkWare \u00b6 VeeDo is StarkWare\u2019s STARK-based Verifiable Delay Function (VDF), and its PoC is now live on Mainnet. VeeDo's time-locks allow information to be sealed for a predetermined period of time (during the sequencing phase), and then made public. 2 approaches using privacy to minimize MEV Time-locks as part of the protocol layer Time-locks on Ethereum with smart contracts - supported today Links https://starkware.co/ https://medium.com/starkware/presenting-veedo-e4bbff77c7ae https://docs.google.com/presentation/d/1C_Rb_rtUXT2Nkettu_GPSlD9yCge8ioBNLRj5OBNbyY/edit#slide=id.gb576f94980_0_836 LibSubmarine \u00b6 LibSubmarine is an open-source smart contract library that protects your contract against front-runners by temporarily hiding transactions on-chain. Links https://libsubmarine.org/ Video: https://www.youtube.com/watch?v=N8PDKoptmPs&feature=emb_imp_woyt&ab_channel=IC3InitiativeforCryptocurrenciesandContracts GitHub: https://github.com/lorenzb/libsubmarine Sikka \u00b6 Sikka's MEV solution to censorship and frontrunning problems is using a technique called Threshold Decryption, as a plugin to the Tendermint Core BFT consensus engine to create mempool level privacy. With this plugin, users are able to submit encrypted transactions to the blockchain, which are only decrypted and executed after being committed to a block by a quorum of 2/3 validators. Links https://sikka.tech/ https://docs.google.com/presentation/d/1tQEUpZjy_U9J-VQAx1Wf5W9oOX5rrCY3AwjAb7ZgA68/edit#slide=id.p Shutter Network \u00b6 Shutter Network is an open-source project that aims to prevent frontrunning and malicious MEV on Ethereum by using a threshold cryptography-based distributed key generation (DKG) protocol. A Shutter transaction is a transaction protected from frontrunning in the target smart contract system. It therefore passes through a sequence of stages before it is executed. A Shutter transaction flow: Created and encrypted in the user's wallet; Sent to the batcher contract as a standard Ethereum transaction; Picked up and decrypted by the keypers; Sent to the executor contract, and Forwarded to the target contract. Links https://shutter.ghost.io/ GitHub: https://github.com/brainbot-com/shutter","title":"MEV Minimization / Prevention"},{"location":"mev/solutions/mev-minimization-prevention/#mev-minimizationprevention","text":"","title":"MEV Minimization/Prevention"},{"location":"mev/solutions/mev-minimization-prevention/#conveyor-the-automata-network-approach-to-tackling-mev","text":"At Automata, we have created Conveyor , a service that ingests and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering. When transactions are fed into Conveyor, it determines the order of the incoming transactions and makes it impossible for block producers to perform the following: Inject new transactions into the Conveyor output: The inserted transactions bypassing Conveyor is detectable by anyone because of signature mismatch. Delete ordered transactions: Transactions accepted by Conveyor are broadcasted everywhere so transactions cannot be deleted unless ALL block producers are colluding and censoring the transactions at the same time. From the DEX\u2019s perspective, they can choose to accept either Ordered transactions from Automata\u2019s Conveyor which is free from transaction reordering and other front-running transactions Other unordered transactions (which include front-running etc) that may negatively impact their users","title":"Conveyor - The Automata Network approach to tackling MEV"},{"location":"mev/solutions/mev-minimization-prevention/#why-should-users-trust-conveyor","text":"Automata\u2019s Conveyor runs on a decentralized compute plane backed by many Geode instances. Each Geode instance can be attested so anyone can publicly verify that the Geode is running on a system with genuine hardware (i.e., CPU) and that the Geode application code matches the version that is open-sourced and audited. This provides a strong guarantee that: The Geode code is untampered with The Geode data is inaccessible to even Geode providers (In which case they cannot act on said data to front-run transactions) Importantly, Automata\u2019s Conveyor is a chain-agnostic solution to the MEV issue, and works seamlessly on various platforms \u2014 zero modifications needed. Here\u2019s a demo on how trading pairs on Uniswap can be protected.","title":"Why should users trust Conveyor?"},{"location":"mev/solutions/mev-minimization-prevention/#an-industry-first-oblivious-ram","text":"In fully public computation, access pattern leakage is not negligible as everything is exposed. But in privacy-preserving computation, any tiny bit of information leakage becomes a significant issue. Studies have shown that access pattern leakage leads to exposure of sensitive information such as private keys from searchable encryption and trusted computing. This is where the Oblivious RAM algorithm comes into play. Automata\u2019s implementation is the first-of-its-kind in the blockchain industry, providing an exceedingly high degree of privacy in dApps. This greatly reduces the probability of user privacy being leaked even as access patterns are being monitored and analyzed by malicious actors. The Automata team has authored multiple research papers on state-of-the-art ORAM and hardware technologies to enhance the privacy and performance of existing networks. Robust P2P Primitives Using SGX Enclaves RAID 2020 PRO-ORAM: Practical Read-Only Oblivious RAM RAID 2019 OblivP2P: An Oblivious Peer-to-Peer Content Sharing System USENIX Security 2016 Preventing Page Faults from Telling Your Secrets Asia CCS 2016","title":"An industry-first: Oblivious RAM"},{"location":"mev/solutions/mev-minimization-prevention/#the-fair-sequencing-service-by-chainlink","text":"The idea behind FSS is to have an oracle network order the transactions sent to a particular contract SC, including both user transactions and oracle reports. Oracle nodes ingest transactions and then reach consensus on their ordering, rather than allowing a single leader to dictate it. FSS is a framework for implementing ordering policies, of which Aequitas (protocol for order-fairness in addition to consistency and liveness) is one example. It can alternatively support simpler approaches, such as straightforward encryption of transactions, which can then be decrypted in a threshold manner by oracle nodes after ordering. It will also support various policies for inserting oracle reports into a stream of transactions. (It can even support MEV auctions, if desired.) Links Blog post: https://blog.chain.link/chainlink-fair-sequencing-services-enabling-a-provably-fair-defi-ecosystem/ Whitepaper (to be released later)","title":"The Fair Sequencing Service by ChainLink"},{"location":"mev/solutions/mev-minimization-prevention/#arbitrum-by-offchain-labs","text":"Arbitrum is against MEVA and FaaS. 3 Modes of Arbitrum: Single Sequencer: L2 MEV-Potential ( Mainnet Beta ) For Arbitrum\u2019s initial, flagship Mainnet beta release, the Sequencer will be controlled by a single entity. This entity has transaction ordering rights within the narrow / 15 minute window; users are trusting the Sequencer not to frontrun them. Distributed Sequencer With Fair Ordering: L2-MEV-minimized ( Mainnet Final Form ) The Arbitrum flagship chain will eventually have a distributed set of independent parties controlling the Sequencer. They will collectively propose state updates via the first BFT algorithm that enforces fair ordering within consensus (Aequitas) . Here, L2 MEV is only possible if >1/3 of the sequencing-parties maliciously collude, hence \u201cMEV-minimized.\u201d No Sequencer: No L2 MEV A chain can be created in which no permissioned entities have Sequencing rights. Ordering is determined entirely by the Inbox contract; lose the ability to get lower latency than L1, but gain is that no party involved in L2, including Arbitrum validators, has any say in transaction ordering, and thus no L2 MEV enters the picture. Links https://offchainlabs.com/ https://medium.com/offchainlabs/front-running-as-a-service-334c929c945 https://docs.google.com/document/d/1VOACGgTR84XWm5lH5Bki2nBcImi3lVRe2tYxf5F6XbA/edit","title":"Arbitrum by Offchain Labs"},{"location":"mev/solutions/mev-minimization-prevention/#vega-protocol","text":"Traditionally, fairness in a blockchain has been defined in absolute terms, i.e. once a transaction is seen by a sufficient number of validators, it will be executed in some block, soon. Vega's proposal is to add a module to blockchains that supports the concept of relative fairness so that competing transactions may be sequenced under a known and understood protocol, and not subject to a validator\u2019s discretion. \" If there is a time t such that all honest validators saw a before t and b after t, then a must be scheduled before b\u201d. This is a property that can be assured of at any time with a minimal impact on performance. To get the best combination, their current approach is a hybrid of the two. In normal operation, the protocol will assure block fairness. If the network detects that this causes a bottleneck, it temporarily switches to the timed approach (thus sacrificing a little fairness for performance), before switching back once the bottleneck is resolved. However, Vega will ultimately make the level of fairness customisable by market. Links https://vega.xyz/ https://blog.vega.xyz/new-paper-fairness-and-front-running-an-invitation-for-feedback-cbb39a1a3eb Wendy, the Good Little Fairness Widget: https://vega.xyz/papers/fairness.pdf Video: https://www.youtube.com/watch?v=KjfLj5fhkGQ&t=18s&ab_channel=VegaProtocol","title":"Vega Protocol"},{"location":"mev/solutions/mev-minimization-prevention/#cowswap","text":"A collaboration between BalancerLabs and Gnosis, CowSwap is a DEX that leverages batch auctions to provide MEV protection, plus integrate with liquidity sources across DEXs to offer traders the best prices. When two traders each hold an asset the other wants, an order can be settled directly between them without an external market maker or liquidity provider. Any excess is settled in the same transaction with the best available AMM. The transaction is sent by professional \u201csolvers\u201d which set tight slippage bounds. Solvers compete with each other to achieve best prices for the user. Links https://cowswap.exchange/#/swap https://blog.gnosis.pm/introducing-gnosis-protocol-v2-and-balancer-gnosis-protocol-f693b2938ae4","title":"CowSwap"},{"location":"mev/solutions/mev-minimization-prevention/#veedo-by-starkware","text":"VeeDo is StarkWare\u2019s STARK-based Verifiable Delay Function (VDF), and its PoC is now live on Mainnet. VeeDo's time-locks allow information to be sealed for a predetermined period of time (during the sequencing phase), and then made public. 2 approaches using privacy to minimize MEV Time-locks as part of the protocol layer Time-locks on Ethereum with smart contracts - supported today Links https://starkware.co/ https://medium.com/starkware/presenting-veedo-e4bbff77c7ae https://docs.google.com/presentation/d/1C_Rb_rtUXT2Nkettu_GPSlD9yCge8ioBNLRj5OBNbyY/edit#slide=id.gb576f94980_0_836","title":"Veedo by StarkWare"},{"location":"mev/solutions/mev-minimization-prevention/#libsubmarine","text":"LibSubmarine is an open-source smart contract library that protects your contract against front-runners by temporarily hiding transactions on-chain. Links https://libsubmarine.org/ Video: https://www.youtube.com/watch?v=N8PDKoptmPs&feature=emb_imp_woyt&ab_channel=IC3InitiativeforCryptocurrenciesandContracts GitHub: https://github.com/lorenzb/libsubmarine","title":"LibSubmarine"},{"location":"mev/solutions/mev-minimization-prevention/#sikka","text":"Sikka's MEV solution to censorship and frontrunning problems is using a technique called Threshold Decryption, as a plugin to the Tendermint Core BFT consensus engine to create mempool level privacy. With this plugin, users are able to submit encrypted transactions to the blockchain, which are only decrypted and executed after being committed to a block by a quorum of 2/3 validators. Links https://sikka.tech/ https://docs.google.com/presentation/d/1tQEUpZjy_U9J-VQAx1Wf5W9oOX5rrCY3AwjAb7ZgA68/edit#slide=id.p","title":"Sikka"},{"location":"mev/solutions/mev-minimization-prevention/#shutter-network","text":"Shutter Network is an open-source project that aims to prevent frontrunning and malicious MEV on Ethereum by using a threshold cryptography-based distributed key generation (DKG) protocol. A Shutter transaction is a transaction protected from frontrunning in the target smart contract system. It therefore passes through a sequence of stages before it is executed. A Shutter transaction flow: Created and encrypted in the user's wallet; Sent to the batcher contract as a standard Ethereum transaction; Picked up and decrypted by the keypers; Sent to the executor contract, and Forwarded to the target contract. Links https://shutter.ghost.io/ GitHub: https://github.com/brainbot-com/shutter","title":"Shutter Network"},{"location":"mev/solutions/others/","text":"Others \u00b6 B.Protocol \u00b6 BProtocol aims to shift MEV to users. Users interact with existing lending platforms via B.Protocol smart contract. Liquidity providers (LP) provide a cushion to user debt, which gives B.Protocol precedence over other liquidators. LPs share their profits with the users, where user reward is proportional to his user rating. Links https://www.bprotocol.org/ https://docs.google.com/presentation/d/13UNysGCX9ZJG20lKaxr_qbhgKwcuHACdwlhGNKtzGt4/edit","title":"Others"},{"location":"mev/solutions/others/#others","text":"","title":"Others"},{"location":"mev/solutions/others/#bprotocol","text":"BProtocol aims to shift MEV to users. Users interact with existing lending platforms via B.Protocol smart contract. Liquidity providers (LP) provide a cushion to user debt, which gives B.Protocol precedence over other liquidators. LPs share their profits with the users, where user reward is proportional to his user rating. Links https://www.bprotocol.org/ https://docs.google.com/presentation/d/13UNysGCX9ZJG20lKaxr_qbhgKwcuHACdwlhGNKtzGt4/edit","title":"B.Protocol"},{"location":"witness/api/","text":"Witness API \u00b6 JSON-RPC is a remote procedure call protocol encoded in JSON. You can use this API to send queries to our Geode instance for Witness. Available Endpoints \u00b6 Provider(s) URL(s) Witness Geode Mainnet https://witness-geode-mainnet.ata.network:3350 JSON-RPC Methods \u00b6 geode_witness_vote \u00b6 Submits a signed Vote message in EIP712 format. Endpoint \u00b6 https://witness-geode-mainnet.ata.network:3350/v0/geode_witness_vote Return Code \u00b6 Returns an integer representing the status of the operation. Return Code Description 0 Success 1 SignatureFailure 2 ProposalNotActive 3 AlreadyVote 4 MissingWorkspace 5 IncorrectChainId 6 InternalError 7 WorkspaceDataError 8 ChainError 9 InsufficientBalance The function takes in a signed vote in EIP712 format. Data Format \u00b6 Request Format \u00b6 { \"id\" : 0 , \"jsonrpc\" : \"2.0\" , \"method\" : \"geode_witness_vote\" , \"params\" : { \"vote\" : Sig ne dEIP 712 Vo te } } SignedEIP712Vote Format \u00b6 { \"msg\" : EIP 712 Vo te , \"v\" : U 256 , \"r\" : H 256 , \"s\" : H 256 , } { type : \"object\" , properties : { msg : { type : \"object\" }, v : { type : \"string\" }, r : { type : \"string\" }, s : { type : \"string\" } }, required : [ \"msg\" , \"v\" , \"r\" , \"s\" ] } EIP712Vote Format \u00b6 { \"types\" : { \"EIP712Domain\" : EIP 712 Domai n Type , \"Vote\" : Vo te Type , }, \"domain\" : EIP 712 Domai n Da ta , \"primaryType\" : S tr i n g , \"message\" : Vo te , } { type : \"object\" , properties : { types : { type : \"object\" , properties : { EIP712Domain : { type : \"array\" , items : { name : \"string\" , type : \"string\" }, minItems : 4 , maxItems : 4 }, Vote : { type : \"array\" , items : { name : \"string\" , type : \"string\" }, minItems : 4 , maxItems : 4 }, }, required : [ \"EIP712Domain\" , \"Vote\" ] }, domain : { type : \"object\" , properties : { name : \"string\" , version : \"string\" , chainId : \"string\" , verifyingContract : \"string\" }, required : [ \"name\" , \"version\" , \"chainId\" , \"verifyingContract\" ] }, primaryType : { type : \"string\" }, message : { type : \"object\" } }, required : [ \"types\" , \"domain\" , \"primaryType\" , \"message\" ] } Vote Format \u00b6 { type : \"object\" , properties : { voter : \"string\" , proposal : \"string\" , option : \"number\" , timestamp : \"number\" }, required : [ \"voter\" , \"primaryType\" , \"domain\" , \"message\" ] } Sample JSON-RPC Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"method\" : \"geode_witness_vote\" , \"params\" :{ \"vote\" :{ \"msg\" :{ \"types\" :{ \"EIP712Domain\" :[ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"version\" , \"type\" : \"string\" }, { \"name\" : \"chainId\" , \"type\" : \"uint256\" }, { \"name\" : \"verifyingContract\" , \"type\" : \"address\" } ], \"Vote\" :[ { \"name\" : \"voter\" , \"type\" : \"uint256\" }, { \"name\" : \"proposal\" , \"type\" : \"uint256\" }, { \"name\" : \"option\" , \"type\" : \"uint32\" }, { \"name\" : \"timestamp\" , \"type\" : \"uint64\" } ] }, \"domain\" :{ \"name\" : \"Witness\" , \"version\" : \"0.1.0\" , \"chainId\" : \"42\" , \"verifyingContract\" : \"0xdEB55768F6D1a3E6771A4096531aD6ea258A925e\" }, \"primaryType\" : \"Vote\" , \"message\" :{ \"voter\" : \"0x0000000000000000000000007ef99b0e5beb8ae42dbf126b40b87410a440a32a\" , \"proposal\" : \"0x10002c\" , \"option\" : 2 , \"timestamp\" : 1617188809 } }, \"v\" : 28 , \"r\" : \"0x491b2a733067508f789bb4d180329b1fd9327d79a8135997eada08b3217cbb72\" , \"s\" : \"0x4e48960bef350ea161c997c3c2e881329de0d09d4fddb5781c6719308cc6b260\" } }, \"id\" : 73 } Sample Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"result\" : 0 , \"id\" : 73 } Metamask Support \u00b6 You can use Metamask for signing and sending the message by refering here: Sign-Typed-Data-v4 .","title":"Witness API"},{"location":"witness/api/#witness-api","text":"JSON-RPC is a remote procedure call protocol encoded in JSON. You can use this API to send queries to our Geode instance for Witness.","title":"Witness API"},{"location":"witness/api/#available-endpoints","text":"Provider(s) URL(s) Witness Geode Mainnet https://witness-geode-mainnet.ata.network:3350","title":"Available Endpoints"},{"location":"witness/api/#json-rpc-methods","text":"","title":"JSON-RPC Methods"},{"location":"witness/api/#geode_witness_vote","text":"Submits a signed Vote message in EIP712 format.","title":"geode_witness_vote"},{"location":"witness/api/#endpoint","text":"https://witness-geode-mainnet.ata.network:3350/v0/geode_witness_vote","title":"Endpoint"},{"location":"witness/api/#return-code","text":"Returns an integer representing the status of the operation. Return Code Description 0 Success 1 SignatureFailure 2 ProposalNotActive 3 AlreadyVote 4 MissingWorkspace 5 IncorrectChainId 6 InternalError 7 WorkspaceDataError 8 ChainError 9 InsufficientBalance The function takes in a signed vote in EIP712 format.","title":"Return Code"},{"location":"witness/api/#data-format","text":"","title":"Data Format"},{"location":"witness/api/#request-format","text":"{ \"id\" : 0 , \"jsonrpc\" : \"2.0\" , \"method\" : \"geode_witness_vote\" , \"params\" : { \"vote\" : Sig ne dEIP 712 Vo te } }","title":"Request Format"},{"location":"witness/api/#signedeip712vote-format","text":"{ \"msg\" : EIP 712 Vo te , \"v\" : U 256 , \"r\" : H 256 , \"s\" : H 256 , } { type : \"object\" , properties : { msg : { type : \"object\" }, v : { type : \"string\" }, r : { type : \"string\" }, s : { type : \"string\" } }, required : [ \"msg\" , \"v\" , \"r\" , \"s\" ] }","title":"SignedEIP712Vote Format"},{"location":"witness/api/#eip712vote-format","text":"{ \"types\" : { \"EIP712Domain\" : EIP 712 Domai n Type , \"Vote\" : Vo te Type , }, \"domain\" : EIP 712 Domai n Da ta , \"primaryType\" : S tr i n g , \"message\" : Vo te , } { type : \"object\" , properties : { types : { type : \"object\" , properties : { EIP712Domain : { type : \"array\" , items : { name : \"string\" , type : \"string\" }, minItems : 4 , maxItems : 4 }, Vote : { type : \"array\" , items : { name : \"string\" , type : \"string\" }, minItems : 4 , maxItems : 4 }, }, required : [ \"EIP712Domain\" , \"Vote\" ] }, domain : { type : \"object\" , properties : { name : \"string\" , version : \"string\" , chainId : \"string\" , verifyingContract : \"string\" }, required : [ \"name\" , \"version\" , \"chainId\" , \"verifyingContract\" ] }, primaryType : { type : \"string\" }, message : { type : \"object\" } }, required : [ \"types\" , \"domain\" , \"primaryType\" , \"message\" ] }","title":"EIP712Vote Format"},{"location":"witness/api/#vote-format","text":"{ type : \"object\" , properties : { voter : \"string\" , proposal : \"string\" , option : \"number\" , timestamp : \"number\" }, required : [ \"voter\" , \"primaryType\" , \"domain\" , \"message\" ] }","title":"Vote Format"},{"location":"witness/api/#sample-json-rpc-request","text":"{ \"jsonrpc\" : \"2.0\" , \"method\" : \"geode_witness_vote\" , \"params\" :{ \"vote\" :{ \"msg\" :{ \"types\" :{ \"EIP712Domain\" :[ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"version\" , \"type\" : \"string\" }, { \"name\" : \"chainId\" , \"type\" : \"uint256\" }, { \"name\" : \"verifyingContract\" , \"type\" : \"address\" } ], \"Vote\" :[ { \"name\" : \"voter\" , \"type\" : \"uint256\" }, { \"name\" : \"proposal\" , \"type\" : \"uint256\" }, { \"name\" : \"option\" , \"type\" : \"uint32\" }, { \"name\" : \"timestamp\" , \"type\" : \"uint64\" } ] }, \"domain\" :{ \"name\" : \"Witness\" , \"version\" : \"0.1.0\" , \"chainId\" : \"42\" , \"verifyingContract\" : \"0xdEB55768F6D1a3E6771A4096531aD6ea258A925e\" }, \"primaryType\" : \"Vote\" , \"message\" :{ \"voter\" : \"0x0000000000000000000000007ef99b0e5beb8ae42dbf126b40b87410a440a32a\" , \"proposal\" : \"0x10002c\" , \"option\" : 2 , \"timestamp\" : 1617188809 } }, \"v\" : 28 , \"r\" : \"0x491b2a733067508f789bb4d180329b1fd9327d79a8135997eada08b3217cbb72\" , \"s\" : \"0x4e48960bef350ea161c997c3c2e881329de0d09d4fddb5781c6719308cc6b260\" } }, \"id\" : 73 }","title":"Sample JSON-RPC Request"},{"location":"witness/api/#sample-response","text":"{ \"jsonrpc\" : \"2.0\" , \"result\" : 0 , \"id\" : 73 }","title":"Sample Response"},{"location":"witness/api/#metamask-support","text":"You can use Metamask for signing and sending the message by refering here: Sign-Typed-Data-v4 .","title":"Metamask Support"},{"location":"witness/introduction/","text":"Introduction \u00b6 Automata Witness is a customizable voting service for decentralized applications. Witness provides a fully decentralized voting platform (with privacy features) across different blockchains. Features \u00b6 Privacy : You can choose different types of votes with different privacy levels e.g. Public (full disclosure of voter address and number of votes), Medium (only number of votes), and Private (only voting result is published \u2014 voter identities and number of votes are not). Low-cost : Voting is conducted off-chain so there is no gas cost and a wider range of token holders can participate in governance without being deterred by high gas fees. Chainhook : Trigger on-chain execution based on the voting results. Chainhook enables calling of the on-chain contract which was registered at proposal creation. Modularity : Each of these functions can be used as standalones, or together. If a project wants to use Witness as a signaling tool without on-chain execution, that is also possible. Platforms \u00b6 Witness currently supports the following with more to be added in future: Ethereum (Mainnet, Kovan Testnet) Binance Smart Chain (Mainnet, Testnet) Plasm Network (Dusty Testnet) Clover Finance (Testnet) Darwinia (Pangolin Testnet) Moonbase (Alpha Testnet) Polygon (Matic Mainnet) Avalanche (Mainnet) HECO (Mainnet, Testnet) Next, we will be adding other EVM-based chains and Substrate-based chains to the list. Feature Support \u00b6 Platform Private Voting Chainhook Public Voting Ethereum Mainnet Ethereum Kovan Testnet Binance Smart Chain Mainnet Binance Smart Chain Testnet Plasm Network Dusty Testnet Clover Finance Testnet Darwinia Pangolin Testnet Moonbase Alpha Testnet Polygon Avalanche HECO Mainnet HECO Testnet","title":"Introduction"},{"location":"witness/introduction/#introduction","text":"Automata Witness is a customizable voting service for decentralized applications. Witness provides a fully decentralized voting platform (with privacy features) across different blockchains.","title":"Introduction"},{"location":"witness/introduction/#features","text":"Privacy : You can choose different types of votes with different privacy levels e.g. Public (full disclosure of voter address and number of votes), Medium (only number of votes), and Private (only voting result is published \u2014 voter identities and number of votes are not). Low-cost : Voting is conducted off-chain so there is no gas cost and a wider range of token holders can participate in governance without being deterred by high gas fees. Chainhook : Trigger on-chain execution based on the voting results. Chainhook enables calling of the on-chain contract which was registered at proposal creation. Modularity : Each of these functions can be used as standalones, or together. If a project wants to use Witness as a signaling tool without on-chain execution, that is also possible.","title":"Features"},{"location":"witness/introduction/#platforms","text":"Witness currently supports the following with more to be added in future: Ethereum (Mainnet, Kovan Testnet) Binance Smart Chain (Mainnet, Testnet) Plasm Network (Dusty Testnet) Clover Finance (Testnet) Darwinia (Pangolin Testnet) Moonbase (Alpha Testnet) Polygon (Matic Mainnet) Avalanche (Mainnet) HECO (Mainnet, Testnet) Next, we will be adding other EVM-based chains and Substrate-based chains to the list.","title":"Platforms"},{"location":"witness/introduction/#feature-support","text":"Platform Private Voting Chainhook Public Voting Ethereum Mainnet Ethereum Kovan Testnet Binance Smart Chain Mainnet Binance Smart Chain Testnet Plasm Network Dusty Testnet Clover Finance Testnet Darwinia Pangolin Testnet Moonbase Alpha Testnet Polygon Avalanche HECO Mainnet HECO Testnet","title":"Feature Support"},{"location":"witness/user-guide/","text":"Getting started \u00b6 For Users \u00b6 First, choose the blockchain network that you wish to connect to. Then search for the project in the Search bar. Look for the proposal that you are interested in voting for. Attention Before voting, please ensure that: Your MetaMask wallet is connected to the corresponding network you are voting in. You can get necessary info about the blockchains we support here and follow these instructions to add to your MetaMask wallet Your account has the necessary number of ERC20/BEP20 tokens to qualify for the vote as specified by the block height in the snapshot . Note If you wish to get tokens for the testnet, please refer to the Getting tokens section for more information Once you have obtained tokens, you can participate in the vote by clicking on your option of choice. Currently, we are calculating the token balance for each voter based on the block height that each proposal mandates. The results of vote can be seen after the vote has concluded and finazlied. For Private Proposals: Only the final winning option will be shown For Medium Proposals: The number of votes for each option will be shown. For Public Proposals: The voter information will be transparent to the public. For Project Owners \u00b6 Project owners can create a workspace for hosting proposals. Project teams or community members can then proceed to create proposals. Currently the metadata is stored on the testnet of Automata Network. Connect to the testnet to create workspaces or propsals. Adding the Automata Network testnet to your network \u00b6 Add the Automata Network to your existing network using the following details: Field Value Network Name Automata Network New RPC URL https://rpc.ata.network/ Chain ID 86 Currency Symbol ATA The option to add network can be found by clicking on: Profile Picture >> Settings >> Networks >> Add Network or: Network name >> Custom RPC Connecting Your Metamask Wallet \u00b6 If you see Connect wallet or Not connected show up in your MetaMask, this means that you are not connected ! You can follow these steps to connect your wallet: Click on Connect wallet at the top right corner Click on MetaMask Select the account you wish to connect with MetaMask Connect your account Creating a workspace \u00b6 You can create a workspace from the landing page Witness . Tips Before creating a workspace for your token, please ensure the following: Your MetaMask wallet is connected to Automata Network Your account has the necessary ATA tokens If you do not have the necessary tokens, please refer to Getting tokens . Once ready, you can create a workspace by: Clicking on Create Choose the correct blockchain network for your workspace Fill in your workspace name Fill in your workspace specifications Enter your token contract hash Click on Create Creating a new proposal \u00b6 Head over to the workspace of a project you're interested in creating a proposal for. If the workspace has not been created yet, refer to Creating a Workspace . Tips Before creating a proposal, please ensure that: Your MetaMask wallet is connected to Automata Network Your account has the necessary ATA tokens If you do not have the necessary tokens, you can refer to Getting tokens . Once ready, you can create a proposal by: Clicking on New Proposal Fill in your proposal title Fill in content for your proposal Add / Edit / Remove your voting options Select the start and end date Click on Publish Chainhook \u00b6 This feature enables calling of the on-chain contract which was registered at proposal creation. Note this is still in beta so it's only enabled for selected platform currently. Each voting option can be followed with a chainhook or, you can create a chainhook by: Clicking on Add Chainhook followed by the option field Choose the smart contract language for your Chainhook Fill in the contract address where your Chainhook will take effect Fill in the function name Add arguments for your callback function Each argument is paired with the type and the value field Currently only uint256, uint256[], address, address[] are supported as argument types Follow the example for input value by hovering above the value field Appendix \u00b6 Setting up MetaMask \u00b6 MetaMask is a cryptocurrency wallet used to interact with the Ethereum blockchain. As it is required when using Automata Network, you can install the extension via the official download page here , or simply add the extension for your browser using the links below: Chrome Firefox Brave Edge Getting tokens \u00b6 Getting ERC20 tokens (Ethereum Kovan Network) \u00b6 To get your tokens, head over to our faucet at https://faucet.ata.network/ . Copy the address of your account in MetaMask by clicking on 'Copy to Clipboard' and then paste the address into the input field for your desired token. Click Submit . When receiving ERC-20 tokens, the relevant contract hash can be found right next to the words \"Ethereum Kovan Network\". You can copy this by clicking on the Copy button next to it. Getting BEP20 tokens in the Binance Smart Chain test network \u00b6 To get tokens in the BSC test network, you can search for the contract address using https://testnet.bscscan.com/ . Use the faucet https://testnet.venus.io/faucet or https://testnet.binance.org/faucet-smart to get tokens. Supported Chain Info \u00b6 Field Value Network Name BSC mainnet New RPC URL https://bsc-dataseed1.defibit.io/ Chain ID 56 Field Value Network Name BSC testnet New RPC URL https://data-seed-prebsc-1-s1.binance.org:8545/ Chain ID 97 Field Value Network Name Plasm Dusty testnet New RPC URL https://rpc.dusty.plasmnet.io:8545/ Chain ID 80 Field Value Network Name Clover testnet New RPC URL https://rpc.clover.finance/ Chain ID 1023 Field Value Network Name Dawinia Pangolin testnet New RPC URL https://pangolin-rpc.darwinia.network/ Chain ID 43 Field Value Network Name Moonbase Alpha testnet New RPC URL https://rpc.testnet.moonbeam.network/ Chain ID 1287 Field Value Network Name Polygon New RPC URL https://rpc-mainnet.matic.network Chain ID 137 Field Value Network Name Avalanche New RPC URL https://api.avax.network/ext/bc/C/rpc Chain ID 43114 Ethereum Mainnet and Kovan Testnet are not listed here since they are natively supported by Metamask Get supported by Witness \u00b6 We are open to onboard any EVM networks as our first batch of supported networks by Witness. The following details are required for us to complete the onboarding. The integration only involves small changes in Witness on our side. Chain ID JSON-RPC URL Blockchain Explorer URL (optional) Faucet (for testnet)","title":"User Guide"},{"location":"witness/user-guide/#getting-started","text":"","title":"Getting started"},{"location":"witness/user-guide/#for-users","text":"First, choose the blockchain network that you wish to connect to. Then search for the project in the Search bar. Look for the proposal that you are interested in voting for. Attention Before voting, please ensure that: Your MetaMask wallet is connected to the corresponding network you are voting in. You can get necessary info about the blockchains we support here and follow these instructions to add to your MetaMask wallet Your account has the necessary number of ERC20/BEP20 tokens to qualify for the vote as specified by the block height in the snapshot . Note If you wish to get tokens for the testnet, please refer to the Getting tokens section for more information Once you have obtained tokens, you can participate in the vote by clicking on your option of choice. Currently, we are calculating the token balance for each voter based on the block height that each proposal mandates. The results of vote can be seen after the vote has concluded and finazlied. For Private Proposals: Only the final winning option will be shown For Medium Proposals: The number of votes for each option will be shown. For Public Proposals: The voter information will be transparent to the public.","title":"For Users"},{"location":"witness/user-guide/#for-project-owners","text":"Project owners can create a workspace for hosting proposals. Project teams or community members can then proceed to create proposals. Currently the metadata is stored on the testnet of Automata Network. Connect to the testnet to create workspaces or propsals.","title":"For Project Owners"},{"location":"witness/user-guide/#adding-the-automata-network-testnet-to-your-network","text":"Add the Automata Network to your existing network using the following details: Field Value Network Name Automata Network New RPC URL https://rpc.ata.network/ Chain ID 86 Currency Symbol ATA The option to add network can be found by clicking on: Profile Picture >> Settings >> Networks >> Add Network or: Network name >> Custom RPC","title":"Adding the Automata Network testnet to your network"},{"location":"witness/user-guide/#connecting-your-metamask-wallet","text":"If you see Connect wallet or Not connected show up in your MetaMask, this means that you are not connected ! You can follow these steps to connect your wallet: Click on Connect wallet at the top right corner Click on MetaMask Select the account you wish to connect with MetaMask Connect your account","title":"Connecting Your Metamask Wallet"},{"location":"witness/user-guide/#creating-a-workspace","text":"You can create a workspace from the landing page Witness . Tips Before creating a workspace for your token, please ensure the following: Your MetaMask wallet is connected to Automata Network Your account has the necessary ATA tokens If you do not have the necessary tokens, please refer to Getting tokens . Once ready, you can create a workspace by: Clicking on Create Choose the correct blockchain network for your workspace Fill in your workspace name Fill in your workspace specifications Enter your token contract hash Click on Create","title":"Creating a workspace"},{"location":"witness/user-guide/#creating-a-new-proposal","text":"Head over to the workspace of a project you're interested in creating a proposal for. If the workspace has not been created yet, refer to Creating a Workspace . Tips Before creating a proposal, please ensure that: Your MetaMask wallet is connected to Automata Network Your account has the necessary ATA tokens If you do not have the necessary tokens, you can refer to Getting tokens . Once ready, you can create a proposal by: Clicking on New Proposal Fill in your proposal title Fill in content for your proposal Add / Edit / Remove your voting options Select the start and end date Click on Publish","title":"Creating a new proposal"},{"location":"witness/user-guide/#chainhook","text":"This feature enables calling of the on-chain contract which was registered at proposal creation. Note this is still in beta so it's only enabled for selected platform currently. Each voting option can be followed with a chainhook or, you can create a chainhook by: Clicking on Add Chainhook followed by the option field Choose the smart contract language for your Chainhook Fill in the contract address where your Chainhook will take effect Fill in the function name Add arguments for your callback function Each argument is paired with the type and the value field Currently only uint256, uint256[], address, address[] are supported as argument types Follow the example for input value by hovering above the value field","title":"Chainhook"},{"location":"witness/user-guide/#appendix","text":"","title":"Appendix"},{"location":"witness/user-guide/#setting-up-metamask","text":"MetaMask is a cryptocurrency wallet used to interact with the Ethereum blockchain. As it is required when using Automata Network, you can install the extension via the official download page here , or simply add the extension for your browser using the links below: Chrome Firefox Brave Edge","title":"Setting up MetaMask"},{"location":"witness/user-guide/#getting-tokens","text":"","title":"Getting tokens"},{"location":"witness/user-guide/#getting-erc20-tokens-ethereum-kovan-network","text":"To get your tokens, head over to our faucet at https://faucet.ata.network/ . Copy the address of your account in MetaMask by clicking on 'Copy to Clipboard' and then paste the address into the input field for your desired token. Click Submit . When receiving ERC-20 tokens, the relevant contract hash can be found right next to the words \"Ethereum Kovan Network\". You can copy this by clicking on the Copy button next to it.","title":"Getting ERC20 tokens (Ethereum Kovan Network)"},{"location":"witness/user-guide/#getting-bep20-tokens-in-the-binance-smart-chain-test-network","text":"To get tokens in the BSC test network, you can search for the contract address using https://testnet.bscscan.com/ . Use the faucet https://testnet.venus.io/faucet or https://testnet.binance.org/faucet-smart to get tokens.","title":"Getting BEP20 tokens in the Binance Smart Chain test network"},{"location":"witness/user-guide/#supported-chain-info","text":"Field Value Network Name BSC mainnet New RPC URL https://bsc-dataseed1.defibit.io/ Chain ID 56 Field Value Network Name BSC testnet New RPC URL https://data-seed-prebsc-1-s1.binance.org:8545/ Chain ID 97 Field Value Network Name Plasm Dusty testnet New RPC URL https://rpc.dusty.plasmnet.io:8545/ Chain ID 80 Field Value Network Name Clover testnet New RPC URL https://rpc.clover.finance/ Chain ID 1023 Field Value Network Name Dawinia Pangolin testnet New RPC URL https://pangolin-rpc.darwinia.network/ Chain ID 43 Field Value Network Name Moonbase Alpha testnet New RPC URL https://rpc.testnet.moonbeam.network/ Chain ID 1287 Field Value Network Name Polygon New RPC URL https://rpc-mainnet.matic.network Chain ID 137 Field Value Network Name Avalanche New RPC URL https://api.avax.network/ext/bc/C/rpc Chain ID 43114 Ethereum Mainnet and Kovan Testnet are not listed here since they are natively supported by Metamask","title":"Supported Chain Info"},{"location":"witness/user-guide/#get-supported-by-witness","text":"We are open to onboard any EVM networks as our first batch of supported networks by Witness. The following details are required for us to complete the onboarding. The integration only involves small changes in Witness on our side. Chain ID JSON-RPC URL Blockchain Explorer URL (optional) Faucet (for testnet)","title":"Get supported by Witness"}]}