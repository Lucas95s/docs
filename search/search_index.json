{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Automata Network \u00b6 Automata Network is a decentralized service protocol that provides middleware-like services for dApps to achieve traceless privacy, high assurance and frictionless computation. The MEV Wiki \u00b6 Flashboys, Flashbots, Dark Forests and more.. Witness \u00b6 Witness is a privacy-first off-chain governance solution with on-chain execution. Please see the guide to start. ContextFree \u00b6 ContextFree is the canary network of Automata Network. Please see the wallet guide here! NFTFair \u00b6 Automata NFTFair is an NFT launch platform. Read the introduction to learn more about the platform. AnyDAO \u00b6 Automata AnyDAO is a governance platform for DAOs. Read the introduction to learn more about the platform. 2FA Guru \u00b6 Automata 2FA Guru is a middleware to protect your assets. Read the introduction to setup your 2FA Guru. XATA.FI \u00b6 XATA.FI is a Fair Liquidity Provisioning protocol to minimize MEV. Read the introduction to learn more about the protocol.","title":"Automata Network"},{"location":"#automata-network","text":"Automata Network is a decentralized service protocol that provides middleware-like services for dApps to achieve traceless privacy, high assurance and frictionless computation.","title":"Automata Network"},{"location":"#the-mev-wiki","text":"Flashboys, Flashbots, Dark Forests and more..","title":"The MEV Wiki"},{"location":"#witness","text":"Witness is a privacy-first off-chain governance solution with on-chain execution. Please see the guide to start.","title":"Witness"},{"location":"#contextfree","text":"ContextFree is the canary network of Automata Network. Please see the wallet guide here!","title":"ContextFree"},{"location":"#nftfair","text":"Automata NFTFair is an NFT launch platform. Read the introduction to learn more about the platform.","title":"NFTFair"},{"location":"#anydao","text":"Automata AnyDAO is a governance platform for DAOs. Read the introduction to learn more about the platform.","title":"AnyDAO"},{"location":"#2fa-guru","text":"Automata 2FA Guru is a middleware to protect your assets. Read the introduction to setup your 2FA Guru.","title":"2FA Guru"},{"location":"#xatafi","text":"XATA.FI is a Fair Liquidity Provisioning protocol to minimize MEV. Read the introduction to learn more about the protocol.","title":"XATA.FI"},{"location":"2fa/introduction/","text":"Introduction \u00b6 2FA Guru by Automata is a blockchain-based authentication solution that secures access to accounts and protects users with an active defence. There are a number of known scenarios where hackers can brute-force attacks: User-controlled private keys can be compromised or stolen Exploitation of excessive or unlimited ERC20 allowance Rise of social engineering attacks, such as phishing scams Not all security measures are made equal. 2FA Guru\u2019s secret generation, storage and verification is based on the strongest technical guarantees with Automata\u2019s impenetrable technical design. This makes it nigh-impossible for malicious agents to intercept, obtain, or duplicate the authentication factor. 2FA Guru features \u00b6 Anti-phishing protection. Crypto is fun and exciting, but there are serious risks. Make sure your accounts are resistant to real-time identity attacks. Multi-chain support. 2FA Guru is currently live on Polygon mainnet. We\u2019re EVM-compatible and working hard to expand the range of supported networks - If you\u2019d like us to prioritise a chain, submit a proposal here or drop us a message . One-time setup. The additional layer of protection extends across all dApps supported by 2FA Guru on the same blockchain network. Developer-oriented integration. Deploy and secure dApps easily with 2FA Guru\u2019s smart contract. Smooth onboarding. 2FA Guru fits seamlessly into your workflow by working with your favourite tools such as 1Password, LastPass and more. How 2FA Guru works \u00b6 Login with your primary or preferred wallet on 2FA Guru Add your 2FA Authenticator application and complete setup Link a recovery wallet to your primary wallet to be extra safe Follow the user guide for more details. If you're a developer, head over here to view the contract guide .","title":"Introduction"},{"location":"2fa/introduction/#introduction","text":"2FA Guru by Automata is a blockchain-based authentication solution that secures access to accounts and protects users with an active defence. There are a number of known scenarios where hackers can brute-force attacks: User-controlled private keys can be compromised or stolen Exploitation of excessive or unlimited ERC20 allowance Rise of social engineering attacks, such as phishing scams Not all security measures are made equal. 2FA Guru\u2019s secret generation, storage and verification is based on the strongest technical guarantees with Automata\u2019s impenetrable technical design. This makes it nigh-impossible for malicious agents to intercept, obtain, or duplicate the authentication factor.","title":"Introduction"},{"location":"2fa/introduction/#2fa-guru-features","text":"Anti-phishing protection. Crypto is fun and exciting, but there are serious risks. Make sure your accounts are resistant to real-time identity attacks. Multi-chain support. 2FA Guru is currently live on Polygon mainnet. We\u2019re EVM-compatible and working hard to expand the range of supported networks - If you\u2019d like us to prioritise a chain, submit a proposal here or drop us a message . One-time setup. The additional layer of protection extends across all dApps supported by 2FA Guru on the same blockchain network. Developer-oriented integration. Deploy and secure dApps easily with 2FA Guru\u2019s smart contract. Smooth onboarding. 2FA Guru fits seamlessly into your workflow by working with your favourite tools such as 1Password, LastPass and more.","title":"2FA Guru features"},{"location":"2fa/introduction/#how-2fa-guru-works","text":"Login with your primary or preferred wallet on 2FA Guru Add your 2FA Authenticator application and complete setup Link a recovery wallet to your primary wallet to be extra safe Follow the user guide for more details. If you're a developer, head over here to view the contract guide .","title":"How 2FA Guru works"},{"location":"2fa/contracts/2FAppendix/","text":"Appendix \u00b6 Signature Extraction \u00b6 Data that are sent to TwoFactorBase contracts must strictly adhere to the following format. Calldata Deadline Signature dynamically-sized 32 bytes 65 bytes Transaction data that are in compliance with the above format is then divided into three parts using the formula described below: Deadline = Data [len-97 : len-65] This is the given deadline of a transaction, which reverts at block.timestamp > deadline . Signature = Data [-65] The relayer signature can be simply extracting by slicing out the last 65-bytes of msg.data . Calldata = Data [0 : len-97] The actual calldata is the entire msg.data excluding the last 97-byte. 2FA Message \u00b6 The message is a hash of the encoded structure, as defined by the following: bytes32 hash = keccak256 ( abi . encode ( uint256 chainId , uint256 walletNonce , bytes32 domain_name_hash , uint256 deadline , address primary , address target , bytes data ) ) An honest relayer may only sign this message if and only if the relayer is able to verify that the provided 2FA code from the primary wallet holder is valid.","title":"Appendix"},{"location":"2fa/contracts/2FAppendix/#appendix","text":"","title":"Appendix"},{"location":"2fa/contracts/2FAppendix/#signature-extraction","text":"Data that are sent to TwoFactorBase contracts must strictly adhere to the following format. Calldata Deadline Signature dynamically-sized 32 bytes 65 bytes Transaction data that are in compliance with the above format is then divided into three parts using the formula described below: Deadline = Data [len-97 : len-65] This is the given deadline of a transaction, which reverts at block.timestamp > deadline . Signature = Data [-65] The relayer signature can be simply extracting by slicing out the last 65-bytes of msg.data . Calldata = Data [0 : len-97] The actual calldata is the entire msg.data excluding the last 97-byte.","title":"Signature Extraction"},{"location":"2fa/contracts/2FAppendix/#2fa-message","text":"The message is a hash of the encoded structure, as defined by the following: bytes32 hash = keccak256 ( abi . encode ( uint256 chainId , uint256 walletNonce , bytes32 domain_name_hash , uint256 deadline , address primary , address target , bytes data ) ) An honest relayer may only sign this message if and only if the relayer is able to verify that the provided 2FA code from the primary wallet holder is valid.","title":"2FA Message"},{"location":"2fa/contracts/TwoFactorAuthentication/","text":"TwoFactorAuthentication \u00b6 The Authenticator contract serves as an on-chain storage for 2FA Guru. It stores information about the list of trusted relayer addresses and the binding between primary and recovery wallets. All 2FA contracts are dependent on the Authenticator contract to perform signature verification. The Authenticator simply returns a boolean type data to determine if a signature is generated from one of the approved relayers. getRecoveryWallet \u00b6 function getRecoveryWallet ( address primaryWallet ) external view returns ( address ) Gets the address of a recovery wallet based on the given primary wallet address. getWalletNonce \u00b6 function getWalletNonce ( address primaryWallet ) external view returns ( uint256 ) Gets the transaction count of the primary wallet. validWalletBinding \u00b6 modifier validWalletBinding ( address primaryWallet , address recoveryWallet ) This modifier defines the conditions that both wallets must satisfy to bind with each other. The conditions are: (1) The primary and recovery wallets cannot be the same address (2) The primary wallet can only bind with a recovery wallet once. After a recovery wallet is binded with the primary wallet, this process is not reversible. setRecoveryWallet \u00b6 function setRecoveryWallet ( address recoveryWallet ) external Binds msg.sender with the provided recoveryWallet . This function includes both only2FA and validWalletBinding modifiers. Note: msg.sender is passed as the input to the only2FA modifier. In other words, the primary wallet holder must be the originating caller. This function makes an exception, which delegation is not allowed. setRelayer \u00b6 function setRelayer ( address relayerAccount ) external Adds the given address into a list of vetted relayers. Any signatures signed by relayerAccount will be considered valid after this function is executed. This function requires onlyOwner . removeRelayer \u00b6 function removeRelayer ( address relayerAccount ) external Revokes an existing relayer address from validating 2FAs. Any signatures signed by relayerAddress will no longer be valid after this function is executed. isTrustedRelayer \u00b6 function isTrustedRelayer ( address relayerAccount ) external view returns ( bool ) Checks whether the provided relayerAccount address is a trusted relayer. verifySignature \u00b6 function verifySignature ( uint256 deadline , address primaryWallet , address target , bytes memory data , bytes memory signature ) external returns ( bool ) This function re-constructs and hashes the message to be verified against the provided signature. Returns a boolean value describing whether the provided signature is generated from a trusted relayer. Parameter Type Description deadline uint256 The transaction reverts if block.timestamp > deadline primaryWallet address The primary address that is subjected to the 2FA authentication process target address The contract address where the function executes data bytes The calldata to be executed by the target contract signature bytes The signature generated by a relayer See the Appendix section to learn more about the structure of the message that is signed by the relayer.","title":"TwoFactorAuthentication"},{"location":"2fa/contracts/TwoFactorAuthentication/#twofactorauthentication","text":"The Authenticator contract serves as an on-chain storage for 2FA Guru. It stores information about the list of trusted relayer addresses and the binding between primary and recovery wallets. All 2FA contracts are dependent on the Authenticator contract to perform signature verification. The Authenticator simply returns a boolean type data to determine if a signature is generated from one of the approved relayers.","title":"TwoFactorAuthentication"},{"location":"2fa/contracts/TwoFactorAuthentication/#getrecoverywallet","text":"function getRecoveryWallet ( address primaryWallet ) external view returns ( address ) Gets the address of a recovery wallet based on the given primary wallet address.","title":"getRecoveryWallet"},{"location":"2fa/contracts/TwoFactorAuthentication/#getwalletnonce","text":"function getWalletNonce ( address primaryWallet ) external view returns ( uint256 ) Gets the transaction count of the primary wallet.","title":"getWalletNonce"},{"location":"2fa/contracts/TwoFactorAuthentication/#validwalletbinding","text":"modifier validWalletBinding ( address primaryWallet , address recoveryWallet ) This modifier defines the conditions that both wallets must satisfy to bind with each other. The conditions are: (1) The primary and recovery wallets cannot be the same address (2) The primary wallet can only bind with a recovery wallet once. After a recovery wallet is binded with the primary wallet, this process is not reversible.","title":"validWalletBinding"},{"location":"2fa/contracts/TwoFactorAuthentication/#setrecoverywallet","text":"function setRecoveryWallet ( address recoveryWallet ) external Binds msg.sender with the provided recoveryWallet . This function includes both only2FA and validWalletBinding modifiers. Note: msg.sender is passed as the input to the only2FA modifier. In other words, the primary wallet holder must be the originating caller. This function makes an exception, which delegation is not allowed.","title":"setRecoveryWallet"},{"location":"2fa/contracts/TwoFactorAuthentication/#setrelayer","text":"function setRelayer ( address relayerAccount ) external Adds the given address into a list of vetted relayers. Any signatures signed by relayerAccount will be considered valid after this function is executed. This function requires onlyOwner .","title":"setRelayer"},{"location":"2fa/contracts/TwoFactorAuthentication/#removerelayer","text":"function removeRelayer ( address relayerAccount ) external Revokes an existing relayer address from validating 2FAs. Any signatures signed by relayerAddress will no longer be valid after this function is executed.","title":"removeRelayer"},{"location":"2fa/contracts/TwoFactorAuthentication/#istrustedrelayer","text":"function isTrustedRelayer ( address relayerAccount ) external view returns ( bool ) Checks whether the provided relayerAccount address is a trusted relayer.","title":"isTrustedRelayer"},{"location":"2fa/contracts/TwoFactorAuthentication/#verifysignature","text":"function verifySignature ( uint256 deadline , address primaryWallet , address target , bytes memory data , bytes memory signature ) external returns ( bool ) This function re-constructs and hashes the message to be verified against the provided signature. Returns a boolean value describing whether the provided signature is generated from a trusted relayer. Parameter Type Description deadline uint256 The transaction reverts if block.timestamp > deadline primaryWallet address The primary address that is subjected to the 2FA authentication process target address The contract address where the function executes data bytes The calldata to be executed by the target contract signature bytes The signature generated by a relayer See the Appendix section to learn more about the structure of the message that is signed by the relayer.","title":"verifySignature"},{"location":"2fa/contracts/TwoFactorBase/","text":"TwoFactorBase \u00b6 The base contract is responsible for passing the relayer's signature to be authenticated by the TwoFactorAuthentication contract. The contract then decides to execute or revert a transaction, depending on the data returned by the Authenticator. Constructor \u00b6 constructor ( address _authenticator ) The address of the TwoFactorAuthentication contract is required to be passed onto the constructor, and then stored into the twoFactorAuthenticator variable, which is immutable. enable2FAProtection \u00b6 function enabled2FAProtection () external Sets enabled2FA = true . This method enables 2FA protection for all methods with the only2FA modifier. This method requires onlyOwner . disable2FAProtection \u00b6 function disabled2FAProtection () external Sets enabled2FA = false . Methods with the only2FA modifier are no longer protected. This method requires onlyOwner . enabled2FA \u00b6 function enabled2FA () public view returns ( bool ) Queries the 2FA protection status of the contract. only2FA \u00b6 modifier only2FA ( address primaryWallet ) Even though the modifier requires the input of a primary wallet address, this does not mean the sender necessarily needs to come from the same address as primaryWallet , as long as the embedded signature is generated by a trusted relayer. Prior to sending a transaction to the contract, the relayer signs a message indicating that the primary wallet holder has provided a valid 2FA code. This signature must be appended into msg.data , which is later sliced out by the only2FA modifier to be sent to the Authenticator contract for verification. See the Appendix section to learn more about the signature extraction process. Read more about TwoFactorAuthentication to learn the signature verification process.","title":"TwoFactorBase"},{"location":"2fa/contracts/TwoFactorBase/#twofactorbase","text":"The base contract is responsible for passing the relayer's signature to be authenticated by the TwoFactorAuthentication contract. The contract then decides to execute or revert a transaction, depending on the data returned by the Authenticator.","title":"TwoFactorBase"},{"location":"2fa/contracts/TwoFactorBase/#constructor","text":"constructor ( address _authenticator ) The address of the TwoFactorAuthentication contract is required to be passed onto the constructor, and then stored into the twoFactorAuthenticator variable, which is immutable.","title":"Constructor"},{"location":"2fa/contracts/TwoFactorBase/#enable2faprotection","text":"function enabled2FAProtection () external Sets enabled2FA = true . This method enables 2FA protection for all methods with the only2FA modifier. This method requires onlyOwner .","title":"enable2FAProtection"},{"location":"2fa/contracts/TwoFactorBase/#disable2faprotection","text":"function disabled2FAProtection () external Sets enabled2FA = false . Methods with the only2FA modifier are no longer protected. This method requires onlyOwner .","title":"disable2FAProtection"},{"location":"2fa/contracts/TwoFactorBase/#enabled2fa","text":"function enabled2FA () public view returns ( bool ) Queries the 2FA protection status of the contract.","title":"enabled2FA"},{"location":"2fa/contracts/TwoFactorBase/#only2fa","text":"modifier only2FA ( address primaryWallet ) Even though the modifier requires the input of a primary wallet address, this does not mean the sender necessarily needs to come from the same address as primaryWallet , as long as the embedded signature is generated by a trusted relayer. Prior to sending a transaction to the contract, the relayer signs a message indicating that the primary wallet holder has provided a valid 2FA code. This signature must be appended into msg.data , which is later sliced out by the only2FA modifier to be sent to the Authenticator contract for verification. See the Appendix section to learn more about the signature extraction process. Read more about TwoFactorAuthentication to learn the signature verification process.","title":"only2FA"},{"location":"2fa/contracts/summary/","text":"Summary \u00b6 Smart contracts that benefit from Automata 2FA protection must inherit from the TwoFactorBase contract. Any function calls that require 2FA protection must include the only2FA modifier. 2FA Guru relies on the TwoFactorAuthentication contract to: (1) store the mapping between primary and recovery wallets, and (2) verifies the authenticity of the transaction based on the provided signature from the relayer. The binding between a primary wallet and the recovery wallet is subjected to the usual 2FA workflow, as the Authenticator contract itself also extends the TwoFactorBase contract. After a user has completed the binding process, they can easily query their recovery wallet address by providing their primary wallet address. Read the next section to learn more about the TwoFactorBase contract.","title":"Summary"},{"location":"2fa/contracts/summary/#summary","text":"Smart contracts that benefit from Automata 2FA protection must inherit from the TwoFactorBase contract. Any function calls that require 2FA protection must include the only2FA modifier. 2FA Guru relies on the TwoFactorAuthentication contract to: (1) store the mapping between primary and recovery wallets, and (2) verifies the authenticity of the transaction based on the provided signature from the relayer. The binding between a primary wallet and the recovery wallet is subjected to the usual 2FA workflow, as the Authenticator contract itself also extends the TwoFactorBase contract. After a user has completed the binding process, they can easily query their recovery wallet address by providing their primary wallet address. Read the next section to learn more about the TwoFactorBase contract.","title":"Summary"},{"location":"2fa/developers/faq/","text":"Frequently Asked Questions \u00b6 1. How can I integrate my dApp with the Automata's 2FA protection? \u00b6 You can refer to the smart contract section for more technical details. Do ensure that all asset transfer operation include a only2FA modifier.","title":"FAQs"},{"location":"2fa/developers/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"2fa/developers/faq/#1-how-can-i-integrate-my-dapp-with-the-automatas-2fa-protection","text":"You can refer to the smart contract section for more technical details. Do ensure that all asset transfer operation include a only2FA modifier.","title":"1. How can I integrate my dApp with the Automata's 2FA protection?"},{"location":"2fa/developers/workflow/","text":"Workflow \u00b6 Make your authorised transfer sequenceDiagram autonumber participant PW as Primary wallet participant Client as 2FA client participant DApp as Automata 2FA Guru participant Geode as 2FA Guru Geode participant Contract as Target contract note over PW, DApp: Make authorised transfer PW->>DApp: Attempt to transfer 2FA protected assets DApp-->>PW: Request 2FA code and recipient address PW->>Client: Acquire a valid 2FA code Client-->>PW: 6-digit 2FA code PW->>DApp: Input the valid 2FA code and recipient address DApp->>Geode: Ask for the validation alt note over Geode: Validation succeeded Geode-->>DApp: Return a signature based on the actual transaction DApp-->>PW: Metamask signature PW->>DApp: Make authorised transfer DApp->>Contract: Make authorised transfer else note over Geode: Validation failed Geode-->>DApp: Return a validation error DApp-->>PW: Request declined end Recover your 2FA client sequenceDiagram autonumber participant RW as Recovery Wallet participant Client as 2FA client participant DApp as Automata 2FA Guru participant Geode as 2FA Guru Geode participant Contract as 2FA authentication contract RW->>DApp: Attempt to recover your 2FA client for your primary wallet DApp->>Geode: Ask for the validation Geode->>Contract: Check the binding relationship alt note over Geode: Validation succeeded Geode-->>DApp: Return a new generated secret DApp-->>Client: Scan the QR code to set up Client->>DApp: Input a 6-digit 2FA code DApp->>Geode: Confirm reset alt note over Geode: Validation succeeded Geode->>DApp: Reset succeeded else note over Geode: Validation failed Geode->>DApp: Return a validation error end else note over Geode: Validation failed Geode-->>DApp: Request declined end Key Components \u00b6 Primary wallet: The wallet where users store and control their assets. Recovery wallet: Used for identifying users' roles and resetting the 2FA device. The relationship between the primary wallet and the recovery wallet is saved on-chain after binding. 2FA client: The device which provides the TOTP(Time-based one-time password). Automata 2FA Guru The dApp hosted by the Automata team. It contains the 2FA management and wallet assets control panels. Users can sign up for 2FA and find the 2FA protected dApps in the management panel. They can also make authorised transfers under the wallet assets control panel. 2FA Guru Geode: The 2FA middleware which is built upon the Intel SGX . With the provision of a secure, fully-shielded enclave, the platform connects seamlessly with dApps to provide support for 2FA verification on public blockchains. It's responsible for the 2FA secret generation, storage and authentication. Attackers cannot predict or calculate the valid signature outside the enclave, and its storage is encrypted internally and attackers are unable to view anything even if they managed to steal data. Even though the assets are safe under the 2FA protection, it's still possible for attackers to steal the TOTP by using a phishing attack. To prevent this, we use an anti-phishing feature where our 2FA middleware can analyse the original domain and detect whether it's coming from the phishing domains or links by using daily updated phishing blacklists. If a malicious domain is detected, the geode will not provide a signature to keep users' assets safe. To uphold high security standards, we also support a custom domain whitelist for a specified dApp.","title":"Workflow"},{"location":"2fa/developers/workflow/#workflow","text":"Make your authorised transfer sequenceDiagram autonumber participant PW as Primary wallet participant Client as 2FA client participant DApp as Automata 2FA Guru participant Geode as 2FA Guru Geode participant Contract as Target contract note over PW, DApp: Make authorised transfer PW->>DApp: Attempt to transfer 2FA protected assets DApp-->>PW: Request 2FA code and recipient address PW->>Client: Acquire a valid 2FA code Client-->>PW: 6-digit 2FA code PW->>DApp: Input the valid 2FA code and recipient address DApp->>Geode: Ask for the validation alt note over Geode: Validation succeeded Geode-->>DApp: Return a signature based on the actual transaction DApp-->>PW: Metamask signature PW->>DApp: Make authorised transfer DApp->>Contract: Make authorised transfer else note over Geode: Validation failed Geode-->>DApp: Return a validation error DApp-->>PW: Request declined end Recover your 2FA client sequenceDiagram autonumber participant RW as Recovery Wallet participant Client as 2FA client participant DApp as Automata 2FA Guru participant Geode as 2FA Guru Geode participant Contract as 2FA authentication contract RW->>DApp: Attempt to recover your 2FA client for your primary wallet DApp->>Geode: Ask for the validation Geode->>Contract: Check the binding relationship alt note over Geode: Validation succeeded Geode-->>DApp: Return a new generated secret DApp-->>Client: Scan the QR code to set up Client->>DApp: Input a 6-digit 2FA code DApp->>Geode: Confirm reset alt note over Geode: Validation succeeded Geode->>DApp: Reset succeeded else note over Geode: Validation failed Geode->>DApp: Return a validation error end else note over Geode: Validation failed Geode-->>DApp: Request declined end","title":"Workflow"},{"location":"2fa/developers/workflow/#key-components","text":"Primary wallet: The wallet where users store and control their assets. Recovery wallet: Used for identifying users' roles and resetting the 2FA device. The relationship between the primary wallet and the recovery wallet is saved on-chain after binding. 2FA client: The device which provides the TOTP(Time-based one-time password). Automata 2FA Guru The dApp hosted by the Automata team. It contains the 2FA management and wallet assets control panels. Users can sign up for 2FA and find the 2FA protected dApps in the management panel. They can also make authorised transfers under the wallet assets control panel. 2FA Guru Geode: The 2FA middleware which is built upon the Intel SGX . With the provision of a secure, fully-shielded enclave, the platform connects seamlessly with dApps to provide support for 2FA verification on public blockchains. It's responsible for the 2FA secret generation, storage and authentication. Attackers cannot predict or calculate the valid signature outside the enclave, and its storage is encrypted internally and attackers are unable to view anything even if they managed to steal data. Even though the assets are safe under the 2FA protection, it's still possible for attackers to steal the TOTP by using a phishing attack. To prevent this, we use an anti-phishing feature where our 2FA middleware can analyse the original domain and detect whether it's coming from the phishing domains or links by using daily updated phishing blacklists. If a malicious domain is detected, the geode will not provide a signature to keep users' assets safe. To uphold high security standards, we also support a custom domain whitelist for a specified dApp.","title":"Key Components"},{"location":"2fa/users/faq/","text":"Frequently Asked Questions \u00b6 1. Are the 2FA secrets different for each account? \u00b6 Of course. Each new account has a unique secret, which is replaced if a reset request is confirmed. Even with the same account, secrets are different across networks. 2. How long does it take to bind a recovery wallet? \u00b6 Binding takes place immediately. You will need to bind a recovery wallet within 7 days of signing up with your primary wallet. 3. How long does it take to disable 2FA? \u00b6 Once you have put in your request, there is a cooldown window of 7 days before 2FA is permanently disabled for that particular account. During those 7 days, if you happen to change your mind, simply cancel the request. 4. Can I change my recovery wallet after binding? \u00b6 Unfortunately, no. Binding is permanent, so make sure to keep your recovery wallet safe - for one, don't use it in the same device as your primary wallet so that they are not compromised at the same time. 5. During the setup process, what happens if I scan the QR code without inputting the 6-digit authentication code? \u00b6 2FA will not be successfully enabled for the account, and the authenticated code from its secret will not be authorized. 6. During the reset process, what if I scan the QR code without inputting the 6-digit authentication code? \u00b6 The new secret will not be stored in the 2FA storage. The user's old secret will remain active. 7. Can I use the same recovery wallet for more than one primary wallet? \u00b6 Yes. 8. What kinds of assets will be shown in the wallet assets management page? \u00b6 All 2FA protected assets and Top20 ERC20 tokens in each network. Polygon: https://polygonscan.com/tokens","title":"FAQs"},{"location":"2fa/users/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"2fa/users/faq/#1-are-the-2fa-secrets-different-for-each-account","text":"Of course. Each new account has a unique secret, which is replaced if a reset request is confirmed. Even with the same account, secrets are different across networks.","title":"1. Are the 2FA secrets different for each account?"},{"location":"2fa/users/faq/#2-how-long-does-it-take-to-bind-a-recovery-wallet","text":"Binding takes place immediately. You will need to bind a recovery wallet within 7 days of signing up with your primary wallet.","title":"2. How long does it take to bind a recovery wallet?"},{"location":"2fa/users/faq/#3-how-long-does-it-take-to-disable-2fa","text":"Once you have put in your request, there is a cooldown window of 7 days before 2FA is permanently disabled for that particular account. During those 7 days, if you happen to change your mind, simply cancel the request.","title":"3. How long does it take to disable 2FA?"},{"location":"2fa/users/faq/#4-can-i-change-my-recovery-wallet-after-binding","text":"Unfortunately, no. Binding is permanent, so make sure to keep your recovery wallet safe - for one, don't use it in the same device as your primary wallet so that they are not compromised at the same time.","title":"4. Can I change my recovery wallet after binding?"},{"location":"2fa/users/faq/#5-during-the-setup-process-what-happens-if-i-scan-the-qr-code-without-inputting-the-6-digit-authentication-code","text":"2FA will not be successfully enabled for the account, and the authenticated code from its secret will not be authorized.","title":"5. During the setup process, what happens if I scan the QR code without inputting the 6-digit authentication code?"},{"location":"2fa/users/faq/#6-during-the-reset-process-what-if-i-scan-the-qr-code-without-inputting-the-6-digit-authentication-code","text":"The new secret will not be stored in the 2FA storage. The user's old secret will remain active.","title":"6. During the reset process, what if I scan the QR code without inputting the 6-digit authentication code?"},{"location":"2fa/users/faq/#7-can-i-use-the-same-recovery-wallet-for-more-than-one-primary-wallet","text":"Yes.","title":"7. Can I use the same recovery wallet for more than one primary wallet?"},{"location":"2fa/users/faq/#8-what-kinds-of-assets-will-be-shown-in-the-wallet-assets-management-page","text":"All 2FA protected assets and Top20 ERC20 tokens in each network. Polygon: https://polygonscan.com/tokens","title":"8. What kinds of assets will be shown in the wallet assets management page?"},{"location":"2fa/users/guide/","text":"User Guide \u00b6 Visit Automata 2FA Guru to start your 2FA protection. Setup 2FA \u00b6 Visit Automata 2FA Guru . Use metamask and connect your wallet. If you haven't signed up for an account, you can click the Wallet Actions button at the top to initiate the process of signing up. You will be required to sign a message to prove your identity before generating a 2FA secret. Take note, the primary wallet and 2FA device should be different devices. We support 1Password for storing your 2FA secret. To enable the use of Scan QR Code function in 1Password, you would first have to prepare a Login item in 1Password and configure the basic information. This makes password retrieval more convenient. Recommended configuration in 1Password username wallet address website https://app.2fa.guru tags the target network Once you've successfully signed up, we recommend that you add a recovery wallet for your primary wallet, which can be used to reset your 2FA device. Without a recovery wallet, if you lost your 2FA device, then you can only disable the 2FA protection before you use your 2FA protected assets. For binding a recovery wallet, you would need to send a binding transaction to our 2FA management contract after our authentication, and gas fees would be required. There is a binding window for each account after signup, If you do not bind a recovery wallet in 7 days , you would not be allowed to bind one subsequently. Reset 2FA devices \u00b6 If you lost your 2FA device in an unfortunate incident, you can reset it only if you have a recovery wallet. The reset processes are similar to setting up 2FA for the first time: Visit Automata 2FA Guru . Use metamask and connect your recovery wallet. Click Reset 2FA button in Wallet Actions , input your primary wallet address and sign the message. If the address pair matches, you can scan the new secret to reset the 2FA device. There is no transaction on chain, so no gas fees are required to reset a 2FA device. Take note, the recovery wallet does not need to sign up for 2FA for this to work. Make authorised transfer \u00b6 Once you sign up 2FA for your wallet, your 2FA assets in supported dApps will be protected. If you hold any 2FA protected assets, you will be able to transfer them in Manage my Wallet Assets panel. During the transfer of assets, a 2FA check will be conducted before allowing you to sign a message which would be used in the transfer. Disable 2FA protection \u00b6 If you've lost your 2FA device and no respective recovery wallet has been bound, you always have the option to disable 2FA protection in the 2FA dApp. There is a cooldown period for disabling 2FA protection, and you can cancel the disable 2FA protection request before this period ends. The cooldown period is 7 Days , and after which you would not be able to use 2FA protection anymore. Hence, it's recommended to transfer all your 2FA protected assets to another 2FA protected account after you've disabled the 2FA for a primary wallet. This ensures that all assets will stay protected. Steps to disable 2FA \u00b6 Visit Automata 2FA Guru . Use metamask and connect your wallet. Click Disable 2FA button in Wallet actions , sign the message and wait until the cooldown window ends. Do note, 2FA is still active during this period, and all operations will require authorisation. If you trigger the disable procedure by mistake, you can cancel it during the cooldown window to keep the 2FA protection. Click Cancel Disable 2FA button in Wallet actions , sign the message and this would cancel the request to disable 2FA on the current wallet. You can then continue to use the previous 2FA device with 2FA protection.","title":"User Guide"},{"location":"2fa/users/guide/#user-guide","text":"Visit Automata 2FA Guru to start your 2FA protection.","title":"User Guide"},{"location":"2fa/users/guide/#setup-2fa","text":"Visit Automata 2FA Guru . Use metamask and connect your wallet. If you haven't signed up for an account, you can click the Wallet Actions button at the top to initiate the process of signing up. You will be required to sign a message to prove your identity before generating a 2FA secret. Take note, the primary wallet and 2FA device should be different devices. We support 1Password for storing your 2FA secret. To enable the use of Scan QR Code function in 1Password, you would first have to prepare a Login item in 1Password and configure the basic information. This makes password retrieval more convenient. Recommended configuration in 1Password username wallet address website https://app.2fa.guru tags the target network Once you've successfully signed up, we recommend that you add a recovery wallet for your primary wallet, which can be used to reset your 2FA device. Without a recovery wallet, if you lost your 2FA device, then you can only disable the 2FA protection before you use your 2FA protected assets. For binding a recovery wallet, you would need to send a binding transaction to our 2FA management contract after our authentication, and gas fees would be required. There is a binding window for each account after signup, If you do not bind a recovery wallet in 7 days , you would not be allowed to bind one subsequently.","title":"Setup 2FA"},{"location":"2fa/users/guide/#reset-2fa-devices","text":"If you lost your 2FA device in an unfortunate incident, you can reset it only if you have a recovery wallet. The reset processes are similar to setting up 2FA for the first time: Visit Automata 2FA Guru . Use metamask and connect your recovery wallet. Click Reset 2FA button in Wallet Actions , input your primary wallet address and sign the message. If the address pair matches, you can scan the new secret to reset the 2FA device. There is no transaction on chain, so no gas fees are required to reset a 2FA device. Take note, the recovery wallet does not need to sign up for 2FA for this to work.","title":"Reset 2FA devices"},{"location":"2fa/users/guide/#make-authorised-transfer","text":"Once you sign up 2FA for your wallet, your 2FA assets in supported dApps will be protected. If you hold any 2FA protected assets, you will be able to transfer them in Manage my Wallet Assets panel. During the transfer of assets, a 2FA check will be conducted before allowing you to sign a message which would be used in the transfer.","title":"Make authorised transfer"},{"location":"2fa/users/guide/#disable-2fa-protection","text":"If you've lost your 2FA device and no respective recovery wallet has been bound, you always have the option to disable 2FA protection in the 2FA dApp. There is a cooldown period for disabling 2FA protection, and you can cancel the disable 2FA protection request before this period ends. The cooldown period is 7 Days , and after which you would not be able to use 2FA protection anymore. Hence, it's recommended to transfer all your 2FA protected assets to another 2FA protected account after you've disabled the 2FA for a primary wallet. This ensures that all assets will stay protected.","title":"Disable 2FA protection"},{"location":"2fa/users/guide/#steps-to-disable-2fa","text":"Visit Automata 2FA Guru . Use metamask and connect your wallet. Click Disable 2FA button in Wallet actions , sign the message and wait until the cooldown window ends. Do note, 2FA is still active during this period, and all operations will require authorisation. If you trigger the disable procedure by mistake, you can cancel it during the cooldown window to keep the 2FA protection. Click Cancel Disable 2FA button in Wallet actions , sign the message and this would cancel the request to disable 2FA on the current wallet. You can then continue to use the previous 2FA device with 2FA protection.","title":"Steps to disable 2FA"},{"location":"anydao/design/","text":"Design \u00b6 Architecture \u00b6 The whole system for AnyDAO MVP is composed of 4 major components: Substrate based blockchain : Stores the related metadata and proofs for Projects and Proposals. IPFS : Stores the actual bits of the data such as texts, images and public voter information. Geode : It receives, queries and aggregates user votes. Also monitors the on-chain status and handles the uploading of IPFS storage and on-chain storage. At the same time it ensures the protection of user privacy. Frontend : It gathers all kinds of data and provides information via graphical interface, and provides interactivity for users to register projects, create proposals, cast votes and many more. Concept \u00b6 Project \u00b6 It represents an entity of a DAO, the creator will be the default owner, and the owner has the right to update project configurations and even transfer the ownership to another address. Workspace \u00b6 Each project can configure multiple workspaces, each workspace is composed of a chain and strategies. Strategy \u00b6 It defines how to get the voting power of users from on-chain states, such as calculating by ERC20 token balance and so on. Proposal \u00b6 A proposal stands for a topic where user can vote on with their assets. Snapshot \u00b6 For the fairness of all user voting assets, to avoid double-entrance, a snapshot mechanism is adopted in our design. When a proposal is started, the block height of each involved chain will be taken by our Geode, on which the state of each user will be fetched for power aggregation. Privacy Level \u00b6 There are currently 4 levels of privacy settings: - Public : Details of all individual votes made by users will be made available. - Private : Total amount of votes made per option will be made available as an aggregation while the individual vote is hidden. - Mixed : Users have the option to choose to reveal their vote or to cast their vote in the form of an aggregated result. - Opaque : Only the result of the vote is revealed, all other details are hidden, including aggregated vote amount. Update Frequency \u00b6 It stands for how often Geode will execute transaction to update the on-chain states. The total number of updates for a proposal is calculated by the total voting duration divided by update frequency. As each execution generates transaction fee, the proposal creator need to pay certain amount of token according to the number of updating. If the update frequency is not enabled, Geode will only update the IPFS and on-chain state for once when the proposal is ended.","title":"Design"},{"location":"anydao/design/#design","text":"","title":"Design"},{"location":"anydao/design/#architecture","text":"The whole system for AnyDAO MVP is composed of 4 major components: Substrate based blockchain : Stores the related metadata and proofs for Projects and Proposals. IPFS : Stores the actual bits of the data such as texts, images and public voter information. Geode : It receives, queries and aggregates user votes. Also monitors the on-chain status and handles the uploading of IPFS storage and on-chain storage. At the same time it ensures the protection of user privacy. Frontend : It gathers all kinds of data and provides information via graphical interface, and provides interactivity for users to register projects, create proposals, cast votes and many more.","title":"Architecture"},{"location":"anydao/design/#concept","text":"","title":"Concept"},{"location":"anydao/design/#project","text":"It represents an entity of a DAO, the creator will be the default owner, and the owner has the right to update project configurations and even transfer the ownership to another address.","title":"Project"},{"location":"anydao/design/#workspace","text":"Each project can configure multiple workspaces, each workspace is composed of a chain and strategies.","title":"Workspace"},{"location":"anydao/design/#strategy","text":"It defines how to get the voting power of users from on-chain states, such as calculating by ERC20 token balance and so on.","title":"Strategy"},{"location":"anydao/design/#proposal","text":"A proposal stands for a topic where user can vote on with their assets.","title":"Proposal"},{"location":"anydao/design/#snapshot","text":"For the fairness of all user voting assets, to avoid double-entrance, a snapshot mechanism is adopted in our design. When a proposal is started, the block height of each involved chain will be taken by our Geode, on which the state of each user will be fetched for power aggregation.","title":"Snapshot"},{"location":"anydao/design/#privacy-level","text":"There are currently 4 levels of privacy settings: - Public : Details of all individual votes made by users will be made available. - Private : Total amount of votes made per option will be made available as an aggregation while the individual vote is hidden. - Mixed : Users have the option to choose to reveal their vote or to cast their vote in the form of an aggregated result. - Opaque : Only the result of the vote is revealed, all other details are hidden, including aggregated vote amount.","title":"Privacy Level"},{"location":"anydao/design/#update-frequency","text":"It stands for how often Geode will execute transaction to update the on-chain states. The total number of updates for a proposal is calculated by the total voting duration divided by update frequency. As each execution generates transaction fee, the proposal creator need to pay certain amount of token according to the number of updating. If the update frequency is not enabled, Geode will only update the IPFS and on-chain state for once when the proposal is ended.","title":"Update Frequency"},{"location":"anydao/guide/","text":"User Guide \u00b6 Claim Testing Token \u00b6 Assume you have set up your wallet account, if not, please refer to here Head to the Automata Faucet , you may need to login via Twitter account to get access to the faucet page. Choose ContextFree under the Network drop-down field Input your ContextFree wallet address and submit, 10 CTX native token will be sent to your account, can check on our Blockchain Dashboard . Interface Layout \u00b6 Now let's explore our AnyDAO frontend The left panel are the directory, the right panel shows the contents. Currently you can see all the projects registered on AnyDAO Connect Wallet \u00b6 The connect button is located at the bottom of the left panel. If you want to disconnect, click on your connected wallet and you can find the disconnect button there Currently you have to connect with a PolkadotJS wallet to proceed to the following operations: Register Project , Update Project , and Create Proposal . Create Project \u00b6 Once you have connected with a wallet with a corresponding contextfree account, you will see another entry Project Management appears at your left panel. Make sure you are connected with a Polkadot Extension Wallet. Go to Project Management , then Add a new project Fill in your Project title, description Upload your project icon, banner Then add workspaces for your project, choose the chain you want to add Attach available strategy to it, such as You should be able to see like this if everything set up Press Submit new project and follow the wallet instructions to submit the transaction. Ensure your wallet has enough tokens to pay for the transaction fee. If you see this it means you succeeded. You can check your created project Update Project \u00b6 Upon successfully created your project, you should be able to see your project in Project Management page Go into your created project, you should be able to see your previous configuration for your project. Change any of the fields you wish to, and click Save project settings , follow the wallet instructions and submit the transaction. Create Proposal \u00b6 Go to any project, you should see the detail page. Click New Proposal Fill in the title, description as you want for the proposal Then click Define proposal configurations to configure your proposal. Here you can see more details of Privacy level Here you can see more details of Voting Type Starting date & Ending data: the actual timing you want to start and end your proposal voting period. Here you can see more details of Time Restriction Here you can see more details of Update Frequency Click Publish my proposal and follow the instructions to submit your transaction. You should be able to see your proposal once it's successfully created. Vote \u00b6 Go to any on-going proposal or the one you just created. Check the detail about the proposal, make sure what are you voting with :D For proposal with privacy level Mixed , you can toggle the Vote Privacy to choose whether vote publicly or anonymously if you choose to vote publicly, details of your vote will be made available, such as: if you choose to vote anonymously, your details won't be revealed to anyone. Click on the option you want to cast your vote. The voting only requires the signature from your wallet, no fee will be charged for voting. You can use either Metamask wallet or Polkadot Extension Wallet according to the project workspace configuration. Here is an example of a closed proposal, it's the time to try your own, cheers! \ud83d\ude4c","title":"User Guide"},{"location":"anydao/guide/#user-guide","text":"","title":"User Guide"},{"location":"anydao/guide/#claim-testing-token","text":"Assume you have set up your wallet account, if not, please refer to here Head to the Automata Faucet , you may need to login via Twitter account to get access to the faucet page. Choose ContextFree under the Network drop-down field Input your ContextFree wallet address and submit, 10 CTX native token will be sent to your account, can check on our Blockchain Dashboard .","title":"Claim Testing Token"},{"location":"anydao/guide/#interface-layout","text":"Now let's explore our AnyDAO frontend The left panel are the directory, the right panel shows the contents. Currently you can see all the projects registered on AnyDAO","title":"Interface Layout"},{"location":"anydao/guide/#connect-wallet","text":"The connect button is located at the bottom of the left panel. If you want to disconnect, click on your connected wallet and you can find the disconnect button there Currently you have to connect with a PolkadotJS wallet to proceed to the following operations: Register Project , Update Project , and Create Proposal .","title":"Connect Wallet"},{"location":"anydao/guide/#create-project","text":"Once you have connected with a wallet with a corresponding contextfree account, you will see another entry Project Management appears at your left panel. Make sure you are connected with a Polkadot Extension Wallet. Go to Project Management , then Add a new project Fill in your Project title, description Upload your project icon, banner Then add workspaces for your project, choose the chain you want to add Attach available strategy to it, such as You should be able to see like this if everything set up Press Submit new project and follow the wallet instructions to submit the transaction. Ensure your wallet has enough tokens to pay for the transaction fee. If you see this it means you succeeded. You can check your created project","title":"Create Project"},{"location":"anydao/guide/#update-project","text":"Upon successfully created your project, you should be able to see your project in Project Management page Go into your created project, you should be able to see your previous configuration for your project. Change any of the fields you wish to, and click Save project settings , follow the wallet instructions and submit the transaction.","title":"Update Project"},{"location":"anydao/guide/#create-proposal","text":"Go to any project, you should see the detail page. Click New Proposal Fill in the title, description as you want for the proposal Then click Define proposal configurations to configure your proposal. Here you can see more details of Privacy level Here you can see more details of Voting Type Starting date & Ending data: the actual timing you want to start and end your proposal voting period. Here you can see more details of Time Restriction Here you can see more details of Update Frequency Click Publish my proposal and follow the instructions to submit your transaction. You should be able to see your proposal once it's successfully created.","title":"Create Proposal"},{"location":"anydao/guide/#vote","text":"Go to any on-going proposal or the one you just created. Check the detail about the proposal, make sure what are you voting with :D For proposal with privacy level Mixed , you can toggle the Vote Privacy to choose whether vote publicly or anonymously if you choose to vote publicly, details of your vote will be made available, such as: if you choose to vote anonymously, your details won't be revealed to anyone. Click on the option you want to cast your vote. The voting only requires the signature from your wallet, no fee will be charged for voting. You can use either Metamask wallet or Polkadot Extension Wallet according to the project workspace configuration. Here is an example of a closed proposal, it's the time to try your own, cheers! \ud83d\ude4c","title":"Vote"},{"location":"anydao/introduction/","text":"Introduction \u00b6 Voting is one of the most important components for DAO. Currently there are two major approaches: off-chain signalling and on-chain governance. Due to the sensitivity and indeterminate design of on-chain infrastructure for different project, there is no an easy approach to have a universal pattern to apply to most of the cases and it requires abundant knowledge and thorough understanding to practice on-chain governance, currently there are very few teams have the ability to adopt it. Thus off-chain signalling is still the major approach for DAO to involve the community to make decisions. However for off-chain signalling voting, there are also several major problems faced: Island of Voting Power: Nowadays most of WEB3.0 projects locate their assets across different chains, usually users have to bridge their assets to a specific chain designated by the project team to have the right to vote. It causes unnecessary waste for the intermediate transactions and can even cause a liquidity crisis. Privacy Concern: Anonymous voting will greatly promote users' motivation to get involved in the voting. But due to the nature of traceability of blockchain networks, it is always a challenge to achieve true anonymity. AnyDAO is an off-chain voting signalling platform built by Automata Network aiming to solve the above challenges. Currently it already supports the following major features: Boarderless Governance : Vote aggregation across any EVM or Substrate-based blockchain networks Zero-cost voting : User-friendly process Multi-tier privacy : Adjustable privacy levels Flexible parameters : Choose from different token standards, such as with ERC20s, NFTs, LP tokens or Native Substrate Account Balances.","title":"Introduction"},{"location":"anydao/introduction/#introduction","text":"Voting is one of the most important components for DAO. Currently there are two major approaches: off-chain signalling and on-chain governance. Due to the sensitivity and indeterminate design of on-chain infrastructure for different project, there is no an easy approach to have a universal pattern to apply to most of the cases and it requires abundant knowledge and thorough understanding to practice on-chain governance, currently there are very few teams have the ability to adopt it. Thus off-chain signalling is still the major approach for DAO to involve the community to make decisions. However for off-chain signalling voting, there are also several major problems faced: Island of Voting Power: Nowadays most of WEB3.0 projects locate their assets across different chains, usually users have to bridge their assets to a specific chain designated by the project team to have the right to vote. It causes unnecessary waste for the intermediate transactions and can even cause a liquidity crisis. Privacy Concern: Anonymous voting will greatly promote users' motivation to get involved in the voting. But due to the nature of traceability of blockchain networks, it is always a challenge to achieve true anonymity. AnyDAO is an off-chain voting signalling platform built by Automata Network aiming to solve the above challenges. Currently it already supports the following major features: Boarderless Governance : Vote aggregation across any EVM or Substrate-based blockchain networks Zero-cost voting : User-friendly process Multi-tier privacy : Adjustable privacy levels Flexible parameters : Choose from different token standards, such as with ERC20s, NFTs, LP tokens or Native Substrate Account Balances.","title":"Introduction"},{"location":"anydao/spec/","text":"Specifications \u00b6 Production \u00b6 Frontend \u00b6 https://the.anydao.app/ Currently supports wallet connection with Metamask and Polkadot Extension Faucet \u00b6 https://faucet.ata.network Blockchain \u00b6 Explorer \u00b6 ContextFree Dashboard Endpoints \u00b6 https://cf-rpc.ata.network Configurations \u00b6 Minimum voting period: 1 hour Maximum voting period: 30 days Maximum option count: 10 Maximum workspace number: 10 Maximum strategy number: 10 Supported Chains \u00b6 Platform Protocol Automata Mainnet Substrate ContextFree Canary Network Substrate FiniteState Testnet Substrate Ethereum Mainnet EVM Ropsten Testnet EVM Kovan Testnet EVM BSC Mainnet EVM BSC Testnet EVM Polygon Mainnet EVM Polygon Testnet EVM HECO Mainnet EVM HECO Testnet EVM Moonbase Alpha Testnet EVM Avalanche Testnet EVM Avalanche Mainnet EVM Strategies \u00b6 EVM \u00b6 Name Parameter Description ERC20Balance Contract Address Take BalanceOf as voting power Substrate \u00b6 Name Parameter Description NativeBalance - Take System/Account and the Free balance as voting power Voting Type \u00b6 Name Parameter Description SingleChoice - User can vote on only one option","title":"Specification"},{"location":"anydao/spec/#specifications","text":"","title":"Specifications"},{"location":"anydao/spec/#production","text":"","title":"Production"},{"location":"anydao/spec/#frontend","text":"https://the.anydao.app/ Currently supports wallet connection with Metamask and Polkadot Extension","title":"Frontend"},{"location":"anydao/spec/#faucet","text":"https://faucet.ata.network","title":"Faucet"},{"location":"anydao/spec/#blockchain","text":"","title":"Blockchain"},{"location":"anydao/spec/#explorer","text":"ContextFree Dashboard","title":"Explorer"},{"location":"anydao/spec/#endpoints","text":"https://cf-rpc.ata.network","title":"Endpoints"},{"location":"anydao/spec/#configurations","text":"Minimum voting period: 1 hour Maximum voting period: 30 days Maximum option count: 10 Maximum workspace number: 10 Maximum strategy number: 10","title":"Configurations"},{"location":"anydao/spec/#supported-chains","text":"Platform Protocol Automata Mainnet Substrate ContextFree Canary Network Substrate FiniteState Testnet Substrate Ethereum Mainnet EVM Ropsten Testnet EVM Kovan Testnet EVM BSC Mainnet EVM BSC Testnet EVM Polygon Mainnet EVM Polygon Testnet EVM HECO Mainnet EVM HECO Testnet EVM Moonbase Alpha Testnet EVM Avalanche Testnet EVM Avalanche Mainnet EVM","title":"Supported Chains"},{"location":"anydao/spec/#strategies","text":"","title":"Strategies"},{"location":"anydao/spec/#evm","text":"Name Parameter Description ERC20Balance Contract Address Take BalanceOf as voting power","title":"EVM"},{"location":"anydao/spec/#substrate","text":"Name Parameter Description NativeBalance - Take System/Account and the Free balance as voting power","title":"Substrate"},{"location":"anydao/spec/#voting-type","text":"Name Parameter Description SingleChoice - User can vote on only one option","title":"Voting Type"},{"location":"canarynet/getstarted/introduction/","text":"ContextFree Network \u00b6 ContextFree is the Canary Network of Automata\u2019s Mainnet, and this is an important milestone in realizing the technological vision of a privacy middleware platform built for Web 3.0. The launch of ContextFree provides a pre-production environment for real-life learnings to be applied to the eventual rollout of the Mainnet. During this time, users are invited to battle-test the code. Features are rolled out in phases to ensure the stability and security of the blockchain. This documentation homepage offers the necessary resources to learn about ContextFree, guides and tools to contribute to the Canary Network, either as a user looking to explore the blockchain, or to participate by running a node. Here are some background information to get you started: Network Parameters \u00b6 Basic \u00b6 Config Parameter Expected block time 6 seconds Epoch duration 4 hours Era duration 24 hours Account prefix 11820 Tokens \u00b6 CTX are ContextFree tokens, and do not have any monetary value. Users can request for free CTX tokens by heading over to our faucet . The initial circulation amount of CTX is set at 1 billion, and will be minted on demand. Roadmap \u00b6 ContextFree launch progress mimics and follows the Roadmap , with faster iteration. All upgrades will be recorded in this documentation. Features \u00b6 2021-09-30 Initial launch ContextFree was launched on September 30, 2021, in Proof of Authority mode. All nodes are held by the Automata team, with most functionalities disabled. 2021-10-09 Token Economics Features related to Transfer, Staking and Token Bridge have been enabled on October 9, 2021. 2021-10-12 NPoS Nominated Proof of Stake has been enabled on October 12, 2021, and public validators will be able to join the network. Resources \u00b6 Name Value Dashboard https://dashboard.ata.network HTTP RPC Endpoint https://cf-rpc.ata.network Websockets RPC Endpoint wss://cf-api.ata.network","title":"Introduction"},{"location":"canarynet/getstarted/introduction/#contextfree-network","text":"ContextFree is the Canary Network of Automata\u2019s Mainnet, and this is an important milestone in realizing the technological vision of a privacy middleware platform built for Web 3.0. The launch of ContextFree provides a pre-production environment for real-life learnings to be applied to the eventual rollout of the Mainnet. During this time, users are invited to battle-test the code. Features are rolled out in phases to ensure the stability and security of the blockchain. This documentation homepage offers the necessary resources to learn about ContextFree, guides and tools to contribute to the Canary Network, either as a user looking to explore the blockchain, or to participate by running a node. Here are some background information to get you started:","title":"ContextFree Network"},{"location":"canarynet/getstarted/introduction/#network-parameters","text":"","title":"Network Parameters"},{"location":"canarynet/getstarted/introduction/#basic","text":"Config Parameter Expected block time 6 seconds Epoch duration 4 hours Era duration 24 hours Account prefix 11820","title":"Basic"},{"location":"canarynet/getstarted/introduction/#tokens","text":"CTX are ContextFree tokens, and do not have any monetary value. Users can request for free CTX tokens by heading over to our faucet . The initial circulation amount of CTX is set at 1 billion, and will be minted on demand.","title":"Tokens"},{"location":"canarynet/getstarted/introduction/#roadmap","text":"ContextFree launch progress mimics and follows the Roadmap , with faster iteration. All upgrades will be recorded in this documentation.","title":"Roadmap"},{"location":"canarynet/getstarted/introduction/#features","text":"2021-09-30 Initial launch ContextFree was launched on September 30, 2021, in Proof of Authority mode. All nodes are held by the Automata team, with most functionalities disabled. 2021-10-09 Token Economics Features related to Transfer, Staking and Token Bridge have been enabled on October 9, 2021. 2021-10-12 NPoS Nominated Proof of Stake has been enabled on October 12, 2021, and public validators will be able to join the network.","title":"Features"},{"location":"canarynet/getstarted/introduction/#resources","text":"Name Value Dashboard https://dashboard.ata.network HTTP RPC Endpoint https://cf-rpc.ata.network Websockets RPC Endpoint wss://cf-api.ata.network","title":"Resources"},{"location":"canarynet/node/node-type/","text":"Type of Nodes \u00b6 Before an introduction to the distinct type of nodes, it is important to understand a few concepts: * Genesis block: defined by a chain spec file, which describes the initial status of a chain, including the initial wasm, balances, authority set and so on. * Extrinsics: a piece of information that comes from outside the chain and is included in a block, which will change the state of chain. * Events: a piece of information comes from inside the chain, which may trigger some operation and change the state of chain. The chain starts from a initial state, and updated by Extrinsics or Events . Assume the current block height is N, a validator will takes the chain state at block N and apply changes on top of it, to construct the block N+1. Archive node \u00b6 Archive Nodes keeps all the historical state in storage. So it is convenient to use a archive node to query the state of a certain block height. For example, you can get the balance of Alice at block 20, or get the validator number at block 1024. As a result, running a archive node needs more disk space. Generally, archive nodes are used when you need to know the past states. Full node \u00b6 Full nodes keeps states of genesis block and serveral recently blocks in storage. By default, blocks which is older than 256 from the latest finalized block will be discarded. Besides, full node keeps extrinsics for all past blocks, so it can rebuild the chain without additional information. Full nodes need less disk space than archive node and is used when you just want to read the recently state of chain, submit or validate extrinsics. For running full node or archive node, please refer here . Light node \u00b6 Light nodes has only the runtime and current state, does not keep any of the historical state or extrinsics. Light nodes are useful for resource limited devices. Validator \u00b6 Validator is a special kind of archive node. Like archive nodes, validators keep all the historical state in storage. More importantly, validators are participants of the chain, which are responsible for validate blocks, voting for finality and so on. Validators will be rewarded for maintaining the chain and slashed for misbehavior. For running validator node, please refer here .","title":"Node Types"},{"location":"canarynet/node/node-type/#type-of-nodes","text":"Before an introduction to the distinct type of nodes, it is important to understand a few concepts: * Genesis block: defined by a chain spec file, which describes the initial status of a chain, including the initial wasm, balances, authority set and so on. * Extrinsics: a piece of information that comes from outside the chain and is included in a block, which will change the state of chain. * Events: a piece of information comes from inside the chain, which may trigger some operation and change the state of chain. The chain starts from a initial state, and updated by Extrinsics or Events . Assume the current block height is N, a validator will takes the chain state at block N and apply changes on top of it, to construct the block N+1.","title":"Type of Nodes"},{"location":"canarynet/node/node-type/#archive-node","text":"Archive Nodes keeps all the historical state in storage. So it is convenient to use a archive node to query the state of a certain block height. For example, you can get the balance of Alice at block 20, or get the validator number at block 1024. As a result, running a archive node needs more disk space. Generally, archive nodes are used when you need to know the past states.","title":"Archive node"},{"location":"canarynet/node/node-type/#full-node","text":"Full nodes keeps states of genesis block and serveral recently blocks in storage. By default, blocks which is older than 256 from the latest finalized block will be discarded. Besides, full node keeps extrinsics for all past blocks, so it can rebuild the chain without additional information. Full nodes need less disk space than archive node and is used when you just want to read the recently state of chain, submit or validate extrinsics. For running full node or archive node, please refer here .","title":"Full node"},{"location":"canarynet/node/node-type/#light-node","text":"Light nodes has only the runtime and current state, does not keep any of the historical state or extrinsics. Light nodes are useful for resource limited devices.","title":"Light node"},{"location":"canarynet/node/node-type/#validator","text":"Validator is a special kind of archive node. Like archive nodes, validators keep all the historical state in storage. More importantly, validators are participants of the chain, which are responsible for validate blocks, voting for finality and so on. Validators will be rewarded for maintaining the chain and slashed for misbehavior. For running validator node, please refer here .","title":"Validator"},{"location":"canarynet/node/run-full-node/","text":"Run Full Node \u00b6 Introduction \u00b6 According to description in Type of Nodes , you can run Full Node, Archive Node or Validator Node on ContextFree Network. In this section, we briefly introduce how to run Full Node or Archive Node For running Validator Node , please refer to the next section . Preparation \u00b6 Dependencies \u00b6 Install Docker Please go to this link to download the docker engine for your Operating System accordingly. Create a Local Directory To Store the Chain Data \u00b6 You may need sudo permission to run the following commands. Firstly create a folder to store the synchronized on-chain data mkdir /chain Change the ownership and permission of your local storage directory to current user sudo chown -R $(id -u):$(id -g) /chain Launch Node \u00b6 Launch Full Node \u00b6 Run the following command to launch a Full Node, you may need sudo permission: docker run -it \\ -v \"/chain:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -d \\ atactr/automata:contextfree-v0.1.0-rc4 \\ --node-type full \\ --name <YOUR_NODE_NAME> Which will return the c_ontainer ID of your node <YOUR_NODE_NAME> can be anything, but it's recommended to have something unique to make it easier to identify your node. Launch Archive Node \u00b6 Run the following command to launch a Archive Node, you may need sudo permission: docker run -it \\ -v \"/chain:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -d \\ atactr/automata:contextfree-v0.1.0-rc4 \\ --node-type archive \\ --name <YOUR_NODE_NAME> Which will return the container ID of your node <YOUR_NODE_NAME> can be anything, but it's recommended to have something unique to make it easier to identify your node. Check Launch Status \u00b6 Check whether your node downloading blocks by checking the logs docker logs --follow <YOUR_CONTAINER_ID> If it works fine, the beginning of the log should look like Take note of your node identity behind \"Local node identity is: ...\" . This will be very important for identifying your node on the Telemetry, as the node name can be duplicated. Notice that you should have a non-zero number of \"peers\" connected as shown in the image above. If the logs saying \"Error while dialing /dns/...\" , don't be panic, normally it may take a few minutes for the node to connect to the Telemetry server, after that the error will stop popping up.","title":"Run Full Node"},{"location":"canarynet/node/run-full-node/#run-full-node","text":"","title":"Run Full Node"},{"location":"canarynet/node/run-full-node/#introduction","text":"According to description in Type of Nodes , you can run Full Node, Archive Node or Validator Node on ContextFree Network. In this section, we briefly introduce how to run Full Node or Archive Node For running Validator Node , please refer to the next section .","title":"Introduction"},{"location":"canarynet/node/run-full-node/#preparation","text":"","title":"Preparation"},{"location":"canarynet/node/run-full-node/#dependencies","text":"Install Docker Please go to this link to download the docker engine for your Operating System accordingly.","title":"Dependencies"},{"location":"canarynet/node/run-full-node/#create-a-local-directory-to-store-the-chain-data","text":"You may need sudo permission to run the following commands. Firstly create a folder to store the synchronized on-chain data mkdir /chain Change the ownership and permission of your local storage directory to current user sudo chown -R $(id -u):$(id -g) /chain","title":"Create a Local Directory To Store the Chain Data"},{"location":"canarynet/node/run-full-node/#launch-node","text":"","title":"Launch Node"},{"location":"canarynet/node/run-full-node/#launch-full-node","text":"Run the following command to launch a Full Node, you may need sudo permission: docker run -it \\ -v \"/chain:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -d \\ atactr/automata:contextfree-v0.1.0-rc4 \\ --node-type full \\ --name <YOUR_NODE_NAME> Which will return the c_ontainer ID of your node <YOUR_NODE_NAME> can be anything, but it's recommended to have something unique to make it easier to identify your node.","title":"Launch Full Node"},{"location":"canarynet/node/run-full-node/#launch-archive-node","text":"Run the following command to launch a Archive Node, you may need sudo permission: docker run -it \\ -v \"/chain:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -d \\ atactr/automata:contextfree-v0.1.0-rc4 \\ --node-type archive \\ --name <YOUR_NODE_NAME> Which will return the container ID of your node <YOUR_NODE_NAME> can be anything, but it's recommended to have something unique to make it easier to identify your node.","title":"Launch Archive Node"},{"location":"canarynet/node/run-full-node/#check-launch-status","text":"Check whether your node downloading blocks by checking the logs docker logs --follow <YOUR_CONTAINER_ID> If it works fine, the beginning of the log should look like Take note of your node identity behind \"Local node identity is: ...\" . This will be very important for identifying your node on the Telemetry, as the node name can be duplicated. Notice that you should have a non-zero number of \"peers\" connected as shown in the image above. If the logs saying \"Error while dialing /dns/...\" , don't be panic, normally it may take a few minutes for the node to connect to the Telemetry server, after that the error will stop popping up.","title":"Check Launch Status"},{"location":"canarynet/node/run-validator/","text":"Run A Validator \u00b6 Introduction \u00b6 You may want to run a validator, which means if you are elected into the validator set, you will be able to earn rewards. To run a validator, you need to run a validator node and stake some tokens, we will show you how to do it step by step. Steps \u00b6 Install Dependencies \u00b6 Install Docker Please go to this link to download the docker engine for your Operating System accordingly. Create a Local Directory To Store the Chain Data \u00b6 You may need sudo permission to run the following commands. Firstly create a folder to store the synchronized on-chain data mkdir /chain Change the ownership and permission of your local storage directory to current user sudo chown -R $(id -u):$(id -g) /chain Launch the Validator Node \u00b6 Run the following command to launch a validator node, you may need sudo permission: docker run -it \\ -v \"/chain:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -d \\ atactr/automata:contextfree-v0.1.0-rc4 \\ --node-type validator \\ --name <YOUR_NODE_NAME> Which will return the container ID of your node <YOUR_NODE_NAME> can be anything, but it's recommended to have something unique to make it easier to identify your node. Check Launch Status \u00b6 Check whether your node downloading blocks by checking the logs docker logs --follow <YOUR_CONTAINER_ID> If it works fine, the beginning of the log should look like Take note of your node identity behind \"Local node identity is: ...\" . This will be very important for identifying your node on the Telemetry, as the node name can be duplicated. Notice that you should have a non-zero number of \"peers\" connected as shown in the image above. If the logs saying \"Error while dialing /dns/...\" , don't be panic, normally it may take a few minutes for the node to connect to the Telemetry server, after that the error will stop popping up. Get Session Keys Of Your Node \u00b6 Run the following command Install curl in your docker container: docker exec -t -u root <YOUR_CONTAINER_ID> bash -c 'apt-get update | apt-get -y install curl' Fetch Session Keys from your container: docker exec -t <YOUR_CONTAINER_ID> curl http://127.0.0.1:9933 -H \"Content-Type:application/json;charset=utf-8\" -d '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"author_rotateKeys\", \"params\": [] }' You will get a response like this { \"jsonrpc\": \"2.0\", \"result\":\"0xc05a9d093e4db4c1bde31977716e7a0a39d6f3d1f1bf749e7fec8371147de730af6860aeef81a11130c9fcd317b96e736f6c36141c28f382a18f9faf6e7df797eaa951ead00d12db10937003f0956e3d3444d1774d452ed045dbc1b84d1bf1471abf5d77bf5033845f01be1188a852c6f0ba703042b4d06d14314841c1096c50\", \"id\":1 } The content after \"result\" is the session keys of your validator node Set Up Accounts \u00b6 For running a validator, you need to set up two accounts: Stash account : This account holds funds bonded for staking, but delegates some functions to the Controller account. It can be kept in a cold wallet, meaning it can stays offline all the time. Controller account : This account acts on behalf of the Stash account, signalling decisions and necessary execution for staking. It only needs enough funds to pay transaction fees. For more details, refer to Polkadot Keys . For how to create accounts in ContextFree, you can refer here . Get Token \u00b6 Your Stash account and Controller account need to be funded with some native token If you already had some native token on other account, you can simply transfer to the stash and controller accounts you have created, using the dashboard by opening the Transfer page under the Accounts tab. If you don't have any native token, visit Get Token from Faucet to get some native token. Alternatively, if you have some ContextFree ERC20 token , you can follow the Token Bridge user guide to convert it into native token. Stake Tokens \u00b6 Visit the Automata Dashboard Go to the Staking section. Set Stash and Controller. Choose the stash account and controller account accordingly, set the value for staking and press Bond to submit the transaction. Set Session Keys \u00b6 Click Session Keys and set the session keys you got previously. If you are nominating someone, you need to stop nominating or you will not be able to set session keys. Set Validate Parameters \u00b6 Click Validate Set the value of reward commission percentage , which is the rate that your validator will be commissioned with. The remaining rewards will be split among your nominators. Besides, you can choose to accept nominating or not. Joining Validator Set \u00b6 If you go to the \"Staking\" tab, you will see a list of active validators currently running on the network. At the top of the page, it shows the number of validator slots that are available as well as the number of nodes that have signaled their intention to be a validator. You can go to the \"Waiting\" tab to double check to see whether your node is listed there. The validator set is refreshed every era. In the next era, if there is a slot available and your node is selected to join the validator set, your node will become an active validator. Until then, it will remain in the waiting queue. If your validator is not selected to become part of the validator set, it will remain in the waiting queue until it is. There is no need to re-start if you are not selected for the validator set in a particular era. However, it may be necessary to increase the number of native token staked or seek out nominators for your validator in order to join the validator set. Congratuation \u00b6 If you have followed all of these steps, and been selected to be a part of the validator set, you are now running a ContextFree validator!","title":"Join as Validator"},{"location":"canarynet/node/run-validator/#run-a-validator","text":"","title":"Run A Validator"},{"location":"canarynet/node/run-validator/#introduction","text":"You may want to run a validator, which means if you are elected into the validator set, you will be able to earn rewards. To run a validator, you need to run a validator node and stake some tokens, we will show you how to do it step by step.","title":"Introduction"},{"location":"canarynet/node/run-validator/#steps","text":"","title":"Steps"},{"location":"canarynet/node/run-validator/#install-dependencies","text":"Install Docker Please go to this link to download the docker engine for your Operating System accordingly.","title":"Install Dependencies"},{"location":"canarynet/node/run-validator/#create-a-local-directory-to-store-the-chain-data","text":"You may need sudo permission to run the following commands. Firstly create a folder to store the synchronized on-chain data mkdir /chain Change the ownership and permission of your local storage directory to current user sudo chown -R $(id -u):$(id -g) /chain","title":"Create a Local Directory To Store the Chain Data"},{"location":"canarynet/node/run-validator/#launch-the-validator-node","text":"Run the following command to launch a validator node, you may need sudo permission: docker run -it \\ -v \"/chain:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -d \\ atactr/automata:contextfree-v0.1.0-rc4 \\ --node-type validator \\ --name <YOUR_NODE_NAME> Which will return the container ID of your node <YOUR_NODE_NAME> can be anything, but it's recommended to have something unique to make it easier to identify your node.","title":"Launch the Validator Node"},{"location":"canarynet/node/run-validator/#check-launch-status","text":"Check whether your node downloading blocks by checking the logs docker logs --follow <YOUR_CONTAINER_ID> If it works fine, the beginning of the log should look like Take note of your node identity behind \"Local node identity is: ...\" . This will be very important for identifying your node on the Telemetry, as the node name can be duplicated. Notice that you should have a non-zero number of \"peers\" connected as shown in the image above. If the logs saying \"Error while dialing /dns/...\" , don't be panic, normally it may take a few minutes for the node to connect to the Telemetry server, after that the error will stop popping up.","title":"Check Launch Status"},{"location":"canarynet/node/run-validator/#get-session-keys-of-your-node","text":"Run the following command Install curl in your docker container: docker exec -t -u root <YOUR_CONTAINER_ID> bash -c 'apt-get update | apt-get -y install curl' Fetch Session Keys from your container: docker exec -t <YOUR_CONTAINER_ID> curl http://127.0.0.1:9933 -H \"Content-Type:application/json;charset=utf-8\" -d '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"author_rotateKeys\", \"params\": [] }' You will get a response like this { \"jsonrpc\": \"2.0\", \"result\":\"0xc05a9d093e4db4c1bde31977716e7a0a39d6f3d1f1bf749e7fec8371147de730af6860aeef81a11130c9fcd317b96e736f6c36141c28f382a18f9faf6e7df797eaa951ead00d12db10937003f0956e3d3444d1774d452ed045dbc1b84d1bf1471abf5d77bf5033845f01be1188a852c6f0ba703042b4d06d14314841c1096c50\", \"id\":1 } The content after \"result\" is the session keys of your validator node","title":"Get Session Keys Of Your Node"},{"location":"canarynet/node/run-validator/#set-up-accounts","text":"For running a validator, you need to set up two accounts: Stash account : This account holds funds bonded for staking, but delegates some functions to the Controller account. It can be kept in a cold wallet, meaning it can stays offline all the time. Controller account : This account acts on behalf of the Stash account, signalling decisions and necessary execution for staking. It only needs enough funds to pay transaction fees. For more details, refer to Polkadot Keys . For how to create accounts in ContextFree, you can refer here .","title":"Set Up Accounts"},{"location":"canarynet/node/run-validator/#get-token","text":"Your Stash account and Controller account need to be funded with some native token If you already had some native token on other account, you can simply transfer to the stash and controller accounts you have created, using the dashboard by opening the Transfer page under the Accounts tab. If you don't have any native token, visit Get Token from Faucet to get some native token. Alternatively, if you have some ContextFree ERC20 token , you can follow the Token Bridge user guide to convert it into native token.","title":"Get Token"},{"location":"canarynet/node/run-validator/#stake-tokens","text":"Visit the Automata Dashboard Go to the Staking section. Set Stash and Controller. Choose the stash account and controller account accordingly, set the value for staking and press Bond to submit the transaction.","title":"Stake Tokens"},{"location":"canarynet/node/run-validator/#set-session-keys","text":"Click Session Keys and set the session keys you got previously. If you are nominating someone, you need to stop nominating or you will not be able to set session keys.","title":"Set Session Keys"},{"location":"canarynet/node/run-validator/#set-validate-parameters","text":"Click Validate Set the value of reward commission percentage , which is the rate that your validator will be commissioned with. The remaining rewards will be split among your nominators. Besides, you can choose to accept nominating or not.","title":"Set Validate Parameters"},{"location":"canarynet/node/run-validator/#joining-validator-set","text":"If you go to the \"Staking\" tab, you will see a list of active validators currently running on the network. At the top of the page, it shows the number of validator slots that are available as well as the number of nodes that have signaled their intention to be a validator. You can go to the \"Waiting\" tab to double check to see whether your node is listed there. The validator set is refreshed every era. In the next era, if there is a slot available and your node is selected to join the validator set, your node will become an active validator. Until then, it will remain in the waiting queue. If your validator is not selected to become part of the validator set, it will remain in the waiting queue until it is. There is no need to re-start if you are not selected for the validator set in a particular era. However, it may be necessary to increase the number of native token staked or seek out nominators for your validator in order to join the validator set.","title":"Joining Validator Set"},{"location":"canarynet/node/run-validator/#congratuation","text":"If you have followed all of these steps, and been selected to be a part of the validator set, you are now running a ContextFree validator!","title":"Congratuation"},{"location":"canarynet/userguide/accounts/","text":"Accounts \u00b6 This document introduce you to the basics of ContextFree accounts. Account basic \u00b6 The address format used in ContextFree network is SS58 , which is a modification of Base-58-check from Bitcoin with some miner changes. More details can be found on the Substrate github wiki . Network Address type prefix Leading characters Example(Alice) Automata Network 2349 aA ContextFree Network 11820 a7 a7SvTrjvshEMePMEZpEkYMekuZMPpDwMNqfUx8N8ScEEQYfM8 FiniteState Network 13107 at ateYGxACWo2Yu8wVi7RGJQsEQLAB25xbAHkSRpzTqMabJ38zx Substrate default 42 5 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY As we known, the secret seed of account Alice is: 0xe5be9a5092b81bca64be81d212e7f2f9eba183bb7a90954f7b76361f6edb5c0a . In ContextFree network, the address of Alice will be a7SvTrjvshEMePMEZpEkYMekuZMPpDwMNqfUx8N8ScEEQYfM8 . But all addresses above are merely different representations of the same public key in a private-public keypair. In another word, the account in ContextFree network is compatible with other substrate-based chains. Create account \u00b6 There are several ways to create an ContextFree account, we will suggest you to use our official blockchain explorer . Create account using explorer \u00b6 Open official blockchain explorer of Automata, check the connected network on the left upper corner of web page. If the connected network is not ContextFree Network , click and choose Automata ContextFree in TEST NETWORKS . Click Accounts in the top menu and choose Accounts , you will enter the accounts page. Then click Add account and start to create a new account. You will see a auto generated mnemonic in the popup box, please copy this mnemonic and save it safely. Enter an alias for this account and create a password, we suggest you to use a strong and unique password. Click Save and we finish the process of creating an account. The newly created account will be show in the list, and there will be a auto downloaded file which describe the details of this account. Import existing account \u00b6 The process of importing an existing account into blockchain explorer is similar to the process of creating one. We will show you how to import the well known Alice account. 1. Override the auto generated Mnemonic or Raw seed with mnemonic or seed of your existing account. 2. Create an alias and enter the password, the imported account will be show in the list. Wallet \u00b6 Please refer to Wallet tutorial if you want to create and manage accounts in polkadot extention.","title":"Accounts"},{"location":"canarynet/userguide/accounts/#accounts","text":"This document introduce you to the basics of ContextFree accounts.","title":"Accounts"},{"location":"canarynet/userguide/accounts/#account-basic","text":"The address format used in ContextFree network is SS58 , which is a modification of Base-58-check from Bitcoin with some miner changes. More details can be found on the Substrate github wiki . Network Address type prefix Leading characters Example(Alice) Automata Network 2349 aA ContextFree Network 11820 a7 a7SvTrjvshEMePMEZpEkYMekuZMPpDwMNqfUx8N8ScEEQYfM8 FiniteState Network 13107 at ateYGxACWo2Yu8wVi7RGJQsEQLAB25xbAHkSRpzTqMabJ38zx Substrate default 42 5 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY As we known, the secret seed of account Alice is: 0xe5be9a5092b81bca64be81d212e7f2f9eba183bb7a90954f7b76361f6edb5c0a . In ContextFree network, the address of Alice will be a7SvTrjvshEMePMEZpEkYMekuZMPpDwMNqfUx8N8ScEEQYfM8 . But all addresses above are merely different representations of the same public key in a private-public keypair. In another word, the account in ContextFree network is compatible with other substrate-based chains.","title":"Account basic"},{"location":"canarynet/userguide/accounts/#create-account","text":"There are several ways to create an ContextFree account, we will suggest you to use our official blockchain explorer .","title":"Create account"},{"location":"canarynet/userguide/accounts/#create-account-using-explorer","text":"Open official blockchain explorer of Automata, check the connected network on the left upper corner of web page. If the connected network is not ContextFree Network , click and choose Automata ContextFree in TEST NETWORKS . Click Accounts in the top menu and choose Accounts , you will enter the accounts page. Then click Add account and start to create a new account. You will see a auto generated mnemonic in the popup box, please copy this mnemonic and save it safely. Enter an alias for this account and create a password, we suggest you to use a strong and unique password. Click Save and we finish the process of creating an account. The newly created account will be show in the list, and there will be a auto downloaded file which describe the details of this account.","title":"Create account using explorer"},{"location":"canarynet/userguide/accounts/#import-existing-account","text":"The process of importing an existing account into blockchain explorer is similar to the process of creating one. We will show you how to import the well known Alice account. 1. Override the auto generated Mnemonic or Raw seed with mnemonic or seed of your existing account. 2. Create an alias and enter the password, the imported account will be show in the list.","title":"Import existing account"},{"location":"canarynet/userguide/accounts/#wallet","text":"Please refer to Wallet tutorial if you want to create and manage accounts in polkadot extention.","title":"Wallet"},{"location":"canarynet/userguide/get-test-token/","text":"Get Test Token \u00b6 This is a guide on how to claim test token on the ContextFree Assume you have set up your wallet account, if not, please refer to here Use Automata Faucet \u00b6 Visit the Automata Faucet , you may need to login via Twitter account to get access to the faucet page. Get ContextFree Native Token \u00b6 Input your canary network wallet address under this tab, and press Submit . Then 10 CTX native token will be sent to your address, you can check on the Automata Dashboard . Notice: You can request funding for your address for once per 24 hours. Get ContextFree ERC20 Token on Ropsten Testnet \u00b6 Input your Ropsten ETH address under this tab, and press Submit . Then 10 CTX ERC20 token will be sent to your Ropsten address, you can check on Ropsten Explorer . However the ERC20 token cannot be utilized as native token on the canary network, you can follow the instruction here to use the Automata Token Bridge to convert it into the ContextFree native token. Notice: You can request funding for your address for once per 24 hours.","title":"Get Test Token"},{"location":"canarynet/userguide/get-test-token/#get-test-token","text":"This is a guide on how to claim test token on the ContextFree Assume you have set up your wallet account, if not, please refer to here","title":"Get Test Token"},{"location":"canarynet/userguide/get-test-token/#use-automata-faucet","text":"Visit the Automata Faucet , you may need to login via Twitter account to get access to the faucet page.","title":"Use Automata Faucet"},{"location":"canarynet/userguide/get-test-token/#get-contextfree-native-token","text":"Input your canary network wallet address under this tab, and press Submit . Then 10 CTX native token will be sent to your address, you can check on the Automata Dashboard . Notice: You can request funding for your address for once per 24 hours.","title":"Get ContextFree Native Token"},{"location":"canarynet/userguide/get-test-token/#get-contextfree-erc20-token-on-ropsten-testnet","text":"Input your Ropsten ETH address under this tab, and press Submit . Then 10 CTX ERC20 token will be sent to your Ropsten address, you can check on Ropsten Explorer . However the ERC20 token cannot be utilized as native token on the canary network, you can follow the instruction here to use the Automata Token Bridge to convert it into the ContextFree native token. Notice: You can request funding for your address for once per 24 hours.","title":"Get ContextFree ERC20 Token on Ropsten Testnet"},{"location":"canarynet/userguide/setupwallet/","text":"ContextFree Network Wallet Setup Guide \u00b6 This is a guide on how to get onto the Automata Canary Net for Chrome users(recommended). Go to 'ContextFree Dashboard' You should reach a website which looks like the picture below. Hover over the Accounts taskbar and click on Accounts. Picture showing what is needed to be clicked. You should then reach this page. Then you must click on the link called polkadot-js extension on the page. This will direct you to an extension which needs to be downloaded. You should then add this to chrome. You must then click on the plugin to create an account. This process is very easy and just requires you to record your seed phrase, which should be noted to ensure you have a way to restore control of your account, create a username and then a password. You will then have an account. The account should look like this in the plugin. Once you have created your account, it will be necessary to refresh your page on Dashboard.ata.network. This will then prompt you to authorise polkadot{.js}, which you should approve. What the Authorize prompt looks like. After you have allowed the application access, you should then click on the settings tab at the top of the screen. Click on Settings. Then click on Metadata. Then click on update metadata. This will give you another prompt from polkadot{.js} asking to add the metadata to your extension instance. Click \u2018yes, do this metadata update\u2019 After you have done this, click on the polkadot{.js} plugin again. After this click on the three dots next to your account, click on the drop down box which currently says \u2018Allow Use On Any Chain\u2019 and change it to \u2018ContextFree Network.\u2019 After you have done this, refresh your page and click on Accounts again. If there is no exclamation mark next to your account then everything should be set up correctly. It should look like this. However, if there is an exclamation mark, then ensure that you have followed all the steps above. If you believe you have done all the steps properly, try the whole process once more and if you are still having problems then get in touch with us. If you have problems it would look like this. Now that you have set up everything, complete our google form with your name, email, Discord username, Telegram handle and your ContextFree Network wallet address and we will airdrop you some $CTX tokens for you to take part in the upcoming Canary Games. To participate in the Canary Games, register now with this form .","title":"Set up Wallet"},{"location":"canarynet/userguide/setupwallet/#contextfree-network-wallet-setup-guide","text":"This is a guide on how to get onto the Automata Canary Net for Chrome users(recommended). Go to 'ContextFree Dashboard' You should reach a website which looks like the picture below. Hover over the Accounts taskbar and click on Accounts. Picture showing what is needed to be clicked. You should then reach this page. Then you must click on the link called polkadot-js extension on the page. This will direct you to an extension which needs to be downloaded. You should then add this to chrome. You must then click on the plugin to create an account. This process is very easy and just requires you to record your seed phrase, which should be noted to ensure you have a way to restore control of your account, create a username and then a password. You will then have an account. The account should look like this in the plugin. Once you have created your account, it will be necessary to refresh your page on Dashboard.ata.network. This will then prompt you to authorise polkadot{.js}, which you should approve. What the Authorize prompt looks like. After you have allowed the application access, you should then click on the settings tab at the top of the screen. Click on Settings. Then click on Metadata. Then click on update metadata. This will give you another prompt from polkadot{.js} asking to add the metadata to your extension instance. Click \u2018yes, do this metadata update\u2019 After you have done this, click on the polkadot{.js} plugin again. After this click on the three dots next to your account, click on the drop down box which currently says \u2018Allow Use On Any Chain\u2019 and change it to \u2018ContextFree Network.\u2019 After you have done this, refresh your page and click on Accounts again. If there is no exclamation mark next to your account then everything should be set up correctly. It should look like this. However, if there is an exclamation mark, then ensure that you have followed all the steps above. If you believe you have done all the steps properly, try the whole process once more and if you are still having problems then get in touch with us. If you have problems it would look like this. Now that you have set up everything, complete our google form with your name, email, Discord username, Telegram handle and your ContextFree Network wallet address and we will airdrop you some $CTX tokens for you to take part in the upcoming Canary Games. To participate in the Canary Games, register now with this form .","title":"ContextFree Network Wallet Setup Guide"},{"location":"canarynet/userguide/token-bridge/","text":"Automata ContextFree Token Bridge Tutorial \u00b6 Introduction \u00b6 A cross-chain bridge is a connection that allows the transfer of tokens from one chain to another. Both chains can have different protocols and rules, but the bridge provides a compatible way to interoperate securely on both sides. The Automata team has set up a cross-chain token bridge for ContextFree between EVM ( Ropsten testnet ) and Substrate-based chains( ContextFree canary network ) by adopting one of the currently available solutions ChainBridge built by ChainSafe . Tutorial \u00b6 Transfer ERC20 Token to Native Token \u00b6 Preparation \u00b6 To use the Automata Token Bridge, please ensure your explorer is Chrome and the following is installed: Metamask Wallet Extension Visit Automata Token Bridge . Set Up MetaMask \u00b6 Click Connect with Ethereum Wallet(ERC20 -> Native) . Select MetaMask . Then you may need may need to enter password to unlock the MetaMask wallet extension if it hasn't been open for a while. Connect Metamask to bridge dapp. Change the network in MetaMask to Ropsten Test Network . If you don't see the CTX token showing up in the assets, press Import tokens , enter the following specifications and press Add Custom Token : Token Contract Address: 0x8289b901CAC48EbBB1B5cb0049d1459EA1240EF7 Token Symbol: CTX Token Decimal: 18 Then Import Tokens , if you already had some CTX token, the balance will be showed. Let's go back to the web page for the token bridge, by now it should look like this: If not you can click Connect and repeat the above steps. Use the Bridge App \u00b6 Make sure the following fields are correct: Home network: Ethereum Ropsten . Destination Network: Automata ContextFree . Get some CTX ERC20 token if the balance is 0, please refer here . Make sure you have enough ETH on Ropsten Testnet to pay for the BridgeFee and transaction Gas Fee. If not, you can use Ropsten Ethereum Faucet to get some airdrop. Enter the amount of CTX you want to transfer. For the Destination Address, make sure that: the address starts with a7 . the address is valid by trying Add Contact on Automata Dashboard. double check the destination address is correct, once your token were sent to a wrong address it can never be claimed back. If everything looks okay, press Start transfer , confirm the Pre-flight check and press Start Transfer again. Then a MetaMask notification will be popped up to let you allow the website to spend your CTX token, press Confirm . Wait a moment for that transaction to be confirmed. Another MetaMask notification will be prompted, which is to send a transaction to trigger the actual cross-chain bridging transfer, press Confirm . Then you should be able to see this In Transit , it usually takes a few minutes to finish the transferring, please be patient. Once the transferring has been completed, it will show Transfer completed Congratulations! You have completed your first cross-chain token transfer on Automata ContextFree! Go check the balance of the destination address on Automata Dashboard . If you can't see it, try Add contact in the Address book . Transfer Native Token to ERC20 Token \u00b6 Preparation \u00b6 To use the Automata Token Bridge, please ensure your explorer is Chrome and the following is installed: Polkadot{.js} Wallet Extension Visit Automata Token Bridge . Set Up Polkadot{.js} \u00b6 Click Connect with Substrate Wallet(Native -> ERC20) . If it's your first time to use ContextFree bridge, you need to allow it to access your wallet. Authorize the application to access the wallet by pressing Yes, allow this application access on the popped up Polkadot.js notification. If you haven't set up your wallet addresses, please refer here . Use the Bridge App \u00b6 After connecting you Substrate wallet and setting up your Polkadot.js wallet extension, the Token Bridge App should be like this: Click Select an account , you should be able to see a list of addresses starting with a7 , which are ContextFree addresses injected from your Polkadot.js wallet extension. Select the address you want to transfer native token from, the page now should look like: Make sure the following fields are correct: Select account: The address of your native token sender. Destination Network: Ethereum Ropsten . Get some native CTX test token if the balance is 0, please refer here . Make sure you have enough balance to pay for the Bridge Fee and the total amount to transfer. Fill in the Destination Address , which will be an Ethereum address on Ropsten Test Network starting with 0x . Press Start transfer , you will be required to input the password to sign the transaction. Wait for your transfer to complete, it may take a few minutes. After the webpage showing Transfer completed . You can go to Ethereum Ropsten Explorer to check the balance of ContextFree ERC20 Token of your destination address.","title":"Use Token Bridge"},{"location":"canarynet/userguide/token-bridge/#automata-contextfree-token-bridge-tutorial","text":"","title":"Automata ContextFree Token Bridge Tutorial"},{"location":"canarynet/userguide/token-bridge/#introduction","text":"A cross-chain bridge is a connection that allows the transfer of tokens from one chain to another. Both chains can have different protocols and rules, but the bridge provides a compatible way to interoperate securely on both sides. The Automata team has set up a cross-chain token bridge for ContextFree between EVM ( Ropsten testnet ) and Substrate-based chains( ContextFree canary network ) by adopting one of the currently available solutions ChainBridge built by ChainSafe .","title":"Introduction"},{"location":"canarynet/userguide/token-bridge/#tutorial","text":"","title":"Tutorial"},{"location":"canarynet/userguide/token-bridge/#transfer-erc20-token-to-native-token","text":"","title":"Transfer ERC20 Token to Native Token"},{"location":"canarynet/userguide/token-bridge/#preparation","text":"To use the Automata Token Bridge, please ensure your explorer is Chrome and the following is installed: Metamask Wallet Extension Visit Automata Token Bridge .","title":"Preparation"},{"location":"canarynet/userguide/token-bridge/#set-up-metamask","text":"Click Connect with Ethereum Wallet(ERC20 -> Native) . Select MetaMask . Then you may need may need to enter password to unlock the MetaMask wallet extension if it hasn't been open for a while. Connect Metamask to bridge dapp. Change the network in MetaMask to Ropsten Test Network . If you don't see the CTX token showing up in the assets, press Import tokens , enter the following specifications and press Add Custom Token : Token Contract Address: 0x8289b901CAC48EbBB1B5cb0049d1459EA1240EF7 Token Symbol: CTX Token Decimal: 18 Then Import Tokens , if you already had some CTX token, the balance will be showed. Let's go back to the web page for the token bridge, by now it should look like this: If not you can click Connect and repeat the above steps.","title":"Set Up MetaMask"},{"location":"canarynet/userguide/token-bridge/#use-the-bridge-app","text":"Make sure the following fields are correct: Home network: Ethereum Ropsten . Destination Network: Automata ContextFree . Get some CTX ERC20 token if the balance is 0, please refer here . Make sure you have enough ETH on Ropsten Testnet to pay for the BridgeFee and transaction Gas Fee. If not, you can use Ropsten Ethereum Faucet to get some airdrop. Enter the amount of CTX you want to transfer. For the Destination Address, make sure that: the address starts with a7 . the address is valid by trying Add Contact on Automata Dashboard. double check the destination address is correct, once your token were sent to a wrong address it can never be claimed back. If everything looks okay, press Start transfer , confirm the Pre-flight check and press Start Transfer again. Then a MetaMask notification will be popped up to let you allow the website to spend your CTX token, press Confirm . Wait a moment for that transaction to be confirmed. Another MetaMask notification will be prompted, which is to send a transaction to trigger the actual cross-chain bridging transfer, press Confirm . Then you should be able to see this In Transit , it usually takes a few minutes to finish the transferring, please be patient. Once the transferring has been completed, it will show Transfer completed Congratulations! You have completed your first cross-chain token transfer on Automata ContextFree! Go check the balance of the destination address on Automata Dashboard . If you can't see it, try Add contact in the Address book .","title":"Use the Bridge App"},{"location":"canarynet/userguide/token-bridge/#transfer-native-token-to-erc20-token","text":"","title":"Transfer Native Token to ERC20 Token"},{"location":"canarynet/userguide/token-bridge/#preparation_1","text":"To use the Automata Token Bridge, please ensure your explorer is Chrome and the following is installed: Polkadot{.js} Wallet Extension Visit Automata Token Bridge .","title":"Preparation"},{"location":"canarynet/userguide/token-bridge/#set-up-polkadotjs","text":"Click Connect with Substrate Wallet(Native -> ERC20) . If it's your first time to use ContextFree bridge, you need to allow it to access your wallet. Authorize the application to access the wallet by pressing Yes, allow this application access on the popped up Polkadot.js notification. If you haven't set up your wallet addresses, please refer here .","title":"Set Up Polkadot{.js}"},{"location":"canarynet/userguide/token-bridge/#use-the-bridge-app_1","text":"After connecting you Substrate wallet and setting up your Polkadot.js wallet extension, the Token Bridge App should be like this: Click Select an account , you should be able to see a list of addresses starting with a7 , which are ContextFree addresses injected from your Polkadot.js wallet extension. Select the address you want to transfer native token from, the page now should look like: Make sure the following fields are correct: Select account: The address of your native token sender. Destination Network: Ethereum Ropsten . Get some native CTX test token if the balance is 0, please refer here . Make sure you have enough balance to pay for the Bridge Fee and the total amount to transfer. Fill in the Destination Address , which will be an Ethereum address on Ropsten Test Network starting with 0x . Press Start transfer , you will be required to input the password to sign the transaction. Wait for your transfer to complete, it may take a few minutes. After the webpage showing Transfer completed . You can go to Ethereum Ropsten Explorer to check the balance of ContextFree ERC20 Token of your destination address.","title":"Use the Bridge App"},{"location":"conveyor/overview/","text":"Automata Conveyor \u00b6 Automata Conveyor is a service that ingests and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering. When transactions are fed into Conveyor, it determines the order of the incoming transactions and makes it impossible for block producers to perform the following: Inject new transactions into the Conveyor output: The inserted transactions bypassing Conveyor is detectable by anyone because of signature mismatch. Delete ordered transactions: Transactions accepted by Conveyor are broadcasted everywhere so transactions cannot be deleted unless ALL block producers are colluding and censoring the transactions at the same time. From the DEX\u2019s perspective, they can choose to accept either Ordered transactions from Automata\u2019s Conveyor which is free from transaction reordering and other front-running transactions Other unordered transactions (which include front-running etc) that may negatively impact their users","title":"Overview"},{"location":"conveyor/overview/#automata-conveyor","text":"Automata Conveyor is a service that ingests and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering. When transactions are fed into Conveyor, it determines the order of the incoming transactions and makes it impossible for block producers to perform the following: Inject new transactions into the Conveyor output: The inserted transactions bypassing Conveyor is detectable by anyone because of signature mismatch. Delete ordered transactions: Transactions accepted by Conveyor are broadcasted everywhere so transactions cannot be deleted unless ALL block producers are colluding and censoring the transactions at the same time. From the DEX\u2019s perspective, they can choose to accept either Ordered transactions from Automata\u2019s Conveyor which is free from transaction reordering and other front-running transactions Other unordered transactions (which include front-running etc) that may negatively impact their users","title":"Automata Conveyor"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/","text":"Controller \u00b6 The prevention of anti-front-running is implemented by requiring that all method calls to the DEX must be only invoked by the Geode. The user submits a request to the Geode by signing the message without spending gas. The Geode later delegates that request to the DEX for a fee that is deducted from the output token. constructor() \u00b6 constructor ( address _relayer , address _router , address _factory ); Initializes the Controller, Uniswap Factory, and Router contracts and assigns a relayer. relayers \u00b6 mapping ( address => bool ) public relayers ; Key-value pair map that keeps track of the trusted relayers. Parameter Type key address Input address value bool True : address is a trusted relayer. False : otherwise uniswapV2TrustedPair \u00b6 mapping ( address => bool ) public uniswapV2TrustedPair ; Key-value pair map that keeps track of the trusted Uniswap token pair addresses . Parameter Type key address Input address value bool True : address is a trusted pair. False : otherwise relayerOnly() \u00b6 modifier relayerOnly (); Verifies msg.sender is a trusted relayer address, otherwise reverts the function call. setRelayer() \u00b6 function setRelayer ( address _relayer ) public onlyOwner () Assigns the input address as a trusted relayer, can only be invoked by the contract owner. Parameter Type _relayer address Input address isTrustedUniswapV2Pair() \u00b6 function isTrustedUniswapV2Pair ( address pair ) external override returns ( bool ); Checks the input address to determine whether it is a trusted Uniswap pair address or not, returns bool . Parameter Type pair address Input address addTrustedUniswapV2Pair() \u00b6 function addTrustedUniswapV2Pair ( address pair ) public onlyOwner (); Adds the input address as a trusted Uniswap pair address, can only be invoked by the contract owner. Parameter Type pair address Input address removeTrustedUniswapV2Pair() \u00b6 function removeTrustedUniswapV2Pair ( address pair ) public onlyOwner (); Removes the pair address from the uniswapV2TrustedPair map, can only be invoked by the contract owner. Parameter Type pair address Input address gTokenTransferFrom() \u00b6 function gTokenTransferFrom ( address asset , address from , address to , uint256 amount ) public relayerOnly (); Transfers ERC20 tokens from a sender address to a recipient address, can only be invoked by a relayer. Parameter Type asset address The address of the ERC20 token from address Sender address to address Recipient address amount uint256 Amount of tokens to be transferred uniswapV2AddLiquidity() \u00b6 function uniswapV2AddLiquidity ( address from , address tokenA , address tokenB , uint256 amountADesired , uint256 amountBDesired , uint256 amountAMin , uint256 amountBMin , address to , uint256 deadline , bool gasIsTokenA ) public relayerOnly (); This method initially checks for either token A or B balance (depending on gasIsTokenA ), to make sure that the user could pay for gas. Then, deducts the token amount, which is transferred to the relayer. Supplies the token pair to the Uniswap liquidity pool, can only be invoked by a relayer and input tokens must be both wrapped tokens. Any leftover tokens that are not added to the liquidity pool will be refunded to the sender. Parameter Type from address The sender address tokenA address Wrapped Token A address tokenB address Wrapped Token B address amountADesired uint256 The amount of A added to the liquidity pool if the B/A price <= ( amountofBDesired / amountofADesired ) price amountBDesired uint256 The amount of B added to the liquidity pool if the A/B price <= ( amountofADesired / amountofBDesired ) price amountAMin uint256 Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired amountBMin uint256 Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired to address The recipient address of the liquidity token. In this project, it is most likely the sender's address, since they provided liquidity, they should be entitled to getting rewarded with liquidity tokens deadline uint256 Unix timestamp after which the transaction is reverted gasIsTokenA bool User to pay gas in Token A or Token B uniswapV2SwapExactTokensForTokens() \u00b6 function uniswapV2SwapExactTokensForTokens ( address from , uint256 amountIn , uint256 amountOutMin , address [] calldata path , address to , uint256 deadline ) public relayerOnly (); This method initially checks for the balance of the input token, to make sure that the user could pay for gas. Then after the swapping of tokens, deducts the output token amount, which is transferred to the relayer. Swaps an exact amount of input tokens for as much of output tokens as possible, can only be invoked by a relayer. Any leftover tokens that are not swapped will be refunded to the sender. Parameter Type from address The sender address amountIn uint256 The amount of input tokens to be sent amountOutMin uint256 The minimum amount of tokens that must be received, otherwise the transaction reverts path address[] An array of token addresses. path.length >= 2 to address Recipient of the output tokens. In this project, it is also the sender's address deadline uint256 Unix timestamp after which the transaction is reverted uniswapV2SwapTokensForExactTokens() \u00b6 function uniswapV2SwapTokensForExactTokens ( address from , uint256 amountIn , uint256 amountOutMin , address [] calldata path , address to , uint256 deadline ) public relayerOnly (); This method initially checks for the balance of the input token, to make sure that the user could pay for gas. Then after the swapping of tokens, deducts the output token amount, which is transferred to the relayer. Swaps an amount of input tokens for exact amount of output tokens, can only be invoked by a relayer. Any leftover tokens that are not swapped will be refunded to the sender. Parameter Type from address The sender address amountInMax uint256 The minimum amount of tokens that must be sent, otherwise the transaction reverts amountOut uint256 The amount of output tokens to be sents path address[] An array of token addresses. path.length >= 2 to address Recipient of the output tokens. In this project, it is also the sender's address deadline uint256 Unix timestamp after which the transaction is reverted","title":"Controller"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#controller","text":"The prevention of anti-front-running is implemented by requiring that all method calls to the DEX must be only invoked by the Geode. The user submits a request to the Geode by signing the message without spending gas. The Geode later delegates that request to the DEX for a fee that is deducted from the output token.","title":"Controller"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#constructor","text":"constructor ( address _relayer , address _router , address _factory ); Initializes the Controller, Uniswap Factory, and Router contracts and assigns a relayer.","title":"constructor()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#relayers","text":"mapping ( address => bool ) public relayers ; Key-value pair map that keeps track of the trusted relayers. Parameter Type key address Input address value bool True : address is a trusted relayer. False : otherwise","title":"relayers"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#uniswapv2trustedpair","text":"mapping ( address => bool ) public uniswapV2TrustedPair ; Key-value pair map that keeps track of the trusted Uniswap token pair addresses . Parameter Type key address Input address value bool True : address is a trusted pair. False : otherwise","title":"uniswapV2TrustedPair"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#relayeronly","text":"modifier relayerOnly (); Verifies msg.sender is a trusted relayer address, otherwise reverts the function call.","title":"relayerOnly()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#setrelayer","text":"function setRelayer ( address _relayer ) public onlyOwner () Assigns the input address as a trusted relayer, can only be invoked by the contract owner. Parameter Type _relayer address Input address","title":"setRelayer()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#istrusteduniswapv2pair","text":"function isTrustedUniswapV2Pair ( address pair ) external override returns ( bool ); Checks the input address to determine whether it is a trusted Uniswap pair address or not, returns bool . Parameter Type pair address Input address","title":"isTrustedUniswapV2Pair()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#addtrusteduniswapv2pair","text":"function addTrustedUniswapV2Pair ( address pair ) public onlyOwner (); Adds the input address as a trusted Uniswap pair address, can only be invoked by the contract owner. Parameter Type pair address Input address","title":"addTrustedUniswapV2Pair()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#removetrusteduniswapv2pair","text":"function removeTrustedUniswapV2Pair ( address pair ) public onlyOwner (); Removes the pair address from the uniswapV2TrustedPair map, can only be invoked by the contract owner. Parameter Type pair address Input address","title":"removeTrustedUniswapV2Pair()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#gtokentransferfrom","text":"function gTokenTransferFrom ( address asset , address from , address to , uint256 amount ) public relayerOnly (); Transfers ERC20 tokens from a sender address to a recipient address, can only be invoked by a relayer. Parameter Type asset address The address of the ERC20 token from address Sender address to address Recipient address amount uint256 Amount of tokens to be transferred","title":"gTokenTransferFrom()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#uniswapv2addliquidity","text":"function uniswapV2AddLiquidity ( address from , address tokenA , address tokenB , uint256 amountADesired , uint256 amountBDesired , uint256 amountAMin , uint256 amountBMin , address to , uint256 deadline , bool gasIsTokenA ) public relayerOnly (); This method initially checks for either token A or B balance (depending on gasIsTokenA ), to make sure that the user could pay for gas. Then, deducts the token amount, which is transferred to the relayer. Supplies the token pair to the Uniswap liquidity pool, can only be invoked by a relayer and input tokens must be both wrapped tokens. Any leftover tokens that are not added to the liquidity pool will be refunded to the sender. Parameter Type from address The sender address tokenA address Wrapped Token A address tokenB address Wrapped Token B address amountADesired uint256 The amount of A added to the liquidity pool if the B/A price <= ( amountofBDesired / amountofADesired ) price amountBDesired uint256 The amount of B added to the liquidity pool if the A/B price <= ( amountofADesired / amountofBDesired ) price amountAMin uint256 Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired amountBMin uint256 Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired to address The recipient address of the liquidity token. In this project, it is most likely the sender's address, since they provided liquidity, they should be entitled to getting rewarded with liquidity tokens deadline uint256 Unix timestamp after which the transaction is reverted gasIsTokenA bool User to pay gas in Token A or Token B","title":"uniswapV2AddLiquidity()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#uniswapv2swapexacttokensfortokens","text":"function uniswapV2SwapExactTokensForTokens ( address from , uint256 amountIn , uint256 amountOutMin , address [] calldata path , address to , uint256 deadline ) public relayerOnly (); This method initially checks for the balance of the input token, to make sure that the user could pay for gas. Then after the swapping of tokens, deducts the output token amount, which is transferred to the relayer. Swaps an exact amount of input tokens for as much of output tokens as possible, can only be invoked by a relayer. Any leftover tokens that are not swapped will be refunded to the sender. Parameter Type from address The sender address amountIn uint256 The amount of input tokens to be sent amountOutMin uint256 The minimum amount of tokens that must be received, otherwise the transaction reverts path address[] An array of token addresses. path.length >= 2 to address Recipient of the output tokens. In this project, it is also the sender's address deadline uint256 Unix timestamp after which the transaction is reverted","title":"uniswapV2SwapExactTokensForTokens()"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#uniswapv2swaptokensforexacttokens","text":"function uniswapV2SwapTokensForExactTokens ( address from , uint256 amountIn , uint256 amountOutMin , address [] calldata path , address to , uint256 deadline ) public relayerOnly (); This method initially checks for the balance of the input token, to make sure that the user could pay for gas. Then after the swapping of tokens, deducts the output token amount, which is transferred to the relayer. Swaps an amount of input tokens for exact amount of output tokens, can only be invoked by a relayer. Any leftover tokens that are not swapped will be refunded to the sender. Parameter Type from address The sender address amountInMax uint256 The minimum amount of tokens that must be sent, otherwise the transaction reverts amountOut uint256 The amount of output tokens to be sents path address[] An array of token addresses. path.length >= 2 to address Recipient of the output tokens. In this project, it is also the sender's address deadline uint256 Unix timestamp after which the transaction is reverted","title":"uniswapV2SwapTokensForExactTokens()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/","text":"gToken \u00b6 The goal of gTokens is to achieve front-running resistance on DEXs such as Uniswap. When two different gTokens are swapped, users can rest assured that the swapping transaction will not be attacked by front-running bots or malicious miners. This is achieved by inheriting the ERC20 contract, with modified function methods. Methods such as transferFrom() requires that it has to be invoked only from a trusted relayer. constructor() \u00b6 constructor ( address _token , address _controller ); Initializes the contract, then wraps the ERC20 token and assigns the Controller contract instance. Parameter Type _token address The ERC20 Token Address _controller address The address of the Controller instance onlyController() \u00b6 modifier onlyController (); Verifies msg.sender is the Controller address. Otherwise, reverts function calls. setController() \u00b6 function setController ( address _controller ) public onlyOwner (); Sets the Controller instance, can only be invoked by the contract owner. Parameter Type _controller address The address of the Controller instance transferFrom() \u00b6 function transferFrom ( address sender , address recipient , uint256 amount ) public override returns ( bool ); Transfers gTokens from a given address to the recipient. The sender is always the address of the Controller , the transaction is not necessarily originated from the Controller contract itself, as long as the origin address is one of the trusted relayers. For the direct call method, see internalTransferFrom() . Parameter Type sender address The address of a trusted relayer recipient address The recipient's address, most likely a token pair address. For example, an address returned by Uniswap's getPair(tokenA, tokenB) . amount uint256 The amount of token to be transferred. This method reverts if it is not invoked from a trusted relayer. Otherwise, returns true. transfer() \u00b6 function transfer ( address recipient , uint256 amount ) public override returns ( bool ); Transfers gTokens to a recipient. This method can only be invoked by a trusted token pair. Parameter Type recipient address The recipient's address amount uint256 The amount of token to be transferred internalTransferFrom() \u00b6 function internalTransferFrom ( address sender , address recipient , uint256 amount ) public onlyController (); Transfers gTokens from a given address to the recipient, similar to transferFrom() . This method can only be invoked directly from the Controller contract. Parameter Type sender address The sender's address recipient address The recipient's address amount uint256 The amount of token to be transferred deposit() \u00b6 function deposit ( uint256 amount ) public ; Wraps ERC20 token to a gToken. The gToken smart contract stores an amount of ERC20 token as a reserve and mints the same amount of wrapped ERC20 token. Parameter Type amount uint256 The amount of token to be transferred withdraw() \u00b6 function withdraw ( uint256 amount ) public ; Withdraws ERC20 token from the smart contract and burns the wrapped token. Parameter Type amount uint256 The amount of token to be transferred","title":"gToken"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#gtoken","text":"The goal of gTokens is to achieve front-running resistance on DEXs such as Uniswap. When two different gTokens are swapped, users can rest assured that the swapping transaction will not be attacked by front-running bots or malicious miners. This is achieved by inheriting the ERC20 contract, with modified function methods. Methods such as transferFrom() requires that it has to be invoked only from a trusted relayer.","title":"gToken"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#constructor","text":"constructor ( address _token , address _controller ); Initializes the contract, then wraps the ERC20 token and assigns the Controller contract instance. Parameter Type _token address The ERC20 Token Address _controller address The address of the Controller instance","title":"constructor()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#onlycontroller","text":"modifier onlyController (); Verifies msg.sender is the Controller address. Otherwise, reverts function calls.","title":"onlyController()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#setcontroller","text":"function setController ( address _controller ) public onlyOwner (); Sets the Controller instance, can only be invoked by the contract owner. Parameter Type _controller address The address of the Controller instance","title":"setController()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#transferfrom","text":"function transferFrom ( address sender , address recipient , uint256 amount ) public override returns ( bool ); Transfers gTokens from a given address to the recipient. The sender is always the address of the Controller , the transaction is not necessarily originated from the Controller contract itself, as long as the origin address is one of the trusted relayers. For the direct call method, see internalTransferFrom() . Parameter Type sender address The address of a trusted relayer recipient address The recipient's address, most likely a token pair address. For example, an address returned by Uniswap's getPair(tokenA, tokenB) . amount uint256 The amount of token to be transferred. This method reverts if it is not invoked from a trusted relayer. Otherwise, returns true.","title":"transferFrom()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#transfer","text":"function transfer ( address recipient , uint256 amount ) public override returns ( bool ); Transfers gTokens to a recipient. This method can only be invoked by a trusted token pair. Parameter Type recipient address The recipient's address amount uint256 The amount of token to be transferred","title":"transfer()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#internaltransferfrom","text":"function internalTransferFrom ( address sender , address recipient , uint256 amount ) public onlyController (); Transfers gTokens from a given address to the recipient, similar to transferFrom() . This method can only be invoked directly from the Controller contract. Parameter Type sender address The sender's address recipient address The recipient's address amount uint256 The amount of token to be transferred","title":"internalTransferFrom()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#deposit","text":"function deposit ( uint256 amount ) public ; Wraps ERC20 token to a gToken. The gToken smart contract stores an amount of ERC20 token as a reserve and mints the same amount of wrapped ERC20 token. Parameter Type amount uint256 The amount of token to be transferred","title":"deposit()"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#withdraw","text":"function withdraw ( uint256 amount ) public ; Withdraws ERC20 token from the smart contract and burns the wrapped token. Parameter Type amount uint256 The amount of token to be transferred","title":"withdraw()"},{"location":"conveyor/conveyorv1/automata-conveyor-overview/","text":"Overview \u00b6 Automata Conveyor is an anti-front-running service that ingests and outputs transactions in a determined order. Automata Conveyor currently has the following components: gToken smart contract : inherits the ERC20 contract with modified function methods that must be invoked by trusted Geode-provided addresses. Controller smart contract : interacts with the users and facilitates the transfer of gTokens. External calls to any functions in the contract from any addresses other than the trusted relayers will be reverted. Automata Conciliator : TBA The following is an overview of the architecture. Note The Geode is an on-chain computation resource provided by the Automata network. Smart Contract Call Graph \u00b6 The following call graph details the interaction among smart contracts.","title":"Overview"},{"location":"conveyor/conveyorv1/automata-conveyor-overview/#overview","text":"Automata Conveyor is an anti-front-running service that ingests and outputs transactions in a determined order. Automata Conveyor currently has the following components: gToken smart contract : inherits the ERC20 contract with modified function methods that must be invoked by trusted Geode-provided addresses. Controller smart contract : interacts with the users and facilitates the transfer of gTokens. External calls to any functions in the contract from any addresses other than the trusted relayers will be reverted. Automata Conciliator : TBA The following is an overview of the architecture. Note The Geode is an on-chain computation resource provided by the Automata network.","title":"Overview"},{"location":"conveyor/conveyorv1/automata-conveyor-overview/#smart-contract-call-graph","text":"The following call graph details the interaction among smart contracts.","title":"Smart Contract Call Graph"},{"location":"conveyor/conveyorv1/fee-contract/","text":"Fee.sol \u00b6 The contract fetches real-time price feed from Chainlink Oracles and converts the gas fee amount to an equivalent token price. admin \u00b6 mapping ( address => bool ) admins ; Key-value pair map that keeps track of the contract admin. Parameter Type key address input addresses value bool True: the address is an admin, False: otherwise priceContracts \u00b6 mapping ( bytes => address ) public priceContracts ; Key-value pair map that stores the address of a Chainlink pricefeed oracle contract. Parameter Type key bytes The input price feed index, with the format: <network>-<token>-eth . For example, to query the USDC/ETH price from the Mainnet, enter main-usdc-eth value address The Chainlink oracle address tokensMap \u00b6 mapping ( address => bytes ) public tokensMap ; Key-value pair mapping tokens to their contract addresses. Parameter Type key address The ERC20 token address value bytes The input price feed index, as defined in priceContracts constructor() \u00b6 constructor () public ; Assigns the deployer as a default admin, and pre-assigns the following price feed: main-usdc-eth main-uni-eth kovan-usdc-eth onlyAdmin() \u00b6 modifier onlyAdmin (); Verifies msg.sender is a contract admin. modifyAdmin() \u00b6 function modifyAdmin ( address input , bool isAdmin ) public onlyAdmin (); Adds or removes admin privilege to or from the input address. Parameter Type input address The input address to be given or revoked admin privilege isAdmin bool true : assigns admin, false : revokes admin addPriceFeed() \u00b6 function addPriceFeed ( string memory priceIndex , address feed , address token ) public onlyAdmin (); Adds a new price feed, then maps to the token address. It can only be invoked by an admin. To find more oracle addresses, check out the Chainlink docs . Parameter Type priceIndex string The input price feed index, as defined in priceContracts feed address The address of the Chainlink price feed token address The ERC20 token address gasPrice() \u00b6 function getPrice ( address token ) public view returns ( int256 ); Gets the real time price data from Chainlink in 18 decimals. Parameter Type token address The ERC20 Token address calculateGasInTokens() \u00b6 function calculateGasInTokens ( address token , uint256 gas , uint256 weiPerToken ) public view returns ( uint256 ) Returns the amount of tokens equivalent to the gas fee. Parameter Type token address The ERC20 token address gas uint256 The gas fee weiPerToken uint256 The Wei amount per token","title":"`Fee.sol`"},{"location":"conveyor/conveyorv1/fee-contract/#feesol","text":"The contract fetches real-time price feed from Chainlink Oracles and converts the gas fee amount to an equivalent token price.","title":"Fee.sol"},{"location":"conveyor/conveyorv1/fee-contract/#admin","text":"mapping ( address => bool ) admins ; Key-value pair map that keeps track of the contract admin. Parameter Type key address input addresses value bool True: the address is an admin, False: otherwise","title":"admin"},{"location":"conveyor/conveyorv1/fee-contract/#pricecontracts","text":"mapping ( bytes => address ) public priceContracts ; Key-value pair map that stores the address of a Chainlink pricefeed oracle contract. Parameter Type key bytes The input price feed index, with the format: <network>-<token>-eth . For example, to query the USDC/ETH price from the Mainnet, enter main-usdc-eth value address The Chainlink oracle address","title":"priceContracts"},{"location":"conveyor/conveyorv1/fee-contract/#tokensmap","text":"mapping ( address => bytes ) public tokensMap ; Key-value pair mapping tokens to their contract addresses. Parameter Type key address The ERC20 token address value bytes The input price feed index, as defined in priceContracts","title":"tokensMap"},{"location":"conveyor/conveyorv1/fee-contract/#constructor","text":"constructor () public ; Assigns the deployer as a default admin, and pre-assigns the following price feed: main-usdc-eth main-uni-eth kovan-usdc-eth","title":"constructor()"},{"location":"conveyor/conveyorv1/fee-contract/#onlyadmin","text":"modifier onlyAdmin (); Verifies msg.sender is a contract admin.","title":"onlyAdmin()"},{"location":"conveyor/conveyorv1/fee-contract/#modifyadmin","text":"function modifyAdmin ( address input , bool isAdmin ) public onlyAdmin (); Adds or removes admin privilege to or from the input address. Parameter Type input address The input address to be given or revoked admin privilege isAdmin bool true : assigns admin, false : revokes admin","title":"modifyAdmin()"},{"location":"conveyor/conveyorv1/fee-contract/#addpricefeed","text":"function addPriceFeed ( string memory priceIndex , address feed , address token ) public onlyAdmin (); Adds a new price feed, then maps to the token address. It can only be invoked by an admin. To find more oracle addresses, check out the Chainlink docs . Parameter Type priceIndex string The input price feed index, as defined in priceContracts feed address The address of the Chainlink price feed token address The ERC20 token address","title":"addPriceFeed()"},{"location":"conveyor/conveyorv1/fee-contract/#gasprice","text":"function getPrice ( address token ) public view returns ( int256 ); Gets the real time price data from Chainlink in 18 decimals. Parameter Type token address The ERC20 Token address","title":"gasPrice()"},{"location":"conveyor/conveyorv1/fee-contract/#calculategasintokens","text":"function calculateGasInTokens ( address token , uint256 gas , uint256 weiPerToken ) public view returns ( uint256 ) Returns the amount of tokens equivalent to the gas fee. Parameter Type token address The ERC20 token address gas uint256 The gas fee weiPerToken uint256 The Wei amount per token","title":"calculateGasInTokens()"},{"location":"conveyor/conveyorv1/fee/","text":"Fee System \u00b6 Overview: \u00b6 1) The user submits a request to the Geode to perform a transaction. For example, swapping 100 gUSDC for 100 gDAI. swapExactTokensForTokens() Transitioning to Step 2: The Geode verifies that the amount of input token (USDC) is sufficient to pay for gas. The Geode can do this by simply calling the getPrice() method from Fee.sol to get USDC/ETH price in 18 decimals. For example, 1 USDC = 0.000361 ETH would yield 361000000000000. After Geode confirmed the user meets the minimum fee requirement, see step 2. 2) The Geode estimates the gas limit and the gas price. The Controller would capture this information to perform another input token check on step 3. 3) After the Controller finalizes the gas fee check, the Controller sends the transaction to UniswapRouter02 to perform the swap. The Geode would pay the gas fee \"out of pocket\" here, to be reimbursed later on step 4. Then, calculates the actual amount of gas consumption at this point. 4) Let's say the fast gas price is 49 gWei, with an average gas limit of 200,000 to perform a swap, the total gas fee (at the time of writing this) is 0.0098 ETH. The Controller then automatically allocates 25.48 gDAI to reimburse the Geode (or locks it in the contract itself). The user gets the remaining 74.52 gDAI. Price Feed oracles that are available on Chainlink \u00b6 Click here to find the oracle addresses for the following exchange rates. Ethereum Mainnet \u00b6 1INCH / ETH AAVE / ETH ALPHA / ETH AMPL / ETH ANT / ETH BADGER / ETH BAL / ETH BAND / ETH BAT / ETH BNB / ETH BNT / ETH BTC / ETH BUSD / ETH BZRX / ETH CEL / ETH COMP / ETH COVER / ETH CREAM / ETH CRO / ETH CRV / ETH DAI / ETH DPI / ETH ENJ / ETH FIL / ETH FTM / ETH FTT / ETH GRT / ETH HEGIC / ETH HUSD / ETH KNC / ETH KP3R / ETH LINK / ETH LON / ETH LRC / ETH MANA / ETH MKR / ETH MLN / ETH MTA / ETH NMR / ETH OCEAN / ETH OGN / ETH OMG / ETH ORN / ETH PAX / ETH PAXG / ETH PERP / ETH RAI / ETH RARI / ETH REN / ETH REP / ETH RGT / ETH RLC / ETH RUNE / ETH SFI / ETH SNX / ETH SRM / ETH SUSD / ETH SUSHI / ETH TUSD / ETH UMA / ETH UNI / ETH USDC / ETH USDT / ETH UST / ETH WNXM / ETH WOM / ETH YFI / ETH YFII / ETH ZRX / ETH","title":"Fee System"},{"location":"conveyor/conveyorv1/fee/#fee-system","text":"","title":"Fee System"},{"location":"conveyor/conveyorv1/fee/#overview","text":"1) The user submits a request to the Geode to perform a transaction. For example, swapping 100 gUSDC for 100 gDAI. swapExactTokensForTokens() Transitioning to Step 2: The Geode verifies that the amount of input token (USDC) is sufficient to pay for gas. The Geode can do this by simply calling the getPrice() method from Fee.sol to get USDC/ETH price in 18 decimals. For example, 1 USDC = 0.000361 ETH would yield 361000000000000. After Geode confirmed the user meets the minimum fee requirement, see step 2. 2) The Geode estimates the gas limit and the gas price. The Controller would capture this information to perform another input token check on step 3. 3) After the Controller finalizes the gas fee check, the Controller sends the transaction to UniswapRouter02 to perform the swap. The Geode would pay the gas fee \"out of pocket\" here, to be reimbursed later on step 4. Then, calculates the actual amount of gas consumption at this point. 4) Let's say the fast gas price is 49 gWei, with an average gas limit of 200,000 to perform a swap, the total gas fee (at the time of writing this) is 0.0098 ETH. The Controller then automatically allocates 25.48 gDAI to reimburse the Geode (or locks it in the contract itself). The user gets the remaining 74.52 gDAI.","title":"Overview:"},{"location":"conveyor/conveyorv1/fee/#price-feed-oracles-that-are-available-on-chainlink","text":"Click here to find the oracle addresses for the following exchange rates.","title":"Price Feed oracles that are available on Chainlink"},{"location":"conveyor/conveyorv1/fee/#ethereum-mainnet","text":"1INCH / ETH AAVE / ETH ALPHA / ETH AMPL / ETH ANT / ETH BADGER / ETH BAL / ETH BAND / ETH BAT / ETH BNB / ETH BNT / ETH BTC / ETH BUSD / ETH BZRX / ETH CEL / ETH COMP / ETH COVER / ETH CREAM / ETH CRO / ETH CRV / ETH DAI / ETH DPI / ETH ENJ / ETH FIL / ETH FTM / ETH FTT / ETH GRT / ETH HEGIC / ETH HUSD / ETH KNC / ETH KP3R / ETH LINK / ETH LON / ETH LRC / ETH MANA / ETH MKR / ETH MLN / ETH MTA / ETH NMR / ETH OCEAN / ETH OGN / ETH OMG / ETH ORN / ETH PAX / ETH PAXG / ETH PERP / ETH RAI / ETH RARI / ETH REN / ETH REP / ETH RGT / ETH RLC / ETH RUNE / ETH SFI / ETH SNX / ETH SRM / ETH SUSD / ETH SUSHI / ETH TUSD / ETH UMA / ETH UNI / ETH USDC / ETH USDT / ETH UST / ETH WNXM / ETH WOM / ETH YFI / ETH YFII / ETH ZRX / ETH","title":"Ethereum Mainnet"},{"location":"conveyor/conveyorv2/design/","text":"ConveyorV2 Design \u00b6 Summary \u00b6 ConveyorV2 is an upgrade of Automata's ConveyorV1 to support a better user experience. Tokens that are traded in the ConveyorV2 liquidity pools enjoy the MEV protection and transaction ordering enforcement capabilities without the need to wrap existing ERC20 tokens into gTokens. Similar with ConveyorV1 (formerly known as GTokens), users must sign an EIP712 message to authorize Geode to submit a transaction on the user's behalf. Users would still enjoy the benefit of gasless trading, meaning they are not required to hold native tokens like MATIC or BNB to pay for gas. However, users are subjected to pay a service fee with an acceptable form of ERC20 tokens, such as DAI, USDC or ATA tokens. Codebase \u00b6 The ConveyorV2 smart contracts are a fork of UniswapV2. To learn more about the DEX protocol, read the UniswapV2 docs . There are certain modifications applied to the contracts. Check out the next section for details. Comparison between the UniswapV2 Protocol and ConveyorV2 \u00b6 This section highlights the modification that has been applied to the DEX protocol contracts. ConveyorV2Pair \u00b6 The addition of the onlyRouter() modifier. This modifier guards the mint() , burn() and swap() methods, such that it is made callable by the Router contract only. This modifier is the most viable for enforcing MEV protection, because it prevents any other addresses from bypassing our relayers to perform sandwich attacks. ConveyorV2Factory \u00b6 The router() address variable, the ConveyorV2Pair contract uses this value to match with the caller address. If the caller address does not match with router() , then the pair contract rejects the transaction. Using this approach also allows the \"upgradeability\" of the router. After the deployment of a newer version of the Router contract, the owner of the DEX can invoke the setRouter() method to map it to the new router address. At this point, all existing pair contracts would only accept function calls from the new Router contract. ConveyorV2Router01 \u00b6 The ConveyorV2 router introduces the ability for gasless trading. The user signs the EIP712 message, which is then submitted to the trusted relayer. The trusted relayer then executes the executeMetaTx() method, and pays gas on the user's behalf. After completion of execution, the Forwarder contract collects a service fee from the user to compensate for gas. Check out the ERC20Forwarder section to learn more about the Forwarder contract. In an unlikely event when the relayer service is not available, the protocol owner can disable the meta-transaction functionality by invoking the metaSwitch() method to toggle the metaOnly modifier. This would allow users to directly interact with the router contract as a temporary workaround for such an extenuating circumstance. ERC20 Forwarder \u00b6 The gas forwarder contract enables meta-transaction executions, which allows gas relayers to be compensated for the gas payment with ERC20 tokens. The gas forwarder contract has the ability to calculate a better estimation of the actual gas usage, including transactions that are being reverted. This way, the relayers are only compensated for the equivalent amount of ERC20 token in gas usage. constructor() \u00b6 Initializes the contract and assigns msg.sender as the default feeHolder . The feeHolder is the recipient of the ERC20 fee payment. setConstantFee() \u00b6 function setConstantFee ( uint256 _newConstantFee ) public onlyOwner Updates the constantFee value, defaults at 21000. Requires owner() privilege. Parameter Type _newConstantFee uint256 constant gas limit value setTransferFee() \u00b6 function setTransferFee ( uint256 _newTransferFee ) public onlyOwner Updates the ERC20 transfer gas limit, the transferFee value, defaults at 65000. Requires owner() privilege. Parameter Type _newTransfeFee uint256 ERC20 transfer limit value setRelayer() \u00b6 function setRelayer ( address _relayer , bool _trusted ) public onlyOwner Assigns or revokes relayer role. Requires owner() privilege. Parameter Type _relayer address Relayer address _trusted bool True: grant authorization; false: revoke authorization setFeeHolder() \u00b6 function setFeeHolder ( address _feeHolder ) public onlyOwner Transfers feeHolder role over to the input address. Requires owner() privilege. Parameter Type _feeHolder address Fee holder address MetaTransaction \u00b6 struct MetaTransaction { address from ; address feeToken ; uint256 maxTokenAmount ; uint256 deadline ; uint256 nonce ; bytes data ; bytes32 hashedPayload ; } Parameter Type from address the user's address feeToken address The address of the ERC20 fee token maxAmountToken uint256 The maximum amount of fee tokens that the users are willing to pay for the meta-tx deadline uint256 Meta-transactions that are executed past the deadline will be reverted nonce uint256 Replay protection data bytes The encoded function data that is to be executed hashedPayload bytes32 EIP712-compliant hash struct executeMetaTx() \u00b6 function executeMetaTx ( MetaTransaction memory metatx , string memory domainName , uint256 tokenPricePerNativeToken , uint256 feeOffset , SIGNATURE_TYPE memory sig ) public relayerOnly This function executes the encoded function data, as defined in MetaTransaction.data . It calculates the amount of gas consumption within the enveloped function call and charges the user the fee amount that is based on the token/ETH price tokenPricePerNativeToken . This value is given by the Geode, calculated by an aggregation of token prices fetched from multiple sources. There are certain situations that could cause the transaction to revert, which the relayers will not be compensated for gas fee. The point of reverts are: Insufficient fee token balance Insufficient maxAmountToken Invalid EIP 712 signature Out of gas error Parameter Type metatx MetaTransaction The meta-transaction body domainName string The EIP712 domain name tokenPricePerNativeToken uint256 ERC20 token price per ETH feeOffset uint256 An additional amount of token to be taken into consideration when verifying the user's balance sig SIGNATURE_TYPR The user's EIP712 signature MetaStatus \u00b6 event MetaStatus ( address sender , bool success , string error ) The executeMetaTx logs the event to indicate the status of the meta-tx. Execution failure within the meta-tx will not cause the function to revert. To view the error logs of a meta transaction, the client can simply listen for the error message emitted by this event. Parameter Type sender address user address success bool status of the meta-tx error string reason of a reverted meta-tx","title":"ConveyorV2 Design"},{"location":"conveyor/conveyorv2/design/#conveyorv2-design","text":"","title":"ConveyorV2 Design"},{"location":"conveyor/conveyorv2/design/#summary","text":"ConveyorV2 is an upgrade of Automata's ConveyorV1 to support a better user experience. Tokens that are traded in the ConveyorV2 liquidity pools enjoy the MEV protection and transaction ordering enforcement capabilities without the need to wrap existing ERC20 tokens into gTokens. Similar with ConveyorV1 (formerly known as GTokens), users must sign an EIP712 message to authorize Geode to submit a transaction on the user's behalf. Users would still enjoy the benefit of gasless trading, meaning they are not required to hold native tokens like MATIC or BNB to pay for gas. However, users are subjected to pay a service fee with an acceptable form of ERC20 tokens, such as DAI, USDC or ATA tokens.","title":"Summary"},{"location":"conveyor/conveyorv2/design/#codebase","text":"The ConveyorV2 smart contracts are a fork of UniswapV2. To learn more about the DEX protocol, read the UniswapV2 docs . There are certain modifications applied to the contracts. Check out the next section for details.","title":"Codebase"},{"location":"conveyor/conveyorv2/design/#comparison-between-the-uniswapv2-protocol-and-conveyorv2","text":"This section highlights the modification that has been applied to the DEX protocol contracts.","title":"Comparison between the UniswapV2 Protocol and ConveyorV2"},{"location":"conveyor/conveyorv2/design/#conveyorv2pair","text":"The addition of the onlyRouter() modifier. This modifier guards the mint() , burn() and swap() methods, such that it is made callable by the Router contract only. This modifier is the most viable for enforcing MEV protection, because it prevents any other addresses from bypassing our relayers to perform sandwich attacks.","title":"ConveyorV2Pair"},{"location":"conveyor/conveyorv2/design/#conveyorv2factory","text":"The router() address variable, the ConveyorV2Pair contract uses this value to match with the caller address. If the caller address does not match with router() , then the pair contract rejects the transaction. Using this approach also allows the \"upgradeability\" of the router. After the deployment of a newer version of the Router contract, the owner of the DEX can invoke the setRouter() method to map it to the new router address. At this point, all existing pair contracts would only accept function calls from the new Router contract.","title":"ConveyorV2Factory"},{"location":"conveyor/conveyorv2/design/#conveyorv2router01","text":"The ConveyorV2 router introduces the ability for gasless trading. The user signs the EIP712 message, which is then submitted to the trusted relayer. The trusted relayer then executes the executeMetaTx() method, and pays gas on the user's behalf. After completion of execution, the Forwarder contract collects a service fee from the user to compensate for gas. Check out the ERC20Forwarder section to learn more about the Forwarder contract. In an unlikely event when the relayer service is not available, the protocol owner can disable the meta-transaction functionality by invoking the metaSwitch() method to toggle the metaOnly modifier. This would allow users to directly interact with the router contract as a temporary workaround for such an extenuating circumstance.","title":"ConveyorV2Router01"},{"location":"conveyor/conveyorv2/design/#erc20-forwarder","text":"The gas forwarder contract enables meta-transaction executions, which allows gas relayers to be compensated for the gas payment with ERC20 tokens. The gas forwarder contract has the ability to calculate a better estimation of the actual gas usage, including transactions that are being reverted. This way, the relayers are only compensated for the equivalent amount of ERC20 token in gas usage.","title":"ERC20 Forwarder"},{"location":"conveyor/conveyorv2/design/#constructor","text":"Initializes the contract and assigns msg.sender as the default feeHolder . The feeHolder is the recipient of the ERC20 fee payment.","title":"constructor()"},{"location":"conveyor/conveyorv2/design/#setconstantfee","text":"function setConstantFee ( uint256 _newConstantFee ) public onlyOwner Updates the constantFee value, defaults at 21000. Requires owner() privilege. Parameter Type _newConstantFee uint256 constant gas limit value","title":"setConstantFee()"},{"location":"conveyor/conveyorv2/design/#settransferfee","text":"function setTransferFee ( uint256 _newTransferFee ) public onlyOwner Updates the ERC20 transfer gas limit, the transferFee value, defaults at 65000. Requires owner() privilege. Parameter Type _newTransfeFee uint256 ERC20 transfer limit value","title":"setTransferFee()"},{"location":"conveyor/conveyorv2/design/#setrelayer","text":"function setRelayer ( address _relayer , bool _trusted ) public onlyOwner Assigns or revokes relayer role. Requires owner() privilege. Parameter Type _relayer address Relayer address _trusted bool True: grant authorization; false: revoke authorization","title":"setRelayer()"},{"location":"conveyor/conveyorv2/design/#setfeeholder","text":"function setFeeHolder ( address _feeHolder ) public onlyOwner Transfers feeHolder role over to the input address. Requires owner() privilege. Parameter Type _feeHolder address Fee holder address","title":"setFeeHolder()"},{"location":"conveyor/conveyorv2/design/#metatransaction","text":"struct MetaTransaction { address from ; address feeToken ; uint256 maxTokenAmount ; uint256 deadline ; uint256 nonce ; bytes data ; bytes32 hashedPayload ; } Parameter Type from address the user's address feeToken address The address of the ERC20 fee token maxAmountToken uint256 The maximum amount of fee tokens that the users are willing to pay for the meta-tx deadline uint256 Meta-transactions that are executed past the deadline will be reverted nonce uint256 Replay protection data bytes The encoded function data that is to be executed hashedPayload bytes32 EIP712-compliant hash struct","title":"MetaTransaction"},{"location":"conveyor/conveyorv2/design/#executemetatx","text":"function executeMetaTx ( MetaTransaction memory metatx , string memory domainName , uint256 tokenPricePerNativeToken , uint256 feeOffset , SIGNATURE_TYPE memory sig ) public relayerOnly This function executes the encoded function data, as defined in MetaTransaction.data . It calculates the amount of gas consumption within the enveloped function call and charges the user the fee amount that is based on the token/ETH price tokenPricePerNativeToken . This value is given by the Geode, calculated by an aggregation of token prices fetched from multiple sources. There are certain situations that could cause the transaction to revert, which the relayers will not be compensated for gas fee. The point of reverts are: Insufficient fee token balance Insufficient maxAmountToken Invalid EIP 712 signature Out of gas error Parameter Type metatx MetaTransaction The meta-transaction body domainName string The EIP712 domain name tokenPricePerNativeToken uint256 ERC20 token price per ETH feeOffset uint256 An additional amount of token to be taken into consideration when verifying the user's balance sig SIGNATURE_TYPR The user's EIP712 signature","title":"executeMetaTx()"},{"location":"conveyor/conveyorv2/design/#metastatus","text":"event MetaStatus ( address sender , bool success , string error ) The executeMetaTx logs the event to indicate the status of the meta-tx. Execution failure within the meta-tx will not cause the function to revert. To view the error logs of a meta transaction, the client can simply listen for the error message emitted by this event. Parameter Type sender address user address success bool status of the meta-tx error string reason of a reverted meta-tx","title":"MetaStatus"},{"location":"mev/examples/","text":"Attack Examples \u00b6 Front-Running \u00b6 Front-running is the process by which an adversary observes transactions on the network layer and then acts upon this information by, for instance, issuing a competing transaction, with the hope that this transaction is mined before a victim transaction e.g. Transaction A is broadcasted with a higher gas price than an already pending transaction B so that A gets mined before B. Sandwich Attacks \u00b6 Alice wants to buy a Token A on a Decentralised Exchange (DEX) that uses an automated market maker (AMM) model. An adversary which sees Alice\u2019s transaction can create two of its own transactions which it inserts before and after Alice\u2019s transaction (sandwiching it). The adversary\u2019s first transaction buys Token A, which pushes up the price for Alice\u2019s transaction, and then the third transaction is the adversary\u2019s transaction to sell Token A (now at a higher price) at a profit. Back-Running \u00b6 Back-running occurs when a transaction sender wishes to have their transaction ordered immediately after some unconfirmed \"target transaction\". Example: A back-running bot that back-runs new token listings. Bot monitors the Ethereum mempool for new pairs being created on Uniswap. If it finds a new pair the bot places a buy transaction immediately behind the initial liquidity. The bot swoops in and buys as many tokens as possible (but not all of them as there needs to be an opportunity for others to buy tokens as well).The bot then waits for the price to go up as other traders buy the token from Uniswap and proceeds to sell back the tokens at a higher price. The key in this strategy is to be the first to buy tokens, but only after the token has been launched. 1 In order to maximise their changes of being mined immediately after their target, a typical backrunner will send many identical transactions, with gas price identical to that of the target transaction, sometimes from different accounts, in order to increase the chances that one of their transactions is ordered after the target but before any competitor. Liquidations \u00b6 Back-running strategies also apply to liquidations whereby a transaction sender wishes to be the first to liquidate a loan right after a price oracle update (which will allow liquidation to be triggered). Fixed spread liquidation used by Compound, Aave, and dYdX allows a liquidator to purchase collateral at a fixed discount when repaying debt. Strategy 1 A detects a liquidation opportunity at block B (i.e., after the execution of B). A then issues a liquidation transaction T, which is expected to be mined in the next block B +1. A attempts to destructively front-run other competing liquidators by setting high transaction fees for his liquidation transaction T. Strategy 2 A observes a transaction T, which will create a liquidation opportunity (e.g., an oracle price update transaction which will render a collateralized debt liquidatable). A then back-runs T with a liquidation transaction T A to avoid the transaction fee bidding competition. The auction liquidation allows a liquidator to start an auction that lasts for a pre-configured period (e.g., 6 hours). Competing liquidators can engage and bid on the collateral price. Time-Bandit Attacks \u00b6 Time-bandit attacks are attacks where miners rewrite blockchain history to steal funds allocated by smart contracts in the past. If block rewards are small enough compared to MEV, it can be rational for miners to destabilize consensus. Imagine there are two miners, Sam and Dan, who are paid a $100 reward for each block they find. Sam has found 3 blocks, the first of which contained a $10,000 arbitrage opportunity. Now Dan has a choice: he can either mine on top of Sam\u2019s 3 blocks, or he can attempt to re-mine the first block in order to take the Uniswap arbitrage for himself. The $10,000 is much more lucrative than the $100 block reward, and Dan is more rational than honest, so he decides to re-mine the first block. While Dan\u2019s at it, since the current longest chain is height 3, he also re-mines the second and third blocks (and captures any MEV that was in those, too). After the re-organization, Dan owns the longest chain and he and Sam can progress from the third block. The Uncle Bandit Attack \u00b6 Bundles are groups of transactions Flashbots users submit. Those transactions must be included in the order submitted, and either the whole bundle is included, or nothing is. A bundle should never be split up. Robert Miller found that for a specific bundle, only the \"Buy\" part of a sandwich bundle submitted had landed on-chain, and right after that Buy someone else had inserted a 7 gas transaction that arbitraged it. How? In Ethereum occasionally two blocks are mined at roughly the same time, and only one block can be added to the chain. The other gets \"uncled\" or orphaned. Anyone can access transactions in an uncled block and some of the transactions may not have ended up in the non-uncled block. In a way some transactions end up in a sort of mempool like state: they are now public as a part of the uncled block and perhaps still valid too. A Sandwicher's bundle was included in an uncled block. An attacker saw this, grabbed only the Buy part of the Sandwich, threw away the rest, and added an arbitrage after. The attacker then submitted that as a bundle, which was then mined. Instead of seeing something late in time and rewinding it (time-bandit attack), the uncle bandit attack is when an attacker sees something in an uncle and brings it forward. This also shows that attacks extend beyond the mempool and into uncled blocks as well. https://amanusk.medium.com/the-fastest-draw-on-the-blockchain-bzrx-example-6bd19fabdbe1 \u21a9","title":"Attack Examples"},{"location":"mev/examples/#attack-examples","text":"","title":"Attack Examples"},{"location":"mev/examples/#front-running","text":"Front-running is the process by which an adversary observes transactions on the network layer and then acts upon this information by, for instance, issuing a competing transaction, with the hope that this transaction is mined before a victim transaction e.g. Transaction A is broadcasted with a higher gas price than an already pending transaction B so that A gets mined before B.","title":"Front-Running"},{"location":"mev/examples/#sandwich-attacks","text":"Alice wants to buy a Token A on a Decentralised Exchange (DEX) that uses an automated market maker (AMM) model. An adversary which sees Alice\u2019s transaction can create two of its own transactions which it inserts before and after Alice\u2019s transaction (sandwiching it). The adversary\u2019s first transaction buys Token A, which pushes up the price for Alice\u2019s transaction, and then the third transaction is the adversary\u2019s transaction to sell Token A (now at a higher price) at a profit.","title":"Sandwich Attacks"},{"location":"mev/examples/#back-running","text":"Back-running occurs when a transaction sender wishes to have their transaction ordered immediately after some unconfirmed \"target transaction\". Example: A back-running bot that back-runs new token listings. Bot monitors the Ethereum mempool for new pairs being created on Uniswap. If it finds a new pair the bot places a buy transaction immediately behind the initial liquidity. The bot swoops in and buys as many tokens as possible (but not all of them as there needs to be an opportunity for others to buy tokens as well).The bot then waits for the price to go up as other traders buy the token from Uniswap and proceeds to sell back the tokens at a higher price. The key in this strategy is to be the first to buy tokens, but only after the token has been launched. 1 In order to maximise their changes of being mined immediately after their target, a typical backrunner will send many identical transactions, with gas price identical to that of the target transaction, sometimes from different accounts, in order to increase the chances that one of their transactions is ordered after the target but before any competitor.","title":"Back-Running"},{"location":"mev/examples/#liquidations","text":"Back-running strategies also apply to liquidations whereby a transaction sender wishes to be the first to liquidate a loan right after a price oracle update (which will allow liquidation to be triggered). Fixed spread liquidation used by Compound, Aave, and dYdX allows a liquidator to purchase collateral at a fixed discount when repaying debt. Strategy 1 A detects a liquidation opportunity at block B (i.e., after the execution of B). A then issues a liquidation transaction T, which is expected to be mined in the next block B +1. A attempts to destructively front-run other competing liquidators by setting high transaction fees for his liquidation transaction T. Strategy 2 A observes a transaction T, which will create a liquidation opportunity (e.g., an oracle price update transaction which will render a collateralized debt liquidatable). A then back-runs T with a liquidation transaction T A to avoid the transaction fee bidding competition. The auction liquidation allows a liquidator to start an auction that lasts for a pre-configured period (e.g., 6 hours). Competing liquidators can engage and bid on the collateral price.","title":"Liquidations"},{"location":"mev/examples/#time-bandit-attacks","text":"Time-bandit attacks are attacks where miners rewrite blockchain history to steal funds allocated by smart contracts in the past. If block rewards are small enough compared to MEV, it can be rational for miners to destabilize consensus. Imagine there are two miners, Sam and Dan, who are paid a $100 reward for each block they find. Sam has found 3 blocks, the first of which contained a $10,000 arbitrage opportunity. Now Dan has a choice: he can either mine on top of Sam\u2019s 3 blocks, or he can attempt to re-mine the first block in order to take the Uniswap arbitrage for himself. The $10,000 is much more lucrative than the $100 block reward, and Dan is more rational than honest, so he decides to re-mine the first block. While Dan\u2019s at it, since the current longest chain is height 3, he also re-mines the second and third blocks (and captures any MEV that was in those, too). After the re-organization, Dan owns the longest chain and he and Sam can progress from the third block.","title":"Time-Bandit Attacks"},{"location":"mev/examples/#the-uncle-bandit-attack","text":"Bundles are groups of transactions Flashbots users submit. Those transactions must be included in the order submitted, and either the whole bundle is included, or nothing is. A bundle should never be split up. Robert Miller found that for a specific bundle, only the \"Buy\" part of a sandwich bundle submitted had landed on-chain, and right after that Buy someone else had inserted a 7 gas transaction that arbitraged it. How? In Ethereum occasionally two blocks are mined at roughly the same time, and only one block can be added to the chain. The other gets \"uncled\" or orphaned. Anyone can access transactions in an uncled block and some of the transactions may not have ended up in the non-uncled block. In a way some transactions end up in a sort of mempool like state: they are now public as a part of the uncled block and perhaps still valid too. A Sandwicher's bundle was included in an uncled block. An attacker saw this, grabbed only the Buy part of the Sandwich, threw away the rest, and added an arbitrage after. The attacker then submitted that as a bundle, which was then mined. Instead of seeing something late in time and rewinding it (time-bandit attack), the uncle bandit attack is when an attacker sees something in an uncle and brings it forward. This also shows that attacks extend beyond the mempool and into uncled blocks as well. https://amanusk.medium.com/the-fastest-draw-on-the-blockchain-bzrx-example-6bd19fabdbe1 \u21a9","title":"The Uncle Bandit Attack"},{"location":"mev/introduction/","text":"Introduction \u00b6 Flashboys, Flashbots, Dark Forests and more.. This is a public resource for learning about Miner Extractable Value . We cover a range of topics including the key concepts, research on this the topic, different approaches to tackling this issue and also Automata Network's approach. Tip Find any errors? Click the icon on each page to contribute. Want to share your feedback? Contact us here . What is Miner Extractable Value? \u00b6 When one sends a transaction on the blockchain, there is a delay between the time when the transaction is broadcast to the network and when it is actually mined into a block. During this period, transactions sit in a pending transaction pool called the mempool where contents are visible to everyone. Arbitrageurs and miners can monitor the mempool and find opportunities to maximize their own profits e.g. by frontrunning transactions. If a front-runner is a miner, they can also reorder or even censor transactions. Miner Extractable Value refers to the amount of profit that can be extracted from reordering and censoring transactions on the blockchain. Why does this matter 1 ? \u00b6 MEV can harm users \u00b6 MEV is an invisible tax that miners can collect from users. MEV can destabilize Ethereum \u00b6 If block rewards are small enough compared to MEV, it can be rational for miners to destabilize consensus by reordering or censoring transactions. Just how bad is the problem? \u00b6 The Flashbots Dashboard tracks Extracted MEV over time. It is estimated that >$500M has been extracted since 1st January 2020. Dune Analytics tracks Gas consumption by back-running bots. According to https://research.paradigm.xyz/MEV \u21a9","title":"Introduction"},{"location":"mev/introduction/#introduction","text":"Flashboys, Flashbots, Dark Forests and more.. This is a public resource for learning about Miner Extractable Value . We cover a range of topics including the key concepts, research on this the topic, different approaches to tackling this issue and also Automata Network's approach. Tip Find any errors? Click the icon on each page to contribute. Want to share your feedback? Contact us here .","title":"Introduction"},{"location":"mev/introduction/#what-is-miner-extractable-value","text":"When one sends a transaction on the blockchain, there is a delay between the time when the transaction is broadcast to the network and when it is actually mined into a block. During this period, transactions sit in a pending transaction pool called the mempool where contents are visible to everyone. Arbitrageurs and miners can monitor the mempool and find opportunities to maximize their own profits e.g. by frontrunning transactions. If a front-runner is a miner, they can also reorder or even censor transactions. Miner Extractable Value refers to the amount of profit that can be extracted from reordering and censoring transactions on the blockchain.","title":"What is Miner Extractable Value?"},{"location":"mev/introduction/#why-does-this-matter1","text":"","title":"Why does this matter1?"},{"location":"mev/introduction/#mev-can-harm-users","text":"MEV is an invisible tax that miners can collect from users.","title":"MEV can harm users"},{"location":"mev/introduction/#mev-can-destabilize-ethereum","text":"If block rewards are small enough compared to MEV, it can be rational for miners to destabilize consensus by reordering or censoring transactions.","title":"MEV can destabilize Ethereum"},{"location":"mev/introduction/#just-how-bad-is-the-problem","text":"The Flashbots Dashboard tracks Extracted MEV over time. It is estimated that >$500M has been extracted since 1st January 2020. Dune Analytics tracks Gas consumption by back-running bots. According to https://research.paradigm.xyz/MEV \u21a9","title":"Just how bad is the problem?"},{"location":"mev/misc/","text":"Miscellaneous \u00b6 What Happens when Ethereum moves to Proof-of-Stake? \u00b6 The move from PoW to PoS consensus means the Ethereum network becomes secured by a set validators, who stake their ETH and vote on consensus, as opposed to miners who run mining equipment to solve for the proof of work. This change of consensus is set to happen likely some time in 2021. Some have suggested that this means Miner Extractable Value will become Validator Extractable Value. This is an ongoing discussion and you can follow this here https://hackmd.io/@flashbots/ryuH4gn7d From Paradigm's piece \"On Staking Pools and Staking Derivatives\" - Staking pools and their staking derivatives are subject to similar market realities as MEV extraction, in the sense that their existence is inevitable. Institutional staking pools (e.g. exchanges) may have social and reputational constraints that prevent them from extracting certain forms of MEV. This allows smaller staking firms and decentralized pools without these constraints to provide higher returns for their stakers. This could turn the decentralization premium for using a decentralized staking pool into a decentralization discount. https://research.paradigm.xyz/staking Other Academic Papers \u00b6 Tesseract Tesseract proposes a front-running resistant exchange relying on Intel SGX as a trusted execution environment. https://eprint.iacr.org/2017/1153.pdf Calypso Enables a blockchain to hold and manage secrets on-chain with the convenient property that it is able to protect against front-running. https://eprint.iacr.org/2018/209.pdf","title":"Miscellaneous"},{"location":"mev/misc/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"mev/misc/#what-happens-when-ethereum-moves-to-proof-of-stake","text":"The move from PoW to PoS consensus means the Ethereum network becomes secured by a set validators, who stake their ETH and vote on consensus, as opposed to miners who run mining equipment to solve for the proof of work. This change of consensus is set to happen likely some time in 2021. Some have suggested that this means Miner Extractable Value will become Validator Extractable Value. This is an ongoing discussion and you can follow this here https://hackmd.io/@flashbots/ryuH4gn7d From Paradigm's piece \"On Staking Pools and Staking Derivatives\" - Staking pools and their staking derivatives are subject to similar market realities as MEV extraction, in the sense that their existence is inevitable. Institutional staking pools (e.g. exchanges) may have social and reputational constraints that prevent them from extracting certain forms of MEV. This allows smaller staking firms and decentralized pools without these constraints to provide higher returns for their stakers. This could turn the decentralization premium for using a decentralized staking pool into a decentralization discount. https://research.paradigm.xyz/staking","title":"What Happens when Ethereum moves to Proof-of-Stake?"},{"location":"mev/misc/#other-academic-papers","text":"Tesseract Tesseract proposes a front-running resistant exchange relying on Intel SGX as a trusted execution environment. https://eprint.iacr.org/2017/1153.pdf Calypso Enables a blockchain to hold and manage secrets on-chain with the convenient property that it is able to protect against front-running. https://eprint.iacr.org/2018/209.pdf","title":"Other Academic Papers"},{"location":"mev/resource-list/","text":"Resource List \u00b6 Name Type What Is Miner-Extractable Value (MEV)? Article Miners, Front-Running-as-a-Service Is Theft Article MEV and Me Article Ethereum is a Dark Forest Article Escaping the Dark Forest Article Ethereum Blockspace: Who Gets What and Why Article The fastest draw on the Blockchain: Ethereum Backrunning Article Security of Interoperability Presentation Gas Wars: Understanding Ethereum's Mempool & Miner Extractable Value Podcast Smart Contract Security - Incentives Beyond the Launch by Phil Daian (Devcon4) Video Enter the Dark Forest: the terrifying world of MEV and Flash bots Video Frontrunning in Decentralized Exchanges, Miner Extractable Value, and Consensus Instability Video How To Get Front-Run on Ethereum mainnet Video Flash Boys 2.0: Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges Research Paper Quantifying Blockchain Extractable Value: How dark is the forest? Research Paper High-Frequency Trading on Decentralized On-Chain Exchanges Research Paper Frontrunner Jones and the Raiders of the Dark Forest: An Empirical Study of Frontrunning on the Ethereum Blockchain Research Paper","title":"Resource List"},{"location":"mev/resource-list/#resource-list","text":"Name Type What Is Miner-Extractable Value (MEV)? Article Miners, Front-Running-as-a-Service Is Theft Article MEV and Me Article Ethereum is a Dark Forest Article Escaping the Dark Forest Article Ethereum Blockspace: Who Gets What and Why Article The fastest draw on the Blockchain: Ethereum Backrunning Article Security of Interoperability Presentation Gas Wars: Understanding Ethereum's Mempool & Miner Extractable Value Podcast Smart Contract Security - Incentives Beyond the Launch by Phil Daian (Devcon4) Video Enter the Dark Forest: the terrifying world of MEV and Flash bots Video Frontrunning in Decentralized Exchanges, Miner Extractable Value, and Consensus Instability Video How To Get Front-Run on Ethereum mainnet Video Flash Boys 2.0: Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges Research Paper Quantifying Blockchain Extractable Value: How dark is the forest? Research Paper High-Frequency Trading on Decentralized On-Chain Exchanges Research Paper Frontrunner Jones and the Raiders of the Dark Forest: An Empirical Study of Frontrunning on the Ethereum Blockchain Research Paper","title":"Resource List"},{"location":"mev/terms-and-concepts/","text":"Terms and Concepts \u00b6 DeFi \u00b6 DeFi is a subset of finance-focused decentralized protocols that operate autonomously on blockchain-based smart contracts. The total value locked in DeFi amounts to >$50B USD 1 . Automated Market Maker \u00b6 A type of Decentralised Exchange. Contrary to traditional limit order-book-based exchanges (which maintain a list of bids and asks for an asset pair), AMM exchanges maintain a pool of capital (a liquidity pool) with at least two assets. A smart contract governs the rules by which traders can purchase and sell assets from the liquidity pool. The most common AMM mechanism is a constant product AMM, where the product of an asset \\(x\\) and asset \\(y\\) in a pool have to abide by a constant \\(k\\) . Examples of AMM Exchanges include Uniswap , Sushiswap , Balancer . Lending Platforms \u00b6 Debt is an essential tool in DeFi. As DeFi applications typically operate without Know Your Customer (KYC), the borrower\u2019s debt must be over-collateralized. Hence, a borrower must collateralize (lock) 150% of the value that the borrower wishes to lend out. The collateral acts as a security to the lender if the borrower doesn\u2019t pay back the debt. Examples of lending platforms include Aave and Compound . Arbitrage \u00b6 Arbitrage is the simultaneous purchase and sale of the same asset in different markets in order to profit from differences in the asset's listed price. Slippage \u00b6 Slippage is defined as the move in the price of a security between the time you decided to transact in it and the time your order was in the market. When performing a trade on an AMM, the expected execution price may differ from the real execution price because the expected price depends on a past blockchain state, which may change between the transaction creation and its execution \u2014 e.g., due to front-running transactions. Liquidations \u00b6 In Lending Platforms, if the collateral value decreases and the collateralization ratio falls below 150%, the collateral can be freed up for liquidation. Liquidators can then purchase the collateral at a discount to repay the debt. Priority gas auctions (PGAs) \u00b6 As pure arbitrage opportunities offer unconditional revenue, bots often compete against each other by bidding up transaction fees (gas) in PGAs which drives up fees for other users. Transaction Ordering \u00b6 Blockchains typically prescribe specific rules for consensus, but there are only loose requirements for miners on how to order transactions within a block. Many attacks are centered around how miners order transactions within blocks. https://defipulse.com/ \u21a9","title":"Terms and Concepts"},{"location":"mev/terms-and-concepts/#terms-and-concepts","text":"","title":"Terms and Concepts"},{"location":"mev/terms-and-concepts/#defi","text":"DeFi is a subset of finance-focused decentralized protocols that operate autonomously on blockchain-based smart contracts. The total value locked in DeFi amounts to >$50B USD 1 .","title":"DeFi"},{"location":"mev/terms-and-concepts/#automated-market-maker","text":"A type of Decentralised Exchange. Contrary to traditional limit order-book-based exchanges (which maintain a list of bids and asks for an asset pair), AMM exchanges maintain a pool of capital (a liquidity pool) with at least two assets. A smart contract governs the rules by which traders can purchase and sell assets from the liquidity pool. The most common AMM mechanism is a constant product AMM, where the product of an asset \\(x\\) and asset \\(y\\) in a pool have to abide by a constant \\(k\\) . Examples of AMM Exchanges include Uniswap , Sushiswap , Balancer .","title":"Automated Market Maker"},{"location":"mev/terms-and-concepts/#lending-platforms","text":"Debt is an essential tool in DeFi. As DeFi applications typically operate without Know Your Customer (KYC), the borrower\u2019s debt must be over-collateralized. Hence, a borrower must collateralize (lock) 150% of the value that the borrower wishes to lend out. The collateral acts as a security to the lender if the borrower doesn\u2019t pay back the debt. Examples of lending platforms include Aave and Compound .","title":"Lending Platforms"},{"location":"mev/terms-and-concepts/#arbitrage","text":"Arbitrage is the simultaneous purchase and sale of the same asset in different markets in order to profit from differences in the asset's listed price.","title":"Arbitrage"},{"location":"mev/terms-and-concepts/#slippage","text":"Slippage is defined as the move in the price of a security between the time you decided to transact in it and the time your order was in the market. When performing a trade on an AMM, the expected execution price may differ from the real execution price because the expected price depends on a past blockchain state, which may change between the transaction creation and its execution \u2014 e.g., due to front-running transactions.","title":"Slippage"},{"location":"mev/terms-and-concepts/#liquidations","text":"In Lending Platforms, if the collateral value decreases and the collateralization ratio falls below 150%, the collateral can be freed up for liquidation. Liquidators can then purchase the collateral at a discount to repay the debt.","title":"Liquidations"},{"location":"mev/terms-and-concepts/#priority-gas-auctions-pgas","text":"As pure arbitrage opportunities offer unconditional revenue, bots often compete against each other by bidding up transaction fees (gas) in PGAs which drives up fees for other users.","title":"Priority gas auctions (PGAs)"},{"location":"mev/terms-and-concepts/#transaction-ordering","text":"Blockchains typically prescribe specific rules for consensus, but there are only loose requirements for miners on how to order transactions within a block. Many attacks are centered around how miners order transactions within blocks. https://defipulse.com/ \u21a9","title":"Transaction Ordering"},{"location":"mev/trick-the-bots/","text":"Attempts to Trick Bots \u00b6 Salmonella \u00b6 Salmonella intentionally exploits the generalised nature of front-running setups. The goal of sandwich trading is to exploit the slippage of unintended victims, so this strategy turns the tables on the exploiters. It\u2019s a regular ERC20 token, which behaves exactly like any other ERC20 token in normal use-cases. However, it has some special logic to detect when anyone other than the specified owner is transacting it, and in these situations it only returns 10% of the specified amount - despite emitting event logs which match a trade of the full amount. Kattana \u00b6 The Kattana team included a trap for front-running bots during their token listing. There is a line in the code that disallows the front-runner from selling all tokens. So a front-runner paid 68 ETH to the miner and ended up with tokens he wasn't able to sell. Another attempt to trick bots \u00b6 Background \u00b6 Instead of users paying transaction fees via gas prices, Flashbots users pay fees via a smart contract call which transfers ETH to a miner. Miners receive bundles of transaction from users and include the bundle that pays them the most. Users love this because they only pay for transactions that are included and they can determine the fee that they are going to pay. Sandwich bots watch the mempool for users buying on DEXes and sandwich them: running the price up before the victim buys and dumping after for a profit. Those 3 txs (buy, victim transaction, sell) make up a bundle. Note the Sandwich sell transaction contains the smart contract payment to the miner. It's important that payment goes to the miner on the sell transaction! That should only happen after the bot has secured profit from selling the tokens bought in their front-run. If that sell fails then there is no payment to the miner, and thus their bundle shouldn't be included To be even more secure, bots will simulate their transactions on local infrastructure. Bots won't send transactions unless the simulation goes well. Paying transaction fees only on the sell transaction of a sandwich should defend against this. No profit, no payment. Simulation vs Reality \u00b6 Some really smart people found weaknesses among all of these defenses. The first defense was that simulation was done with an ERC20 transfer function that checked to see if the block was a mined by Flashbots' miners, and if so it transfers way less out. Local simulations look fine but do not work in production. The second defense - Payment only on a sell transaction \u00b6 Again: Sandwich bots make miner payment conditional on profit. That was broken by making the ERC20 token pay the miner. Thus even with the Sandwich bot sell failing, the miner would still get paid! Here's what actually happened: Sandwich bot gets baited and buys 100 ETH of the poisonous token. Poisonous token owner's bait triggers custom transfer function, which pays 0.1 ETH to the miner Sandwich bot's sell doesn't work because of the poisonous token. As the sandwich bot submitted these three transactions in a bundle all three were included: the successful buy, the bait, and the failed sell. The poisonous ERC20's payment via the custom transfer was what incentivized a miner to include it! It is estimated that the first person to do this made about 100 ETH. You can see the poisoned ERC20 Uniswap transactions here . From Victim to Predator \u00b6 One of their victims was one the most successful Flashbots bot operators, and they immediately sprung into action. In a short period of time the victim turned into an apex predator. They launched a similar but slightly different ERC20 (YOLOchain), and ended up successfully baiting many more sandwichers. They made 300 ETH doing so!","title":"Attempts to Trick the Bots"},{"location":"mev/trick-the-bots/#attempts-to-trick-bots","text":"","title":"Attempts to Trick Bots"},{"location":"mev/trick-the-bots/#salmonella","text":"Salmonella intentionally exploits the generalised nature of front-running setups. The goal of sandwich trading is to exploit the slippage of unintended victims, so this strategy turns the tables on the exploiters. It\u2019s a regular ERC20 token, which behaves exactly like any other ERC20 token in normal use-cases. However, it has some special logic to detect when anyone other than the specified owner is transacting it, and in these situations it only returns 10% of the specified amount - despite emitting event logs which match a trade of the full amount.","title":"Salmonella"},{"location":"mev/trick-the-bots/#kattana","text":"The Kattana team included a trap for front-running bots during their token listing. There is a line in the code that disallows the front-runner from selling all tokens. So a front-runner paid 68 ETH to the miner and ended up with tokens he wasn't able to sell.","title":"Kattana"},{"location":"mev/trick-the-bots/#another-attempt-to-trick-bots","text":"","title":"Another attempt to trick bots"},{"location":"mev/trick-the-bots/#background","text":"Instead of users paying transaction fees via gas prices, Flashbots users pay fees via a smart contract call which transfers ETH to a miner. Miners receive bundles of transaction from users and include the bundle that pays them the most. Users love this because they only pay for transactions that are included and they can determine the fee that they are going to pay. Sandwich bots watch the mempool for users buying on DEXes and sandwich them: running the price up before the victim buys and dumping after for a profit. Those 3 txs (buy, victim transaction, sell) make up a bundle. Note the Sandwich sell transaction contains the smart contract payment to the miner. It's important that payment goes to the miner on the sell transaction! That should only happen after the bot has secured profit from selling the tokens bought in their front-run. If that sell fails then there is no payment to the miner, and thus their bundle shouldn't be included To be even more secure, bots will simulate their transactions on local infrastructure. Bots won't send transactions unless the simulation goes well. Paying transaction fees only on the sell transaction of a sandwich should defend against this. No profit, no payment.","title":"Background"},{"location":"mev/trick-the-bots/#simulation-vs-reality","text":"Some really smart people found weaknesses among all of these defenses. The first defense was that simulation was done with an ERC20 transfer function that checked to see if the block was a mined by Flashbots' miners, and if so it transfers way less out. Local simulations look fine but do not work in production.","title":"Simulation vs Reality"},{"location":"mev/trick-the-bots/#the-second-defense-payment-only-on-a-sell-transaction","text":"Again: Sandwich bots make miner payment conditional on profit. That was broken by making the ERC20 token pay the miner. Thus even with the Sandwich bot sell failing, the miner would still get paid! Here's what actually happened: Sandwich bot gets baited and buys 100 ETH of the poisonous token. Poisonous token owner's bait triggers custom transfer function, which pays 0.1 ETH to the miner Sandwich bot's sell doesn't work because of the poisonous token. As the sandwich bot submitted these three transactions in a bundle all three were included: the successful buy, the bait, and the failed sell. The poisonous ERC20's payment via the custom transfer was what incentivized a miner to include it! It is estimated that the first person to do this made about 100 ETH. You can see the poisoned ERC20 Uniswap transactions here .","title":"The second defense - Payment only on a sell transaction"},{"location":"mev/trick-the-bots/#from-victim-to-predator","text":"One of their victims was one the most successful Flashbots bot operators, and they immediately sprung into action. In a short period of time the victim turned into an apex predator. They launched a similar but slightly different ERC20 (YOLOchain), and ended up successfully baiting many more sandwichers. They made 300 ETH doing so!","title":"From Victim to Predator"},{"location":"mev/solutions/approaches/","text":"Different approaches to tackling the MEV problem \u00b6 There are largely 2 schools of thought when it comes to approaching the MEV problem Offense - MEV is here to stay so let's find a way to extract and democratize it. Defense - MEV is bad so let's try to prevent it. As such we have put approaches into 2 categories Front-running as a Service (FaaS) or MEV Auctions (MEVA) MEV Minimization/Prevention At Automata Network we are in the Defense camp. Our solution Conveyor ingests transactions and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering.","title":"Different Approaches"},{"location":"mev/solutions/approaches/#different-approaches-to-tackling-the-mev-problem","text":"There are largely 2 schools of thought when it comes to approaching the MEV problem Offense - MEV is here to stay so let's find a way to extract and democratize it. Defense - MEV is bad so let's try to prevent it. As such we have put approaches into 2 categories Front-running as a Service (FaaS) or MEV Auctions (MEVA) MEV Minimization/Prevention At Automata Network we are in the Defense camp. Our solution Conveyor ingests transactions and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering.","title":"Different approaches to tackling the MEV problem"},{"location":"mev/solutions/faas-or-meva/","text":"Front-running as a Service (FaaS) or MEV Auctions (MEVA) \u00b6 In a FaaS or MEVA system, MEV is extracted in a variety of ways such as miners auctioning off the right to front-run users. Vitalik Buterin - Centralizing MEV extraction is good because it quarantines a revenue stream that could otherwise drive centralization in other sectors. Phil Daian, co-author of Flash Boys 2.0 - In this article, I\u2019m going to go deep into my personal arguments for why extracting MEV in cryptocurrencies isn\u2019t like theft, why it is a critical metric for network security in any distributed system secured by economic incentives (yes, including centralized ones), and what we should do about MEV in the next 3-5 years as a community. Private Transactions \u00b6 Typically, transactions are broadcast to the mempool where they remain pending until miners pick them and add to the block. Private transactions however, are only visible to the pool and are not broadcast to other nodes (pay more for faster transactions). Examples include 1inch Exchange's Stealth Transactions , Taichi Network and BloXroute . Private Transactions offered by Taichi Network bloXroute Labs has a wide range of offerings and their core competency is low global latency for DeFi (8% of blocks mined within 1 sec). Note For the other side of the coin, here is bloXroute Labs' take on why private mempools are not necessarily bad 1 : Front-runners don't need these services to outpace regular users, who are slower by seconds. They need it to outpace one another, where improving speed 0.8->0.15 sec matters. When a transaction is privately sent to pools other frontrunners can't attempt to front-run it. This helps avoid fierce escalation of fees. Links https://docs.bloxroute.com/apis/frontrunning-protection BackRunMe by bloXroute \u00b6 BackRunMe is a service that allows users to submit private transactions (e.g. protection against frontrunning and sandwich attacks) while allowing searchers to backrun the transaction via MEV IF it produces an arbitrage profit. If it doesn't generate an arbitrage profit it is processed as a regular private transaction. BackRunMe, gives a portion of this additional profit back to the user. The profit sharing ratio is as follows: 50% to miners, 25% to users, 20% to searchers and 5% to bloXroute. Users can use MetaMask directly on BackRunMe to trade on Uniswap or Sushiswap. Links https://backrunme.com/#/swap https://medium.com/bloxroute/there-is-light-in-the-dark-forest-2d7b77f4ca2d Flashbots \u00b6 Flashbots is a research and development organization formed to mitigate the negative externalities and existential risks posed by MEV. They aim to Democratize MEV Extraction through MEV-Geth, which enables a sealed-bid block space auction mechanism for communicating transaction order preference. ELI5 https://twitter.com/_silto_/status/1381292907567722498 Flashbots created an ETH node for miners, that not only watches the mempool like any other node, but also connects to a relayer (a server) operated by Flashbots. This MEV-Relay is a kind of parallel channel that directly connects miners to bots that want their transactions included. The transactions that the bots want to include are sent through the MEV-Relay as bundles containing: the transactions to execute a tip to the miner, coming as an ETH transfer These transactions use a 0 gwei gas price, as the payment to the miner is included in the transaction itself as the tip. Since these transactions are sent through a parallel private relay, it reduces the mempool bidding war, failed transactions bloating the blockchain, and overall gas cost for users. Links GitHub: https://github.com/flashbots Research: https://github.com/flashbots/mev-research Monthly Meetings: https://github.com/flashbots/pm API: https://blocks.flashbots.net/ Discord: https://discord.gg/7hvTycdNcK Medium: https://medium.com/flashbots https://medium.com/flashbots/frontrunning-the-mev-crisis-40629a613752 https://medium.com/flashbots/quantifying-mev-introducing-mev-explore-v0-5ccbee0f6d02 https://ethresear.ch/t/flashbots-frontrunning-the-mev-crisis/8251 mistX by alchemist \u00b6 mistX is a DEX that enables end users to send transactions through Flashbots bundles. All transactions are gasless. However, instead of paying gas to the miners mistX users pay miners a bribe/tip in ETH. The tip is either included in the trade or comes from the user's wallet. The exchange utilises Flashbots and as such transactions processed via mistX do not publish user transaction information to a public mempool, but instead bundle transactions together. This hides the information from front-runners and thus prevents transactions from being manipulated, front-run, or sandwiched. Links https://app.mistx.io/#/exchange KeeperDAO \u00b6 KeeperDAO is similar to a mining pool for Keepers. By incentivizing a game theory optimal strategy for cooperation among on-chain arbitrageurs, KeeperDAO provides an efficient mechanism for large scale arbitrage and liquidation trades on all DeFi protocols. The Hiding Game \u00b6 One of the 3 games that has been built. The Hiding Game refers to the cooperation between users and keepers to \u201chide\u201d MEV by wrapping trades/debt in specialised on-chain contracts. These contracts restrict profit extracting opportunities to KeeperDAO itself. Here's the ELI5 \u00b6 Users route their trades and loans through KeeperDAO, which attempts to extract any arbitrage or liquidation profit available. Those profits are returned back to the user in $ROOK tokens, and profits go into a pool controlled by $ROOK holders. By giving KeeperDAO priority access to arbitrage and liquidations, the Hiding Game maximizes the profits available from these opportunities. kCompound (Phase 2 of the Hiding Game) \u00b6 kCompound is the second phase of the Hiding Game. KeeperDAO posts collateral to save your position from being publicly liquidated. Instead, you get privately liquidated. KeeperDAO keeper will then find the best price for your collateral, targeting a 5% profit margin. This profit will then be split between you, the keeper, and the KeeperDAO treasury, meaning that kCompound borrowers will receive a portion of the profits from their own liquidation. Links https://keeperdao.com/#/ Wiki: https://github.com/keeperdao/docs/wiki kCompound: https://medium.com/keeperdao/introducing-kcompound-a23511c847a0 ArcherSwap \u00b6 Archerswap is a new DEX extension for Uniswap and Sushiswap that prevents frontrunning and offers traders zero slippage and zero cost cancellation swaps. This enables users to set slippage tolerance to 0%. Miners will only be paid if \"acceptance criteria\" are met, so any transaction that fails is not included on chain. One is for searchers to submit Flashbots-compatible bundles. The other is the Archer Relay Network (powers Archerswap) where users can submit private transactions and be protected from malicious MEV. Links https://swap.archerdao.io/#/swap Optimism \u00b6 Optimism are the original proposers of MEVA. MEV Auction (MEVA) is created in which the winner of the auction has the right to reorder submitted transactions and insert their own, as long as they do not delay any specific transaction by more than N blocks. Implementing the Auction \u00b6 The auction is able to extract MEV from miners by separating two functions 1) Transaction inclusion; and 2) transaction ordering. In order to implement MEVA roles are defined. Block producers determine transaction inclusion, and Sequencers determine transaction ordering. Block producers - Transaction Inclusion \u00b6 Block proposers are most analogous to traditional blockchain miners. Instead of proposing blocks with an ordering, they simply propose a set of transactions to eventually be included before N blocks. Sequencers - Transaction Ordering \u00b6 Sequencers are elected by a smart contract managed auction run by the block producers called the MEVA contract. This auction assigns the right to sequence the last N transactions. If, within a timeout the sequencer has not submitted an ordering which is included by block proposers, a new sequencer is elected. Implementation on Layer 2 \u00b6 It is possible to enshrine this MEVA contract directly on layer 1 (L1) blockchain consensus protocols. However, it is also possible to non-invasively add this mechanism in layer 2 (L2) and use it to manage Optimistic Rollup transactio ordering. In L2, L1 miners are repurposed and utilized as block proposers. MEVA contract is implemented and designated a single sequencer at a time. Links https://optimism.io/ https://ethresear.ch/t/mev-auction-auctioning-transaction-ordering-rights-as-a-solution-to-miner-extractable-value/6788 https://docs.google.com/presentation/d/1RaF1byflrLF3yUjd-5vXDZB1ZIRofVeK3JYVD6NPr30/edit#slide=id.gc9bdacc472_0_96 MiningDAO \u00b6 MiningDAO is building a decentralized and transparent protocol for block formation that aims to pass 100% of MEV to miners. Anyone with an Ethereum address can propose the next block to be mined (via a block sealhash), and attach a bounty for successfully mining it. The mining pools would then mine on the highest-bounty proposal. One is for searchers to submit Flashbots-compatible bundles. The other is the Archer Relay Network (powers Archerswap) where users can submit private transactions and be protected from malicious MEV. Links https://miningdao.io https://medium.com/mining-dao/introducing-miningdao-1e469626f7ad BackBone Cabal \u00b6 BackBone Cabal is a strategy that aims to extract MEV from SushiSwap. Profits are redistributed back to users who submitted trades in the first place in the form of eliminating their transaction cost (up to 90%). YCabal creates a virtualized mempool (i.e. a MEV-relay network) that aggregates transactions (batching). Users are able to opt in and send transactions to YCabal and in return for not having to pay for gas for their transaction, YCabal batch processes it and takes the arbitrage profit. Risk by inventory price risk is carried by a Vault, where Vault depositers are returned the profit the YCabal realizes. Links https://backbonecabal.com/ Knowledge Base: https://backbone-kb.netlify.app/ SushiSwap Proposal: https://forum.sushiswapclassic.org/t/proposal-ycabal-mev-strategy/3159 https://twitter.com/bloXrouteLabs/status/1357026919905173509 \u21a9","title":"FaaS or MEVA"},{"location":"mev/solutions/faas-or-meva/#front-running-as-a-service-faas-or-mev-auctions-meva","text":"In a FaaS or MEVA system, MEV is extracted in a variety of ways such as miners auctioning off the right to front-run users. Vitalik Buterin - Centralizing MEV extraction is good because it quarantines a revenue stream that could otherwise drive centralization in other sectors. Phil Daian, co-author of Flash Boys 2.0 - In this article, I\u2019m going to go deep into my personal arguments for why extracting MEV in cryptocurrencies isn\u2019t like theft, why it is a critical metric for network security in any distributed system secured by economic incentives (yes, including centralized ones), and what we should do about MEV in the next 3-5 years as a community.","title":"Front-running as a Service (FaaS) or MEV Auctions (MEVA)"},{"location":"mev/solutions/faas-or-meva/#private-transactions","text":"Typically, transactions are broadcast to the mempool where they remain pending until miners pick them and add to the block. Private transactions however, are only visible to the pool and are not broadcast to other nodes (pay more for faster transactions). Examples include 1inch Exchange's Stealth Transactions , Taichi Network and BloXroute . Private Transactions offered by Taichi Network bloXroute Labs has a wide range of offerings and their core competency is low global latency for DeFi (8% of blocks mined within 1 sec). Note For the other side of the coin, here is bloXroute Labs' take on why private mempools are not necessarily bad 1 : Front-runners don't need these services to outpace regular users, who are slower by seconds. They need it to outpace one another, where improving speed 0.8->0.15 sec matters. When a transaction is privately sent to pools other frontrunners can't attempt to front-run it. This helps avoid fierce escalation of fees. Links https://docs.bloxroute.com/apis/frontrunning-protection","title":"Private Transactions"},{"location":"mev/solutions/faas-or-meva/#backrunme-by-bloxroute","text":"BackRunMe is a service that allows users to submit private transactions (e.g. protection against frontrunning and sandwich attacks) while allowing searchers to backrun the transaction via MEV IF it produces an arbitrage profit. If it doesn't generate an arbitrage profit it is processed as a regular private transaction. BackRunMe, gives a portion of this additional profit back to the user. The profit sharing ratio is as follows: 50% to miners, 25% to users, 20% to searchers and 5% to bloXroute. Users can use MetaMask directly on BackRunMe to trade on Uniswap or Sushiswap. Links https://backrunme.com/#/swap https://medium.com/bloxroute/there-is-light-in-the-dark-forest-2d7b77f4ca2d","title":"BackRunMe by bloXroute"},{"location":"mev/solutions/faas-or-meva/#flashbots","text":"Flashbots is a research and development organization formed to mitigate the negative externalities and existential risks posed by MEV. They aim to Democratize MEV Extraction through MEV-Geth, which enables a sealed-bid block space auction mechanism for communicating transaction order preference. ELI5 https://twitter.com/_silto_/status/1381292907567722498 Flashbots created an ETH node for miners, that not only watches the mempool like any other node, but also connects to a relayer (a server) operated by Flashbots. This MEV-Relay is a kind of parallel channel that directly connects miners to bots that want their transactions included. The transactions that the bots want to include are sent through the MEV-Relay as bundles containing: the transactions to execute a tip to the miner, coming as an ETH transfer These transactions use a 0 gwei gas price, as the payment to the miner is included in the transaction itself as the tip. Since these transactions are sent through a parallel private relay, it reduces the mempool bidding war, failed transactions bloating the blockchain, and overall gas cost for users. Links GitHub: https://github.com/flashbots Research: https://github.com/flashbots/mev-research Monthly Meetings: https://github.com/flashbots/pm API: https://blocks.flashbots.net/ Discord: https://discord.gg/7hvTycdNcK Medium: https://medium.com/flashbots https://medium.com/flashbots/frontrunning-the-mev-crisis-40629a613752 https://medium.com/flashbots/quantifying-mev-introducing-mev-explore-v0-5ccbee0f6d02 https://ethresear.ch/t/flashbots-frontrunning-the-mev-crisis/8251","title":"Flashbots"},{"location":"mev/solutions/faas-or-meva/#mistx-by-alchemist","text":"mistX is a DEX that enables end users to send transactions through Flashbots bundles. All transactions are gasless. However, instead of paying gas to the miners mistX users pay miners a bribe/tip in ETH. The tip is either included in the trade or comes from the user's wallet. The exchange utilises Flashbots and as such transactions processed via mistX do not publish user transaction information to a public mempool, but instead bundle transactions together. This hides the information from front-runners and thus prevents transactions from being manipulated, front-run, or sandwiched. Links https://app.mistx.io/#/exchange","title":"mistX by alchemist"},{"location":"mev/solutions/faas-or-meva/#keeperdao","text":"KeeperDAO is similar to a mining pool for Keepers. By incentivizing a game theory optimal strategy for cooperation among on-chain arbitrageurs, KeeperDAO provides an efficient mechanism for large scale arbitrage and liquidation trades on all DeFi protocols.","title":"KeeperDAO"},{"location":"mev/solutions/faas-or-meva/#the-hiding-game","text":"One of the 3 games that has been built. The Hiding Game refers to the cooperation between users and keepers to \u201chide\u201d MEV by wrapping trades/debt in specialised on-chain contracts. These contracts restrict profit extracting opportunities to KeeperDAO itself.","title":"The Hiding Game"},{"location":"mev/solutions/faas-or-meva/#heres-the-eli5","text":"Users route their trades and loans through KeeperDAO, which attempts to extract any arbitrage or liquidation profit available. Those profits are returned back to the user in $ROOK tokens, and profits go into a pool controlled by $ROOK holders. By giving KeeperDAO priority access to arbitrage and liquidations, the Hiding Game maximizes the profits available from these opportunities.","title":"Here's the ELI5"},{"location":"mev/solutions/faas-or-meva/#kcompound-phase-2-of-the-hiding-game","text":"kCompound is the second phase of the Hiding Game. KeeperDAO posts collateral to save your position from being publicly liquidated. Instead, you get privately liquidated. KeeperDAO keeper will then find the best price for your collateral, targeting a 5% profit margin. This profit will then be split between you, the keeper, and the KeeperDAO treasury, meaning that kCompound borrowers will receive a portion of the profits from their own liquidation. Links https://keeperdao.com/#/ Wiki: https://github.com/keeperdao/docs/wiki kCompound: https://medium.com/keeperdao/introducing-kcompound-a23511c847a0","title":"kCompound (Phase 2 of the Hiding Game)"},{"location":"mev/solutions/faas-or-meva/#archerswap","text":"Archerswap is a new DEX extension for Uniswap and Sushiswap that prevents frontrunning and offers traders zero slippage and zero cost cancellation swaps. This enables users to set slippage tolerance to 0%. Miners will only be paid if \"acceptance criteria\" are met, so any transaction that fails is not included on chain. One is for searchers to submit Flashbots-compatible bundles. The other is the Archer Relay Network (powers Archerswap) where users can submit private transactions and be protected from malicious MEV. Links https://swap.archerdao.io/#/swap","title":"ArcherSwap"},{"location":"mev/solutions/faas-or-meva/#optimism","text":"Optimism are the original proposers of MEVA. MEV Auction (MEVA) is created in which the winner of the auction has the right to reorder submitted transactions and insert their own, as long as they do not delay any specific transaction by more than N blocks.","title":"Optimism"},{"location":"mev/solutions/faas-or-meva/#implementing-the-auction","text":"The auction is able to extract MEV from miners by separating two functions 1) Transaction inclusion; and 2) transaction ordering. In order to implement MEVA roles are defined. Block producers determine transaction inclusion, and Sequencers determine transaction ordering.","title":"Implementing the Auction"},{"location":"mev/solutions/faas-or-meva/#block-producers-transaction-inclusion","text":"Block proposers are most analogous to traditional blockchain miners. Instead of proposing blocks with an ordering, they simply propose a set of transactions to eventually be included before N blocks.","title":"Block producers - Transaction Inclusion"},{"location":"mev/solutions/faas-or-meva/#sequencers-transaction-ordering","text":"Sequencers are elected by a smart contract managed auction run by the block producers called the MEVA contract. This auction assigns the right to sequence the last N transactions. If, within a timeout the sequencer has not submitted an ordering which is included by block proposers, a new sequencer is elected.","title":"Sequencers - Transaction Ordering"},{"location":"mev/solutions/faas-or-meva/#implementation-on-layer-2","text":"It is possible to enshrine this MEVA contract directly on layer 1 (L1) blockchain consensus protocols. However, it is also possible to non-invasively add this mechanism in layer 2 (L2) and use it to manage Optimistic Rollup transactio ordering. In L2, L1 miners are repurposed and utilized as block proposers. MEVA contract is implemented and designated a single sequencer at a time. Links https://optimism.io/ https://ethresear.ch/t/mev-auction-auctioning-transaction-ordering-rights-as-a-solution-to-miner-extractable-value/6788 https://docs.google.com/presentation/d/1RaF1byflrLF3yUjd-5vXDZB1ZIRofVeK3JYVD6NPr30/edit#slide=id.gc9bdacc472_0_96","title":"Implementation on Layer 2"},{"location":"mev/solutions/faas-or-meva/#miningdao","text":"MiningDAO is building a decentralized and transparent protocol for block formation that aims to pass 100% of MEV to miners. Anyone with an Ethereum address can propose the next block to be mined (via a block sealhash), and attach a bounty for successfully mining it. The mining pools would then mine on the highest-bounty proposal. One is for searchers to submit Flashbots-compatible bundles. The other is the Archer Relay Network (powers Archerswap) where users can submit private transactions and be protected from malicious MEV. Links https://miningdao.io https://medium.com/mining-dao/introducing-miningdao-1e469626f7ad","title":"MiningDAO"},{"location":"mev/solutions/faas-or-meva/#backbone-cabal","text":"BackBone Cabal is a strategy that aims to extract MEV from SushiSwap. Profits are redistributed back to users who submitted trades in the first place in the form of eliminating their transaction cost (up to 90%). YCabal creates a virtualized mempool (i.e. a MEV-relay network) that aggregates transactions (batching). Users are able to opt in and send transactions to YCabal and in return for not having to pay for gas for their transaction, YCabal batch processes it and takes the arbitrage profit. Risk by inventory price risk is carried by a Vault, where Vault depositers are returned the profit the YCabal realizes. Links https://backbonecabal.com/ Knowledge Base: https://backbone-kb.netlify.app/ SushiSwap Proposal: https://forum.sushiswapclassic.org/t/proposal-ycabal-mev-strategy/3159 https://twitter.com/bloXrouteLabs/status/1357026919905173509 \u21a9","title":"BackBone Cabal"},{"location":"mev/solutions/mev-minimization-prevention/","text":"MEV Minimization/Prevention \u00b6 Conveyor - The Automata Network approach to tackling MEV \u00b6 At Automata, we have created Conveyor , a service that ingests and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering. When transactions are fed into Conveyor, it determines the order of the incoming transactions and makes it impossible for block producers to perform the following: Inject new transactions into the Conveyor output: The inserted transactions bypassing Conveyor is detectable by anyone because of signature mismatch. Delete ordered transactions: Transactions accepted by Conveyor are broadcasted everywhere so transactions cannot be deleted unless ALL block producers are colluding and censoring the transactions at the same time. From the DEX\u2019s perspective, they can choose to accept either Ordered transactions from Automata\u2019s Conveyor which is free from transaction reordering and other front-running transactions Other unordered transactions (which include front-running etc) that may negatively impact their users Why should users trust Conveyor? \u00b6 Automata\u2019s Conveyor runs on a decentralized compute plane backed by many Geode instances. Each Geode instance can be attested so anyone can publicly verify that the Geode is running on a system with genuine hardware (i.e., CPU) and that the Geode application code matches the version that is open-sourced and audited. This provides a strong guarantee that: The Geode code is untampered with The Geode data is inaccessible to even Geode providers (In which case they cannot act on said data to front-run transactions) Importantly, Automata\u2019s Conveyor is a chain-agnostic solution to the MEV issue, and works seamlessly on various platforms \u2014 zero modifications needed. Here\u2019s a demo on how trading pairs on Uniswap can be protected. An industry-first: Oblivious RAM \u00b6 In fully public computation, access pattern leakage is not negligible as everything is exposed. But in privacy-preserving computation, any tiny bit of information leakage becomes a significant issue. Studies have shown that access pattern leakage leads to exposure of sensitive information such as private keys from searchable encryption and trusted computing. This is where the Oblivious RAM algorithm comes into play. Automata\u2019s implementation is the first-of-its-kind in the blockchain industry, providing an exceedingly high degree of privacy in dApps. This greatly reduces the probability of user privacy being leaked even as access patterns are being monitored and analyzed by malicious actors. The Automata team has authored multiple research papers on state-of-the-art ORAM and hardware technologies to enhance the privacy and performance of existing networks. Robust P2P Primitives Using SGX Enclaves RAID 2020 PRO-ORAM: Practical Read-Only Oblivious RAM RAID 2019 OblivP2P: An Oblivious Peer-to-Peer Content Sharing System USENIX Security 2016 Preventing Page Faults from Telling Your Secrets Asia CCS 2016 The Fair Sequencing Service by ChainLink \u00b6 The idea behind FSS is to have an oracle network order the transactions sent to a particular contract SC, including both user transactions and oracle reports. Oracle nodes ingest transactions and then reach consensus on their ordering, rather than allowing a single leader to dictate it. FSS is a framework for implementing ordering policies, of which Aequitas (protocol for order-fairness in addition to consistency and liveness) is one example. It can alternatively support simpler approaches, such as straightforward encryption of transactions, which can then be decrypted in a threshold manner by oracle nodes after ordering. It will also support various policies for inserting oracle reports into a stream of transactions. (It can even support MEV auctions, if desired.) Links Blog post: https://blog.chain.link/chainlink-fair-sequencing-services-enabling-a-provably-fair-defi-ecosystem/ Whitepaper (to be released later) Arbitrum by Offchain Labs \u00b6 Arbitrum is against MEVA and FaaS. 3 Modes of Arbitrum: Single Sequencer: L2 MEV-Potential ( Mainnet Beta ) For Arbitrum\u2019s initial, flagship Mainnet beta release, the Sequencer will be controlled by a single entity. This entity has transaction ordering rights within the narrow / 15 minute window; users are trusting the Sequencer not to frontrun them. Distributed Sequencer With Fair Ordering: L2-MEV-minimized ( Mainnet Final Form ) The Arbitrum flagship chain will eventually have a distributed set of independent parties controlling the Sequencer. They will collectively propose state updates via the first BFT algorithm that enforces fair ordering within consensus (Aequitas) . Here, L2 MEV is only possible if >1/3 of the sequencing-parties maliciously collude, hence \u201cMEV-minimized.\u201d No Sequencer: No L2 MEV A chain can be created in which no permissioned entities have Sequencing rights. Ordering is determined entirely by the Inbox contract; lose the ability to get lower latency than L1, but gain is that no party involved in L2, including Arbitrum validators, has any say in transaction ordering, and thus no L2 MEV enters the picture. Links https://offchainlabs.com/ https://medium.com/offchainlabs/front-running-as-a-service-334c929c945 https://docs.google.com/document/d/1VOACGgTR84XWm5lH5Bki2nBcImi3lVRe2tYxf5F6XbA/edit Vega Protocol \u00b6 Traditionally, fairness in a blockchain has been defined in absolute terms, i.e. once a transaction is seen by a sufficient number of validators, it will be executed in some block, soon. Vega's proposal is to add a module to blockchains that supports the concept of relative fairness so that competing transactions may be sequenced under a known and understood protocol, and not subject to a validator\u2019s discretion. \" If there is a time t such that all honest validators saw a before t and b after t, then a must be scheduled before b\u201d. This is a property that can be assured of at any time with a minimal impact on performance. To get the best combination, their current approach is a hybrid of the two. In normal operation, the protocol will assure block fairness. If the network detects that this causes a bottleneck, it temporarily switches to the timed approach (thus sacrificing a little fairness for performance), before switching back once the bottleneck is resolved. However, Vega will ultimately make the level of fairness customisable by market. Links https://vega.xyz/ https://blog.vega.xyz/new-paper-fairness-and-front-running-an-invitation-for-feedback-cbb39a1a3eb Wendy, the Good Little Fairness Widget: https://vega.xyz/papers/fairness.pdf Video: https://www.youtube.com/watch?v=KjfLj5fhkGQ&t=18s&ab_channel=VegaProtocol CowSwap \u00b6 A collaboration between BalancerLabs and Gnosis, CowSwap is a DEX that leverages batch auctions to provide MEV protection, plus integrate with liquidity sources across DEXs to offer traders the best prices. When two traders each hold an asset the other wants, an order can be settled directly between them without an external market maker or liquidity provider. Any excess is settled in the same transaction with the best available AMM. The transaction is sent by professional \u201csolvers\u201d which set tight slippage bounds. Solvers compete with each other to achieve best prices for the user. Links https://cowswap.exchange/#/swap https://blog.gnosis.pm/introducing-gnosis-protocol-v2-and-balancer-gnosis-protocol-f693b2938ae4 Veedo by StarkWare \u00b6 VeeDo is StarkWare\u2019s STARK-based Verifiable Delay Function (VDF), and its PoC is now live on Mainnet. VeeDo's time-locks allow information to be sealed for a predetermined period of time (during the sequencing phase), and then made public. 2 approaches using privacy to minimize MEV Time-locks as part of the protocol layer Time-locks on Ethereum with smart contracts - supported today Links https://starkware.co/ https://medium.com/starkware/presenting-veedo-e4bbff77c7ae https://docs.google.com/presentation/d/1C_Rb_rtUXT2Nkettu_GPSlD9yCge8ioBNLRj5OBNbyY/edit#slide=id.gb576f94980_0_836 LibSubmarine \u00b6 LibSubmarine is an open-source smart contract library that protects your contract against front-runners by temporarily hiding transactions on-chain. Links https://libsubmarine.org/ Video: https://www.youtube.com/watch?v=N8PDKoptmPs&feature=emb_imp_woyt&ab_channel=IC3InitiativeforCryptocurrenciesandContracts GitHub: https://github.com/lorenzb/libsubmarine Sikka \u00b6 Sikka's MEV solution to censorship and frontrunning problems is using a technique called Threshold Decryption, as a plugin to the Tendermint Core BFT consensus engine to create mempool level privacy. With this plugin, users are able to submit encrypted transactions to the blockchain, which are only decrypted and executed after being committed to a block by a quorum of 2/3 validators. Links https://sikka.tech/ https://docs.google.com/presentation/d/1tQEUpZjy_U9J-VQAx1Wf5W9oOX5rrCY3AwjAb7ZgA68/edit#slide=id.p Shutter Network \u00b6 Shutter Network is an open-source project that aims to prevent frontrunning and malicious MEV on Ethereum by using a threshold cryptography-based distributed key generation (DKG) protocol. A Shutter transaction is a transaction protected from frontrunning in the target smart contract system. It therefore passes through a sequence of stages before it is executed. A Shutter transaction flow: Created and encrypted in the user's wallet; Sent to the batcher contract as a standard Ethereum transaction; Picked up and decrypted by the keypers; Sent to the executor contract, and Forwarded to the target contract. Links https://shutter.ghost.io/ GitHub: https://github.com/brainbot-com/shutter","title":"MEV Minimization / Prevention"},{"location":"mev/solutions/mev-minimization-prevention/#mev-minimizationprevention","text":"","title":"MEV Minimization/Prevention"},{"location":"mev/solutions/mev-minimization-prevention/#conveyor-the-automata-network-approach-to-tackling-mev","text":"At Automata, we have created Conveyor , a service that ingests and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering. When transactions are fed into Conveyor, it determines the order of the incoming transactions and makes it impossible for block producers to perform the following: Inject new transactions into the Conveyor output: The inserted transactions bypassing Conveyor is detectable by anyone because of signature mismatch. Delete ordered transactions: Transactions accepted by Conveyor are broadcasted everywhere so transactions cannot be deleted unless ALL block producers are colluding and censoring the transactions at the same time. From the DEX\u2019s perspective, they can choose to accept either Ordered transactions from Automata\u2019s Conveyor which is free from transaction reordering and other front-running transactions Other unordered transactions (which include front-running etc) that may negatively impact their users","title":"Conveyor - The Automata Network approach to tackling MEV"},{"location":"mev/solutions/mev-minimization-prevention/#why-should-users-trust-conveyor","text":"Automata\u2019s Conveyor runs on a decentralized compute plane backed by many Geode instances. Each Geode instance can be attested so anyone can publicly verify that the Geode is running on a system with genuine hardware (i.e., CPU) and that the Geode application code matches the version that is open-sourced and audited. This provides a strong guarantee that: The Geode code is untampered with The Geode data is inaccessible to even Geode providers (In which case they cannot act on said data to front-run transactions) Importantly, Automata\u2019s Conveyor is a chain-agnostic solution to the MEV issue, and works seamlessly on various platforms \u2014 zero modifications needed. Here\u2019s a demo on how trading pairs on Uniswap can be protected.","title":"Why should users trust Conveyor?"},{"location":"mev/solutions/mev-minimization-prevention/#an-industry-first-oblivious-ram","text":"In fully public computation, access pattern leakage is not negligible as everything is exposed. But in privacy-preserving computation, any tiny bit of information leakage becomes a significant issue. Studies have shown that access pattern leakage leads to exposure of sensitive information such as private keys from searchable encryption and trusted computing. This is where the Oblivious RAM algorithm comes into play. Automata\u2019s implementation is the first-of-its-kind in the blockchain industry, providing an exceedingly high degree of privacy in dApps. This greatly reduces the probability of user privacy being leaked even as access patterns are being monitored and analyzed by malicious actors. The Automata team has authored multiple research papers on state-of-the-art ORAM and hardware technologies to enhance the privacy and performance of existing networks. Robust P2P Primitives Using SGX Enclaves RAID 2020 PRO-ORAM: Practical Read-Only Oblivious RAM RAID 2019 OblivP2P: An Oblivious Peer-to-Peer Content Sharing System USENIX Security 2016 Preventing Page Faults from Telling Your Secrets Asia CCS 2016","title":"An industry-first: Oblivious RAM"},{"location":"mev/solutions/mev-minimization-prevention/#the-fair-sequencing-service-by-chainlink","text":"The idea behind FSS is to have an oracle network order the transactions sent to a particular contract SC, including both user transactions and oracle reports. Oracle nodes ingest transactions and then reach consensus on their ordering, rather than allowing a single leader to dictate it. FSS is a framework for implementing ordering policies, of which Aequitas (protocol for order-fairness in addition to consistency and liveness) is one example. It can alternatively support simpler approaches, such as straightforward encryption of transactions, which can then be decrypted in a threshold manner by oracle nodes after ordering. It will also support various policies for inserting oracle reports into a stream of transactions. (It can even support MEV auctions, if desired.) Links Blog post: https://blog.chain.link/chainlink-fair-sequencing-services-enabling-a-provably-fair-defi-ecosystem/ Whitepaper (to be released later)","title":"The Fair Sequencing Service by ChainLink"},{"location":"mev/solutions/mev-minimization-prevention/#arbitrum-by-offchain-labs","text":"Arbitrum is against MEVA and FaaS. 3 Modes of Arbitrum: Single Sequencer: L2 MEV-Potential ( Mainnet Beta ) For Arbitrum\u2019s initial, flagship Mainnet beta release, the Sequencer will be controlled by a single entity. This entity has transaction ordering rights within the narrow / 15 minute window; users are trusting the Sequencer not to frontrun them. Distributed Sequencer With Fair Ordering: L2-MEV-minimized ( Mainnet Final Form ) The Arbitrum flagship chain will eventually have a distributed set of independent parties controlling the Sequencer. They will collectively propose state updates via the first BFT algorithm that enforces fair ordering within consensus (Aequitas) . Here, L2 MEV is only possible if >1/3 of the sequencing-parties maliciously collude, hence \u201cMEV-minimized.\u201d No Sequencer: No L2 MEV A chain can be created in which no permissioned entities have Sequencing rights. Ordering is determined entirely by the Inbox contract; lose the ability to get lower latency than L1, but gain is that no party involved in L2, including Arbitrum validators, has any say in transaction ordering, and thus no L2 MEV enters the picture. Links https://offchainlabs.com/ https://medium.com/offchainlabs/front-running-as-a-service-334c929c945 https://docs.google.com/document/d/1VOACGgTR84XWm5lH5Bki2nBcImi3lVRe2tYxf5F6XbA/edit","title":"Arbitrum by Offchain Labs"},{"location":"mev/solutions/mev-minimization-prevention/#vega-protocol","text":"Traditionally, fairness in a blockchain has been defined in absolute terms, i.e. once a transaction is seen by a sufficient number of validators, it will be executed in some block, soon. Vega's proposal is to add a module to blockchains that supports the concept of relative fairness so that competing transactions may be sequenced under a known and understood protocol, and not subject to a validator\u2019s discretion. \" If there is a time t such that all honest validators saw a before t and b after t, then a must be scheduled before b\u201d. This is a property that can be assured of at any time with a minimal impact on performance. To get the best combination, their current approach is a hybrid of the two. In normal operation, the protocol will assure block fairness. If the network detects that this causes a bottleneck, it temporarily switches to the timed approach (thus sacrificing a little fairness for performance), before switching back once the bottleneck is resolved. However, Vega will ultimately make the level of fairness customisable by market. Links https://vega.xyz/ https://blog.vega.xyz/new-paper-fairness-and-front-running-an-invitation-for-feedback-cbb39a1a3eb Wendy, the Good Little Fairness Widget: https://vega.xyz/papers/fairness.pdf Video: https://www.youtube.com/watch?v=KjfLj5fhkGQ&t=18s&ab_channel=VegaProtocol","title":"Vega Protocol"},{"location":"mev/solutions/mev-minimization-prevention/#cowswap","text":"A collaboration between BalancerLabs and Gnosis, CowSwap is a DEX that leverages batch auctions to provide MEV protection, plus integrate with liquidity sources across DEXs to offer traders the best prices. When two traders each hold an asset the other wants, an order can be settled directly between them without an external market maker or liquidity provider. Any excess is settled in the same transaction with the best available AMM. The transaction is sent by professional \u201csolvers\u201d which set tight slippage bounds. Solvers compete with each other to achieve best prices for the user. Links https://cowswap.exchange/#/swap https://blog.gnosis.pm/introducing-gnosis-protocol-v2-and-balancer-gnosis-protocol-f693b2938ae4","title":"CowSwap"},{"location":"mev/solutions/mev-minimization-prevention/#veedo-by-starkware","text":"VeeDo is StarkWare\u2019s STARK-based Verifiable Delay Function (VDF), and its PoC is now live on Mainnet. VeeDo's time-locks allow information to be sealed for a predetermined period of time (during the sequencing phase), and then made public. 2 approaches using privacy to minimize MEV Time-locks as part of the protocol layer Time-locks on Ethereum with smart contracts - supported today Links https://starkware.co/ https://medium.com/starkware/presenting-veedo-e4bbff77c7ae https://docs.google.com/presentation/d/1C_Rb_rtUXT2Nkettu_GPSlD9yCge8ioBNLRj5OBNbyY/edit#slide=id.gb576f94980_0_836","title":"Veedo by StarkWare"},{"location":"mev/solutions/mev-minimization-prevention/#libsubmarine","text":"LibSubmarine is an open-source smart contract library that protects your contract against front-runners by temporarily hiding transactions on-chain. Links https://libsubmarine.org/ Video: https://www.youtube.com/watch?v=N8PDKoptmPs&feature=emb_imp_woyt&ab_channel=IC3InitiativeforCryptocurrenciesandContracts GitHub: https://github.com/lorenzb/libsubmarine","title":"LibSubmarine"},{"location":"mev/solutions/mev-minimization-prevention/#sikka","text":"Sikka's MEV solution to censorship and frontrunning problems is using a technique called Threshold Decryption, as a plugin to the Tendermint Core BFT consensus engine to create mempool level privacy. With this plugin, users are able to submit encrypted transactions to the blockchain, which are only decrypted and executed after being committed to a block by a quorum of 2/3 validators. Links https://sikka.tech/ https://docs.google.com/presentation/d/1tQEUpZjy_U9J-VQAx1Wf5W9oOX5rrCY3AwjAb7ZgA68/edit#slide=id.p","title":"Sikka"},{"location":"mev/solutions/mev-minimization-prevention/#shutter-network","text":"Shutter Network is an open-source project that aims to prevent frontrunning and malicious MEV on Ethereum by using a threshold cryptography-based distributed key generation (DKG) protocol. A Shutter transaction is a transaction protected from frontrunning in the target smart contract system. It therefore passes through a sequence of stages before it is executed. A Shutter transaction flow: Created and encrypted in the user's wallet; Sent to the batcher contract as a standard Ethereum transaction; Picked up and decrypted by the keypers; Sent to the executor contract, and Forwarded to the target contract. Links https://shutter.ghost.io/ GitHub: https://github.com/brainbot-com/shutter","title":"Shutter Network"},{"location":"mev/solutions/others/","text":"Others \u00b6 B.Protocol \u00b6 BProtocol aims to shift MEV to users. Users interact with existing lending platforms via B.Protocol smart contract. Liquidity providers (LP) provide a cushion to user debt, which gives B.Protocol precedence over other liquidators. LPs share their profits with the users, where user reward is proportional to his user rating. Links https://www.bprotocol.org/ https://docs.google.com/presentation/d/13UNysGCX9ZJG20lKaxr_qbhgKwcuHACdwlhGNKtzGt4/edit","title":"Others"},{"location":"mev/solutions/others/#others","text":"","title":"Others"},{"location":"mev/solutions/others/#bprotocol","text":"BProtocol aims to shift MEV to users. Users interact with existing lending platforms via B.Protocol smart contract. Liquidity providers (LP) provide a cushion to user debt, which gives B.Protocol precedence over other liquidators. LPs share their profits with the users, where user reward is proportional to his user rating. Links https://www.bprotocol.org/ https://docs.google.com/presentation/d/13UNysGCX9ZJG20lKaxr_qbhgKwcuHACdwlhGNKtzGt4/edit","title":"B.Protocol"},{"location":"nftfair/introduction/","text":"Introduction \u00b6 Automata NFTFair is A NFT launch platform, designed around principles of fairness and efficacy for a community-led experience is how we would describe NFTFair. Metadata exploits pre-sniping are all predatory practices that make it unfair for the average user to get their hands on a new collection, much less obtain rare or lucrative items. About Fairdrops \u00b6 Network: \u00b6 This platform is compatible with most EVM networks. We currently support the hosting of Fairdrop events on the following networks: BSC We are working hard to expand the list of supported networks. If your intended launch network is not included in our supported list, please submit a proposal here or reach out to us at nftfair@ata.network . Fairdrop Templates: \u00b6 This platform currently supports two templates, i.e. (1) FIFO (First-In-First-Out) and (2) Mystery Boxes Fairdrops. FIFO Fairdrop \u00b6 First-in-first-out vaults enforce the correct ordering of NFT distributions. This is all made possible by Conveyor . Mystery Boxes Fairdrop \u00b6 Mystery boxes are a more restricted form of FIFO Fairdrop. Users who participated in a mystery box fairdrop selects an NFT category, i.e. a collection of token IDs. A single token ID is then randomly chosen and not revealed until the transaction has been broadcasted. Users are also rest-assured that transaction ordering is determined and correctly enforced in a fair manner. We plan to add more templates in the future. Category: \u00b6 A category defines a collection of NFTs, with a set of configurable properties, such as: NFT Contract Range of Token IDs Sales Price Maximum Purchase/Claim Limit Fairdrop event organizers must define at least one category before sending NFTs to Fairdrop vaults. Fair Sales: \u00b6 This platform provides the option to enable Fairdrop sales, i.e. Selling NFTs in exchange for an acceptable form of ERC20 payment tokens. NFTs can be differentiated by categories, where prices can be set individually. Each vault only accepts a single ERC20 payment token. In other words, it is not possible to price one category at 100 USDC, and the other at 100 BTC. You can however, price different categories for different amounts of the same token. For instance, 100 USDC for category A and 1000 USDC for category B. Sales revenue can be withdrawn once the Fairdrop event has come to an end. Costs \u00b6 Gas consumption plays a major role on the cost of running Fairdrops. This platform provides a gasless transaction experience, powered by Conveyor . To provide the true experience of zero-cost transactions for the users, you may opt for relayer-sponsored transactions. Relayer-sponsored transactions do not charge ERC20 gas payment from the users. The event organizers would bear the full gas cost instead. Please reach out to us at nftfair@ata.network , to get a quote and a cost breakdown for enabling relayer-sponsored transactions. Ready to start? \u00b6 If you are interested in using our platform and ready to start a Fairdrop, you need to provide us with the following information: The activity name. (Example: MOGA Mystery Box Fairdrop) A page title. (Example: Come And Obtain Your Own Genesis MOGA!) The start and end time for your fairdrop. Official website and social media URLs. A short description to introduce your project. (Example: Monster Galaxy is making a mystery box fairdrop to give our players the chance to obtain powerful genesis mogas! Don\u2019t lose this opportunity!) A list of FAQs to let users know about the Fairdrop. A horizontal brand logo, higher than 200px. Example A square brand logo, bigger than 500px. Example A banner related to the theme of the Fairdrop with size 2132x224px Example A small 32x32px square icon for the browser tab bar. Example Once you complete setting up the Fairdrop, you can transfer or mint your NFT to our vault contract, and begin selling. If you wish to enable the wallet connect function with your infura id, you need to provide the id to us. Read more about Wallet Connect and Infura ID Moreover, you can provide us with the primary color of your brand and some decoration backgrounds to customize and enrich your Fairdrop activity page. That's all, leave the rest to us, and we'll bring you a fantastic Fairdrop.","title":"Introduction"},{"location":"nftfair/introduction/#introduction","text":"Automata NFTFair is A NFT launch platform, designed around principles of fairness and efficacy for a community-led experience is how we would describe NFTFair. Metadata exploits pre-sniping are all predatory practices that make it unfair for the average user to get their hands on a new collection, much less obtain rare or lucrative items.","title":"Introduction"},{"location":"nftfair/introduction/#about-fairdrops","text":"","title":"About Fairdrops"},{"location":"nftfair/introduction/#network","text":"This platform is compatible with most EVM networks. We currently support the hosting of Fairdrop events on the following networks: BSC We are working hard to expand the list of supported networks. If your intended launch network is not included in our supported list, please submit a proposal here or reach out to us at nftfair@ata.network .","title":"Network:"},{"location":"nftfair/introduction/#fairdrop-templates","text":"This platform currently supports two templates, i.e. (1) FIFO (First-In-First-Out) and (2) Mystery Boxes Fairdrops.","title":"Fairdrop Templates:"},{"location":"nftfair/introduction/#fifo-fairdrop","text":"First-in-first-out vaults enforce the correct ordering of NFT distributions. This is all made possible by Conveyor .","title":"FIFO Fairdrop"},{"location":"nftfair/introduction/#mystery-boxes-fairdrop","text":"Mystery boxes are a more restricted form of FIFO Fairdrop. Users who participated in a mystery box fairdrop selects an NFT category, i.e. a collection of token IDs. A single token ID is then randomly chosen and not revealed until the transaction has been broadcasted. Users are also rest-assured that transaction ordering is determined and correctly enforced in a fair manner. We plan to add more templates in the future.","title":"Mystery Boxes Fairdrop"},{"location":"nftfair/introduction/#category","text":"A category defines a collection of NFTs, with a set of configurable properties, such as: NFT Contract Range of Token IDs Sales Price Maximum Purchase/Claim Limit Fairdrop event organizers must define at least one category before sending NFTs to Fairdrop vaults.","title":"Category:"},{"location":"nftfair/introduction/#fair-sales","text":"This platform provides the option to enable Fairdrop sales, i.e. Selling NFTs in exchange for an acceptable form of ERC20 payment tokens. NFTs can be differentiated by categories, where prices can be set individually. Each vault only accepts a single ERC20 payment token. In other words, it is not possible to price one category at 100 USDC, and the other at 100 BTC. You can however, price different categories for different amounts of the same token. For instance, 100 USDC for category A and 1000 USDC for category B. Sales revenue can be withdrawn once the Fairdrop event has come to an end.","title":"Fair Sales:"},{"location":"nftfair/introduction/#costs","text":"Gas consumption plays a major role on the cost of running Fairdrops. This platform provides a gasless transaction experience, powered by Conveyor . To provide the true experience of zero-cost transactions for the users, you may opt for relayer-sponsored transactions. Relayer-sponsored transactions do not charge ERC20 gas payment from the users. The event organizers would bear the full gas cost instead. Please reach out to us at nftfair@ata.network , to get a quote and a cost breakdown for enabling relayer-sponsored transactions.","title":"Costs"},{"location":"nftfair/introduction/#ready-to-start","text":"If you are interested in using our platform and ready to start a Fairdrop, you need to provide us with the following information: The activity name. (Example: MOGA Mystery Box Fairdrop) A page title. (Example: Come And Obtain Your Own Genesis MOGA!) The start and end time for your fairdrop. Official website and social media URLs. A short description to introduce your project. (Example: Monster Galaxy is making a mystery box fairdrop to give our players the chance to obtain powerful genesis mogas! Don\u2019t lose this opportunity!) A list of FAQs to let users know about the Fairdrop. A horizontal brand logo, higher than 200px. Example A square brand logo, bigger than 500px. Example A banner related to the theme of the Fairdrop with size 2132x224px Example A small 32x32px square icon for the browser tab bar. Example Once you complete setting up the Fairdrop, you can transfer or mint your NFT to our vault contract, and begin selling. If you wish to enable the wallet connect function with your infura id, you need to provide the id to us. Read more about Wallet Connect and Infura ID Moreover, you can provide us with the primary color of your brand and some decoration backgrounds to customize and enrich your Fairdrop activity page. That's all, leave the rest to us, and we'll bring you a fantastic Fairdrop.","title":"Ready to start?"},{"location":"nftfair/contracts/factory/","text":"NFTFairFactory \u00b6 The Factory contract stores template bytecodes. Upon deployment of the vaults, the owner can select a template by providing its corresponding ID. Once the vault has been deployed, they get full ownership of the Vault contract, implemented using OpenZeppelin's Ownable library. The admin of the Factory contract has the ability to modify the bytecodes stored in the factory, as a means of upgrading existing templates or adding a new template to the platform. Any changes on the Factory contract will NOT impact any existing vaults. Owners who opted to use a newer version of the vault template, must re-deploy a vault. This Factory contract is upgradeable using a Transparent Proxy . initialize() \u00b6 function initialize ( address _owner ) Initializes the state of the contract. In this case, this method initializes the owner of the Factory contract. This method must be implemented for a proxied contract. For more information, see Initializable on OpenZeppelin. Note: It is advisable to encode this method and pass as a data argument upon invoking the upgradeTo() method on the proxy contract for the first time. This is to avoid leaving the proxy uninitialized post-deployment. addVaultTemplate() \u00b6 function addVaultTemplate ( bytes memory _bytecode ) Adds a new bytecode template to the Factory, and returns the ID of the template. Requires onlyOwner() Parameter Type Description Bytecode bytes The creation bytecode of the template updateVaultTemplate() \u00b6 function updateVaultTemplate ( uint256 _templateId , bytes memory _bytecode ) Updates an existing vault template. Requires onlyOwner() . Note: This does not affect existing vaults. Given the immutable nature of smart contracts, the template of the vault permanently adheres to the version of the bytecode based on the time of deployment. Parameter Type Description Template ID uint256 The ID of a template. Reverts if an invalid ID is provided Bytecode bytes The creation bytecode of the template createVault() \u00b6 function createVault ( uint256 _templateId , bytes calldata _constructorData ) Deploys a vault according to a template provided by its ID. Parameter Type Description Template ID uint256 The ID of a template. Reverts if an invalid ID is provided Constructor Data bytes ABI encoded constructor data getVaultTemplate() \u00b6 function getVaultTemplate ( uint256 _templateId ) external view returns ( bytes memory ) Gets the bytecode of a given template ID. getVaultTemplateCount() \u00b6 function getVaultTemplateCount () external view returns ( uint256 ) Returns the number of templates stored in the Factory.","title":"NFTFairFactory"},{"location":"nftfair/contracts/factory/#nftfairfactory","text":"The Factory contract stores template bytecodes. Upon deployment of the vaults, the owner can select a template by providing its corresponding ID. Once the vault has been deployed, they get full ownership of the Vault contract, implemented using OpenZeppelin's Ownable library. The admin of the Factory contract has the ability to modify the bytecodes stored in the factory, as a means of upgrading existing templates or adding a new template to the platform. Any changes on the Factory contract will NOT impact any existing vaults. Owners who opted to use a newer version of the vault template, must re-deploy a vault. This Factory contract is upgradeable using a Transparent Proxy .","title":"NFTFairFactory"},{"location":"nftfair/contracts/factory/#initialize","text":"function initialize ( address _owner ) Initializes the state of the contract. In this case, this method initializes the owner of the Factory contract. This method must be implemented for a proxied contract. For more information, see Initializable on OpenZeppelin. Note: It is advisable to encode this method and pass as a data argument upon invoking the upgradeTo() method on the proxy contract for the first time. This is to avoid leaving the proxy uninitialized post-deployment.","title":"initialize()"},{"location":"nftfair/contracts/factory/#addvaulttemplate","text":"function addVaultTemplate ( bytes memory _bytecode ) Adds a new bytecode template to the Factory, and returns the ID of the template. Requires onlyOwner() Parameter Type Description Bytecode bytes The creation bytecode of the template","title":"addVaultTemplate()"},{"location":"nftfair/contracts/factory/#updatevaulttemplate","text":"function updateVaultTemplate ( uint256 _templateId , bytes memory _bytecode ) Updates an existing vault template. Requires onlyOwner() . Note: This does not affect existing vaults. Given the immutable nature of smart contracts, the template of the vault permanently adheres to the version of the bytecode based on the time of deployment. Parameter Type Description Template ID uint256 The ID of a template. Reverts if an invalid ID is provided Bytecode bytes The creation bytecode of the template","title":"updateVaultTemplate()"},{"location":"nftfair/contracts/factory/#createvault","text":"function createVault ( uint256 _templateId , bytes calldata _constructorData ) Deploys a vault according to a template provided by its ID. Parameter Type Description Template ID uint256 The ID of a template. Reverts if an invalid ID is provided Constructor Data bytes ABI encoded constructor data","title":"createVault()"},{"location":"nftfair/contracts/factory/#getvaulttemplate","text":"function getVaultTemplate ( uint256 _templateId ) external view returns ( bytes memory ) Gets the bytecode of a given template ID.","title":"getVaultTemplate()"},{"location":"nftfair/contracts/factory/#getvaulttemplatecount","text":"function getVaultTemplateCount () external view returns ( uint256 ) Returns the number of templates stored in the Factory.","title":"getVaultTemplateCount()"},{"location":"nftfair/contracts/summary/","text":"Summary \u00b6 This documentation outlines the contract specification of the platform. The contracts consist of three components: NFTFairFactory - The factory contract to deploy vaults based on a given template. Proxied by NFTFairProxy for upgradability. NFTFairTreasury - The central contract that collects sales revenues generated from vaults, and other protocol-related payment. NFTFairVaultBase - The base Vault contract that implements essential features of a vault, can be extended with additional implementations that are tailored to a specific template. Currently, the platform supports the two templates: FIFO Mystery Boxes We plan to add more templates in the future. Addresses \u00b6 BSC \u00b6 Contract Address NFTFairFactory 0x67F7e0C322a067C70e1eE99873Fe4163f4A02edD NFTFairProxy 0x062154774E1726246c75A4e8f05EDC675d8B39a1 NFTFairTreasury 0x39c805A56EeF49BcD7C6c14d5dcf6e7f0daf63A4","title":"Summary"},{"location":"nftfair/contracts/summary/#summary","text":"This documentation outlines the contract specification of the platform. The contracts consist of three components: NFTFairFactory - The factory contract to deploy vaults based on a given template. Proxied by NFTFairProxy for upgradability. NFTFairTreasury - The central contract that collects sales revenues generated from vaults, and other protocol-related payment. NFTFairVaultBase - The base Vault contract that implements essential features of a vault, can be extended with additional implementations that are tailored to a specific template. Currently, the platform supports the two templates: FIFO Mystery Boxes We plan to add more templates in the future.","title":"Summary"},{"location":"nftfair/contracts/summary/#addresses","text":"","title":"Addresses"},{"location":"nftfair/contracts/summary/#bsc","text":"Contract Address NFTFairFactory 0x67F7e0C322a067C70e1eE99873Fe4163f4A02edD NFTFairProxy 0x062154774E1726246c75A4e8f05EDC675d8B39a1 NFTFairTreasury 0x39c805A56EeF49BcD7C6c14d5dcf6e7f0daf63A4","title":"BSC"},{"location":"nftfair/contracts/treasury/","text":"NFTFairTreasury \u00b6 The treasury contract serves as a central entity for collecting payment and sales revenue generated from vaults. This design is intended such that users would send at most one approve() call for one ERC20 token that can be spent across all vaults on the NFTFair platform. To ensure the protocol does not drain the user's allowance without explicit approval, the collectPayment() method requires an EIP712 Signature, indicating the amount of specified tokens to be spent by an authorized address. The structure of the EIP712 Message (similarly based on EIP 2612 ) is the following: Permit : [ { name : 'owner' , type : 'address' }, { name : 'spender' , type : 'address' }, { name : 'token' , type : 'address' }, { name : 'value' , type : 'uint256' }, { name : 'nonce' , type : 'uint256' }, { name : 'deadline' , type : 'uint256' }, ], Parameter Description owner The owner of the token. This is most likely the user's address spender The authorized spender. This is most likely the vault's address token The address of the ERC20 token to be spent value The payment amount nonce The user's transaction count in the Treasury contract deadline Transaction reverts at block.timestamp > deadline In the future, the protocol may set a fee upon payment collection, using basis points. This value is given a ceiling of 3000. In other words. the protocol can not set a fee higher than 30%. Last but not least, the protocol has the ability to exempt fees or configure a custom fee percentage for a specified spender. If an address is neither exempt nor assigned with a custom basis point, the Treasury will collect fee using the default BP. collectPayment() \u00b6 function collectPayment ( address _buyer , address _token , uint256 _amount , uint256 _deadline , bytes calldata _signature ) This function is called by the payee directly, to collect payment from the buyer. Parameter Type Description buyer address The owner of the token. This is most likely the user's address token address The address of the ERC20 token to be spent amount uint256 The payment amount deadline uint256 Transaction reverts at block.timestamp > deadline signature bytes The user signed EIP712 message setNewBp \u00b6 function setNewBp ( uint256 _newBp ) Sets a new default BP. Requires onlyOwner() Parameter Type Description New BP uint256 REVERTS > 3000 setAddressBp \u00b6 function setAddressBp ( address _spender , uint256 _newBp ) Specifies a custom BP for _spender . Requires onlyOwner() Parameter Type Description Spender address This is most likely the vault's address. New BP uint256 REVERTS > 3000 toggleAddressExemption \u00b6 function toggleAddressExemption ( address _spender ) Exempts/Unexempts _spender from paying fees. Requires onlyOwner() Parameter Type Description Spender address This is most likely the vault's address. recoverERC20() \u00b6 function recoverERC20 ( address _recipient , address _token , uint256 _amount ) Withdraws the protocol revenue. Requires onlyOwner() . Parameter Type Description recipient address The recipient address token address The address of the ERC20 token amount uint256 The amount to withdraw getFeeMultiplier() \u00b6 function getFeeMultiplier ( address _spender ) public view returns ( uint256 multiplier ) Returns the BP value for a specified _spender .","title":"NFTFairTreasury"},{"location":"nftfair/contracts/treasury/#nftfairtreasury","text":"The treasury contract serves as a central entity for collecting payment and sales revenue generated from vaults. This design is intended such that users would send at most one approve() call for one ERC20 token that can be spent across all vaults on the NFTFair platform. To ensure the protocol does not drain the user's allowance without explicit approval, the collectPayment() method requires an EIP712 Signature, indicating the amount of specified tokens to be spent by an authorized address. The structure of the EIP712 Message (similarly based on EIP 2612 ) is the following: Permit : [ { name : 'owner' , type : 'address' }, { name : 'spender' , type : 'address' }, { name : 'token' , type : 'address' }, { name : 'value' , type : 'uint256' }, { name : 'nonce' , type : 'uint256' }, { name : 'deadline' , type : 'uint256' }, ], Parameter Description owner The owner of the token. This is most likely the user's address spender The authorized spender. This is most likely the vault's address token The address of the ERC20 token to be spent value The payment amount nonce The user's transaction count in the Treasury contract deadline Transaction reverts at block.timestamp > deadline In the future, the protocol may set a fee upon payment collection, using basis points. This value is given a ceiling of 3000. In other words. the protocol can not set a fee higher than 30%. Last but not least, the protocol has the ability to exempt fees or configure a custom fee percentage for a specified spender. If an address is neither exempt nor assigned with a custom basis point, the Treasury will collect fee using the default BP.","title":"NFTFairTreasury"},{"location":"nftfair/contracts/treasury/#collectpayment","text":"function collectPayment ( address _buyer , address _token , uint256 _amount , uint256 _deadline , bytes calldata _signature ) This function is called by the payee directly, to collect payment from the buyer. Parameter Type Description buyer address The owner of the token. This is most likely the user's address token address The address of the ERC20 token to be spent amount uint256 The payment amount deadline uint256 Transaction reverts at block.timestamp > deadline signature bytes The user signed EIP712 message","title":"collectPayment()"},{"location":"nftfair/contracts/treasury/#setnewbp","text":"function setNewBp ( uint256 _newBp ) Sets a new default BP. Requires onlyOwner() Parameter Type Description New BP uint256 REVERTS > 3000","title":"setNewBp"},{"location":"nftfair/contracts/treasury/#setaddressbp","text":"function setAddressBp ( address _spender , uint256 _newBp ) Specifies a custom BP for _spender . Requires onlyOwner() Parameter Type Description Spender address This is most likely the vault's address. New BP uint256 REVERTS > 3000","title":"setAddressBp"},{"location":"nftfair/contracts/treasury/#toggleaddressexemption","text":"function toggleAddressExemption ( address _spender ) Exempts/Unexempts _spender from paying fees. Requires onlyOwner() Parameter Type Description Spender address This is most likely the vault's address.","title":"toggleAddressExemption"},{"location":"nftfair/contracts/treasury/#recovererc20","text":"function recoverERC20 ( address _recipient , address _token , uint256 _amount ) Withdraws the protocol revenue. Requires onlyOwner() . Parameter Type Description recipient address The recipient address token address The address of the ERC20 token amount uint256 The amount to withdraw","title":"recoverERC20()"},{"location":"nftfair/contracts/treasury/#getfeemultiplier","text":"function getFeeMultiplier ( address _spender ) public view returns ( uint256 multiplier ) Returns the BP value for a specified _spender .","title":"getFeeMultiplier()"},{"location":"nftfair/contracts/vault/base/","text":"NFTFairVaultBase \u00b6 NFTFair Vaults are responsible for fairly distributing NFTs, a.k.a. Fairdrop, this is all made possible by Conveyor . The Vault contract achieves this by inheriting the ConveyorBase contract. The NFTVaultBase contract provides the essential features to receive and organize NFTs by assigning categories. A category must be created prior to receiving any NFTs. The vault may reject any incoming NFTs, if a category is not created for that particular NFT contract. The structure of the Category is the following: struct CategoryInfo { address nft ; EnumerableSet . UintSet ids ; EnumerableSet . UintSet claimable_ids ; uint256 purchaseLimit ; uint256 price ; } Parameter Description NFT The address of the NFT contract. This address cannot be modified after initialization ids A list of token IDs that the vault has received. IDs are appended when the onERC721Received hook is called claimable ids A list of token IDs that are available to claim. A subset of the ids list. Purchase Limit The maximum amount of NFTs that a user is eligible to claim from the category Price Amount to be paid in paymentToken to purchase an NFT createCategory() \u00b6 function createCategory ( address _nft , uint256 _max , uint256 _price ) Initializes a category. Parameter Type Description NFT address The NFT contract address. CANNOT BE CHANGED AFTER INITIALIZATION Max uint256 The maximum amount of NFTs that a user is eligible to claim from the category Price uint256 Amount to be paid in paymentToken to purchase an NFT updateCategory \u00b6 function updateCategory ( uint256 _category , uint256 _maxPurchase , uint256 _price ) Updates the properties of a specified category, except for the NFT address . A new category must be created separately for a different NFT contract. Parameter Type Description Category uint256 The integer representation of a category Max uint256 The maximum amount of NFTs that a user is eligible to claim from the category Price uint256 Amount to be paid in paymentToken to purchase an NFT configurePayment \u00b6 function configurePayment ( address _newToken , uint256 [] memory _prices ) This function allows changing the payment token and/or updates prices across all categories in a single function call. Parameter Type Description Token address The ERC20 token address Prices uint256[] The length of the array must either be 0 or the total number of categories. This transaction reverts otherwise. revenuePayout \u00b6 function revenuePayout ( address _beneficiary , address _token ) The Vault owner calls this function to withdraw revenue out of the vault. Parameter Type Description Beneficiary address The recipient address Token address The ERC20 token address recover \u00b6 function recover ( uint256 [] memory _categoryArr , address _recipient ) The owner can invoke this method to withdraw remaining NFTs from one or more specified categories. This function call effectively empties all categories that are being recovered. Parameter Type Description Categories uint256[] One or more categories Recipient address The recipient address claimed \u00b6 function claimed ( address _user , uint256 _category ) public view override returns ( uint256 [] memory ) Returns a list of token IDs that has been claimed by the _user from a specified _category getClaimableIds \u00b6 function getClaimableIds ( uint256 _category ) public view override returns ( uint256 [] memory ) Returns a list of available token IDs from a specified _category . getCategoryPrice \u00b6 function getCategoryPrice ( uint256 _category ) external view override returns ( uint256 ) Returns the amount of paymentToken required to purchase a single NFT from the specified _category . Call the paymentToken() method to get the ERC20 address of the payment token. getCategoryNft \u00b6 function getCategoryNft ( uint256 _category ) external view override returns ( address ) Returns the address of the NFT contract from the specified _category . getCategoryNftIds \u00b6 function getCategoryNftIds ( uint256 _category ) external view returns ( uint256 [] memory ) Returns the list of token IDs that has been added into this category. This list excludes token IDs that had been recovered by the owner. claimableCount \u00b6 function claimableCount ( uint256 _category ) external view returns ( uint256 ) Return the number of available token IDs from a specified _category . This base contract can be extended to implement the claim() function. claim() functions are implemented differently by their templates.","title":"NFTFairVault"},{"location":"nftfair/contracts/vault/base/#nftfairvaultbase","text":"NFTFair Vaults are responsible for fairly distributing NFTs, a.k.a. Fairdrop, this is all made possible by Conveyor . The Vault contract achieves this by inheriting the ConveyorBase contract. The NFTVaultBase contract provides the essential features to receive and organize NFTs by assigning categories. A category must be created prior to receiving any NFTs. The vault may reject any incoming NFTs, if a category is not created for that particular NFT contract. The structure of the Category is the following: struct CategoryInfo { address nft ; EnumerableSet . UintSet ids ; EnumerableSet . UintSet claimable_ids ; uint256 purchaseLimit ; uint256 price ; } Parameter Description NFT The address of the NFT contract. This address cannot be modified after initialization ids A list of token IDs that the vault has received. IDs are appended when the onERC721Received hook is called claimable ids A list of token IDs that are available to claim. A subset of the ids list. Purchase Limit The maximum amount of NFTs that a user is eligible to claim from the category Price Amount to be paid in paymentToken to purchase an NFT","title":"NFTFairVaultBase"},{"location":"nftfair/contracts/vault/base/#createcategory","text":"function createCategory ( address _nft , uint256 _max , uint256 _price ) Initializes a category. Parameter Type Description NFT address The NFT contract address. CANNOT BE CHANGED AFTER INITIALIZATION Max uint256 The maximum amount of NFTs that a user is eligible to claim from the category Price uint256 Amount to be paid in paymentToken to purchase an NFT","title":"createCategory()"},{"location":"nftfair/contracts/vault/base/#updatecategory","text":"function updateCategory ( uint256 _category , uint256 _maxPurchase , uint256 _price ) Updates the properties of a specified category, except for the NFT address . A new category must be created separately for a different NFT contract. Parameter Type Description Category uint256 The integer representation of a category Max uint256 The maximum amount of NFTs that a user is eligible to claim from the category Price uint256 Amount to be paid in paymentToken to purchase an NFT","title":"updateCategory"},{"location":"nftfair/contracts/vault/base/#configurepayment","text":"function configurePayment ( address _newToken , uint256 [] memory _prices ) This function allows changing the payment token and/or updates prices across all categories in a single function call. Parameter Type Description Token address The ERC20 token address Prices uint256[] The length of the array must either be 0 or the total number of categories. This transaction reverts otherwise.","title":"configurePayment"},{"location":"nftfair/contracts/vault/base/#revenuepayout","text":"function revenuePayout ( address _beneficiary , address _token ) The Vault owner calls this function to withdraw revenue out of the vault. Parameter Type Description Beneficiary address The recipient address Token address The ERC20 token address","title":"revenuePayout"},{"location":"nftfair/contracts/vault/base/#recover","text":"function recover ( uint256 [] memory _categoryArr , address _recipient ) The owner can invoke this method to withdraw remaining NFTs from one or more specified categories. This function call effectively empties all categories that are being recovered. Parameter Type Description Categories uint256[] One or more categories Recipient address The recipient address","title":"recover"},{"location":"nftfair/contracts/vault/base/#claimed","text":"function claimed ( address _user , uint256 _category ) public view override returns ( uint256 [] memory ) Returns a list of token IDs that has been claimed by the _user from a specified _category","title":"claimed"},{"location":"nftfair/contracts/vault/base/#getclaimableids","text":"function getClaimableIds ( uint256 _category ) public view override returns ( uint256 [] memory ) Returns a list of available token IDs from a specified _category .","title":"getClaimableIds"},{"location":"nftfair/contracts/vault/base/#getcategoryprice","text":"function getCategoryPrice ( uint256 _category ) external view override returns ( uint256 ) Returns the amount of paymentToken required to purchase a single NFT from the specified _category . Call the paymentToken() method to get the ERC20 address of the payment token.","title":"getCategoryPrice"},{"location":"nftfair/contracts/vault/base/#getcategorynft","text":"function getCategoryNft ( uint256 _category ) external view override returns ( address ) Returns the address of the NFT contract from the specified _category .","title":"getCategoryNft"},{"location":"nftfair/contracts/vault/base/#getcategorynftids","text":"function getCategoryNftIds ( uint256 _category ) external view returns ( uint256 [] memory ) Returns the list of token IDs that has been added into this category. This list excludes token IDs that had been recovered by the owner.","title":"getCategoryNftIds"},{"location":"nftfair/contracts/vault/base/#claimablecount","text":"function claimableCount ( uint256 _category ) external view returns ( uint256 ) Return the number of available token IDs from a specified _category . This base contract can be extended to implement the claim() function. claim() functions are implemented differently by their templates.","title":"claimableCount"},{"location":"nftfair/contracts/vault/templates/fifo/","text":"FIFO Vault \u00b6 First-in-first-out vaults correctly enforce the order of incoming claim transactions. function claim ( uint256 _category , uint256 _id , uint256 _deadline , bytes calldata _sig ) Parameter Type Description Category uint256 The integer representation of a category ID uint256 NFT Token ID to claim Deadline uint256 Transaction reverts at block.timestamp > deadline Sig bytes The user's EIP712 message to authorize the Treasury for collecting the payment. You may pass 0x if paymentToken == address(0)","title":"FIFO Vault"},{"location":"nftfair/contracts/vault/templates/fifo/#fifo-vault","text":"First-in-first-out vaults correctly enforce the order of incoming claim transactions. function claim ( uint256 _category , uint256 _id , uint256 _deadline , bytes calldata _sig ) Parameter Type Description Category uint256 The integer representation of a category ID uint256 NFT Token ID to claim Deadline uint256 Transaction reverts at block.timestamp > deadline Sig bytes The user's EIP712 message to authorize the Treasury for collecting the payment. You may pass 0x if paymentToken == address(0)","title":"FIFO Vault"},{"location":"nftfair/contracts/vault/templates/mysteryboxes/","text":"Mystery Boxes Vault \u00b6 Mystery box style vaults are more restricted than FIFO vaults, in a way that the token ID is randomly chosen and not revealed until the transaction has been broadcasted. function claim ( uint256 _category , uint256 _deadline , bytes calldata _sig ) Parameter Type Description Category uint256 The integer representation of a category Deadline uint256 Transaction reverts at block.timestamp > deadline Sig bytes The user's EIP712 message to authorize the Treasury for collecting the payment. You may pass 0x if paymentToken == address(0)","title":"Mystery Boxes Vault"},{"location":"nftfair/contracts/vault/templates/mysteryboxes/#mystery-boxes-vault","text":"Mystery box style vaults are more restricted than FIFO vaults, in a way that the token ID is randomly chosen and not revealed until the transaction has been broadcasted. function claim ( uint256 _category , uint256 _deadline , bytes calldata _sig ) Parameter Type Description Category uint256 The integer representation of a category Deadline uint256 Transaction reverts at block.timestamp > deadline Sig bytes The user's EIP712 message to authorize the Treasury for collecting the payment. You may pass 0x if paymentToken == address(0)","title":"Mystery Boxes Vault"},{"location":"nftfair/users/activities/","text":"Homepage \u00b6 The homepage is the main site where users can find a listing of past, current and future Fairdrop events. Every activity in the list contains information about a particular Fairdrop event, such as the network, the length of duration, the type of Fairdrop and the total amount of NFTs on sale (or to be given away). Users can click on the \"Visit Activity Page\" button to be redirected to the activity site, which is created specifically for an individual event. Activity Sites \u00b6 The activity page is individually deployed and designated for a selected Fairdrop event. This user-facing site facilitates user interaction with the vault contract, as well as, providing detailed information about the Fairdrop, such as the remaining time, number of NFTs available to purchase, pricing and FAQs. To claim/purchase NFTs, the user must satisfy all of the following conditions: Eligible to participate in the Fairdrop Users have the sufficient token balance to pay for transaction fee and NFT purchase User's total number of claim/purchase does not exceed the maximum limit. Users may only purchase NFT(s) within the duration of the event. Users may be prompted to submit an approve() transaction for an ERC20 token that do not have prior history with the protocol. In other words, an approve() transaction prompt is always required to authorize new ERC20 tokens to be used for payment to be collected by the Treasury contract. Once all of the above conditions have met, users may select one (or more) category that they wish to claim an NFT from. Users are then prompted to sign two EIP712 messages for authentication. The first message gives permission to the Conveyor relayer to collect ERC20 payment token, with the amount closely equivalent to the market gas price. The second message gives permission to the NFTPlatform treasury contract to collect sales payment for the purchase of NFTs. Users may not be required to sign this message, if an NFT were to be distributed free of charge. Check out this video to see NFTFair in action.","title":"Overview"},{"location":"nftfair/users/activities/#homepage","text":"The homepage is the main site where users can find a listing of past, current and future Fairdrop events. Every activity in the list contains information about a particular Fairdrop event, such as the network, the length of duration, the type of Fairdrop and the total amount of NFTs on sale (or to be given away). Users can click on the \"Visit Activity Page\" button to be redirected to the activity site, which is created specifically for an individual event.","title":"Homepage"},{"location":"nftfair/users/activities/#activity-sites","text":"The activity page is individually deployed and designated for a selected Fairdrop event. This user-facing site facilitates user interaction with the vault contract, as well as, providing detailed information about the Fairdrop, such as the remaining time, number of NFTs available to purchase, pricing and FAQs. To claim/purchase NFTs, the user must satisfy all of the following conditions: Eligible to participate in the Fairdrop Users have the sufficient token balance to pay for transaction fee and NFT purchase User's total number of claim/purchase does not exceed the maximum limit. Users may only purchase NFT(s) within the duration of the event. Users may be prompted to submit an approve() transaction for an ERC20 token that do not have prior history with the protocol. In other words, an approve() transaction prompt is always required to authorize new ERC20 tokens to be used for payment to be collected by the Treasury contract. Once all of the above conditions have met, users may select one (or more) category that they wish to claim an NFT from. Users are then prompted to sign two EIP712 messages for authentication. The first message gives permission to the Conveyor relayer to collect ERC20 payment token, with the amount closely equivalent to the market gas price. The second message gives permission to the NFTPlatform treasury contract to collect sales payment for the purchase of NFTs. Users may not be required to sign this message, if an NFT were to be distributed free of charge. Check out this video to see NFTFair in action.","title":"Activity Sites"},{"location":"nftfair/users/faq/","text":"Frequently Asked Questions \u00b6 General \u00b6 1. What is NFTFair? How is this platform different from other NFT platforms? (e.g. OpenSea) \u00b6 NFTFair is a platform that integrates Conveyor to ensure NFTs are being distributed (or sold) fairly, in a manner which the average users should not be put in a disadvantage of getting frontrun by technologically sophisticated buyers or trading bots. Conveyor achieves Fairness by enforcing the correct ordering of transactions to reduce MEV. Click here to learn more about Conveyor's MEV minimization solution. 2. What is a Fairdrop? \u00b6 A Fairdrop is a single NFT distribution event being held for a certain duration. A vault contract is deployed and to be used only for a single Fairdrop event, which stores a fixed number of NFTs that is ready to be claimed by Fairdrop participants. A user-facing activity site is also created for a Fairdrop event, for participants to easily interact with the vault contract to claim NFTs. Partners \u00b6 1. Can I start a Fairdrop activity to sell or give away NFTs from an existing contract? \u00b6 Currently, this platform only supports NFT contract that follows the ERC721 standard. Please reach out to us at nftfair@ata.network , and we will gladly assist you with the deployment of your very own Fairdrop activity. Participants \u00b6 1. Why am I not qualified to claim NFTs? \u00b6 Certain Fairdrop events may be limited for participants that are in a whitelist. If you are not an eligible participants, please reach out to the Fairdrop organizer directly, since we do not have control over whitelists. 2. How much does it cost to claim NFTs? \u00b6 The price varies by the Fairdrop event and its category. You can find NFT pricings on the activity site. 3. How many NFTs can I claim? \u00b6 This also varies by the event and its category. More info can be found on the activity site. 4. Why am I prompted to send an approve() transaction? What am I approving? \u00b6 If this is your first time using Conveyor, you are likely prompted to send at most two approve() transactions. The first approve() transaction grants permission for the collection of gas payment ERC20 tokens. There are certain scenarios which may omit this requirement, such as: Certain Fairdrop events may be opting for relayer-sponsored transactions. In this case, users do not bear the cost of Conveyor transaction fees. User's token of choice has previously been approved for other Conveyor projects. The second approve() transaction grants permission to the Treasury contract for collecting payment from NFT sales. This permission is valid for all vaults and other contracts on the platform that are receiving payments via the Treasury contract. 5. Why do I still have to sign two EIP712 messages? \u00b6 Sending approve() transactions as a mean of assigning allowance for the transfer of ERC20 tokens requires the users to hold native currencies to pay for gas. Requesting an approval for every single token transfers does not provide the smoothest user experience. A good workaround this issue is to allocate a very large amount of allowance for the spender, so users would only have to approve() once. This however, puts a huge trust on the spender to not drain the user's allowance at its will. To eliminate trust, the spender is subjected to a secondary approval process by requiring user's signed EIP 712 message, without needing to pay for gas. The first signature is verified by the Conveyor relayer to collect ERC20 payment token, with the amount closely equivalent to the market gas price. The second message is sent to the NFTPlatform treasury contract to collect sales payment for the purchase of NFTs. Users may not be required to sign this message, if an NFT were to be distributed free of charge.","title":"FAQs"},{"location":"nftfair/users/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"nftfair/users/faq/#general","text":"","title":"General"},{"location":"nftfair/users/faq/#1-what-is-nftfair-how-is-this-platform-different-from-other-nft-platforms-eg-opensea","text":"NFTFair is a platform that integrates Conveyor to ensure NFTs are being distributed (or sold) fairly, in a manner which the average users should not be put in a disadvantage of getting frontrun by technologically sophisticated buyers or trading bots. Conveyor achieves Fairness by enforcing the correct ordering of transactions to reduce MEV. Click here to learn more about Conveyor's MEV minimization solution.","title":"1. What is NFTFair? How is this platform different from other NFT platforms? (e.g. OpenSea)"},{"location":"nftfair/users/faq/#2-what-is-a-fairdrop","text":"A Fairdrop is a single NFT distribution event being held for a certain duration. A vault contract is deployed and to be used only for a single Fairdrop event, which stores a fixed number of NFTs that is ready to be claimed by Fairdrop participants. A user-facing activity site is also created for a Fairdrop event, for participants to easily interact with the vault contract to claim NFTs.","title":"2. What is a Fairdrop?"},{"location":"nftfair/users/faq/#partners","text":"","title":"Partners"},{"location":"nftfair/users/faq/#1-can-i-start-a-fairdrop-activity-to-sell-or-give-away-nfts-from-an-existing-contract","text":"Currently, this platform only supports NFT contract that follows the ERC721 standard. Please reach out to us at nftfair@ata.network , and we will gladly assist you with the deployment of your very own Fairdrop activity.","title":"1. Can I start a Fairdrop activity to sell or give away NFTs from an existing contract?"},{"location":"nftfair/users/faq/#participants","text":"","title":"Participants"},{"location":"nftfair/users/faq/#1-why-am-i-not-qualified-to-claim-nfts","text":"Certain Fairdrop events may be limited for participants that are in a whitelist. If you are not an eligible participants, please reach out to the Fairdrop organizer directly, since we do not have control over whitelists.","title":"1. Why am I not qualified to claim NFTs?"},{"location":"nftfair/users/faq/#2-how-much-does-it-cost-to-claim-nfts","text":"The price varies by the Fairdrop event and its category. You can find NFT pricings on the activity site.","title":"2. How much does it cost to claim NFTs?"},{"location":"nftfair/users/faq/#3-how-many-nfts-can-i-claim","text":"This also varies by the event and its category. More info can be found on the activity site.","title":"3. How many NFTs can I claim?"},{"location":"nftfair/users/faq/#4-why-am-i-prompted-to-send-an-approve-transaction-what-am-i-approving","text":"If this is your first time using Conveyor, you are likely prompted to send at most two approve() transactions. The first approve() transaction grants permission for the collection of gas payment ERC20 tokens. There are certain scenarios which may omit this requirement, such as: Certain Fairdrop events may be opting for relayer-sponsored transactions. In this case, users do not bear the cost of Conveyor transaction fees. User's token of choice has previously been approved for other Conveyor projects. The second approve() transaction grants permission to the Treasury contract for collecting payment from NFT sales. This permission is valid for all vaults and other contracts on the platform that are receiving payments via the Treasury contract.","title":"4. Why am I prompted to send an approve() transaction? What am I approving?"},{"location":"nftfair/users/faq/#5-why-do-i-still-have-to-sign-two-eip712-messages","text":"Sending approve() transactions as a mean of assigning allowance for the transfer of ERC20 tokens requires the users to hold native currencies to pay for gas. Requesting an approval for every single token transfers does not provide the smoothest user experience. A good workaround this issue is to allocate a very large amount of allowance for the spender, so users would only have to approve() once. This however, puts a huge trust on the spender to not drain the user's allowance at its will. To eliminate trust, the spender is subjected to a secondary approval process by requiring user's signed EIP 712 message, without needing to pay for gas. The first signature is verified by the Conveyor relayer to collect ERC20 payment token, with the amount closely equivalent to the market gas price. The second message is sent to the NFTPlatform treasury contract to collect sales payment for the purchase of NFTs. Users may not be required to sign this message, if an NFT were to be distributed free of charge.","title":"5. Why do I still have to sign two EIP712 messages?"},{"location":"witness/api/","text":"Witness API \u00b6 JSON-RPC is a remote procedure call protocol encoded in JSON. You can use this API to send queries to our Geode instance for Witness. Available Endpoints \u00b6 Provider(s) URL(s) Witness Geode Mainnet https://witness-geode-mainnet.ata.network:3350 JSON-RPC Methods \u00b6 geode_witness_vote \u00b6 Submits a signed Vote message in EIP712 format. Endpoint \u00b6 https://witness-geode-mainnet.ata.network:3350/v0/geode_witness_vote Return Code \u00b6 Returns an integer representing the status of the operation. Return Code Description 0 Success 1 SignatureFailure 2 ProposalNotActive 3 AlreadyVote 4 MissingWorkspace 5 IncorrectChainId 6 InternalError 7 WorkspaceDataError 8 ChainError 9 InsufficientBalance The function takes in a signed vote in EIP712 format. Data Format \u00b6 Request Format \u00b6 { \"id\" : 0 , \"jsonrpc\" : \"2.0\" , \"method\" : \"geode_witness_vote\" , \"params\" : { \"vote\" : Sig ne dEIP 712 Vo te } } SignedEIP712Vote Format \u00b6 { \"msg\" : EIP 712 Vo te , \"v\" : U 256 , \"r\" : H 256 , \"s\" : H 256 , } { type : \"object\" , properties : { msg : { type : \"object\" }, v : { type : \"string\" }, r : { type : \"string\" }, s : { type : \"string\" } }, required : [ \"msg\" , \"v\" , \"r\" , \"s\" ] } EIP712Vote Format \u00b6 { \"types\" : { \"EIP712Domain\" : EIP 712 Domai n Type , \"Vote\" : Vo te Type , }, \"domain\" : EIP 712 Domai n Da ta , \"primaryType\" : S tr i n g , \"message\" : Vo te , } { type : \"object\" , properties : { types : { type : \"object\" , properties : { EIP712Domain : { type : \"array\" , items : { name : \"string\" , type : \"string\" }, minItems : 4 , maxItems : 4 }, Vote : { type : \"array\" , items : { name : \"string\" , type : \"string\" }, minItems : 4 , maxItems : 4 }, }, required : [ \"EIP712Domain\" , \"Vote\" ] }, domain : { type : \"object\" , properties : { name : \"string\" , version : \"string\" , chainId : \"string\" , verifyingContract : \"string\" }, required : [ \"name\" , \"version\" , \"chainId\" , \"verifyingContract\" ] }, primaryType : { type : \"string\" }, message : { type : \"object\" } }, required : [ \"types\" , \"domain\" , \"primaryType\" , \"message\" ] } Vote Format \u00b6 { type : \"object\" , properties : { voter : \"string\" , proposal : \"string\" , option : \"number\" , timestamp : \"number\" }, required : [ \"voter\" , \"primaryType\" , \"domain\" , \"message\" ] } Sample JSON-RPC Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"method\" : \"geode_witness_vote\" , \"params\" :{ \"vote\" :{ \"msg\" :{ \"types\" :{ \"EIP712Domain\" :[ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"version\" , \"type\" : \"string\" }, { \"name\" : \"chainId\" , \"type\" : \"uint256\" }, { \"name\" : \"verifyingContract\" , \"type\" : \"address\" } ], \"Vote\" :[ { \"name\" : \"voter\" , \"type\" : \"uint256\" }, { \"name\" : \"proposal\" , \"type\" : \"uint256\" }, { \"name\" : \"option\" , \"type\" : \"uint32\" }, { \"name\" : \"timestamp\" , \"type\" : \"uint64\" } ] }, \"domain\" :{ \"name\" : \"Witness\" , \"version\" : \"0.1.0\" , \"chainId\" : \"42\" , \"verifyingContract\" : \"0xdEB55768F6D1a3E6771A4096531aD6ea258A925e\" }, \"primaryType\" : \"Vote\" , \"message\" :{ \"voter\" : \"0x0000000000000000000000007ef99b0e5beb8ae42dbf126b40b87410a440a32a\" , \"proposal\" : \"0x10002c\" , \"option\" : 2 , \"timestamp\" : 1617188809 } }, \"v\" : 28 , \"r\" : \"0x491b2a733067508f789bb4d180329b1fd9327d79a8135997eada08b3217cbb72\" , \"s\" : \"0x4e48960bef350ea161c997c3c2e881329de0d09d4fddb5781c6719308cc6b260\" } }, \"id\" : 73 } Sample Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"result\" : 0 , \"id\" : 73 } Metamask Support \u00b6 You can use Metamask for signing and sending the message by refering here: Sign-Typed-Data-v4 .","title":"Witness API"},{"location":"witness/api/#witness-api","text":"JSON-RPC is a remote procedure call protocol encoded in JSON. You can use this API to send queries to our Geode instance for Witness.","title":"Witness API"},{"location":"witness/api/#available-endpoints","text":"Provider(s) URL(s) Witness Geode Mainnet https://witness-geode-mainnet.ata.network:3350","title":"Available Endpoints"},{"location":"witness/api/#json-rpc-methods","text":"","title":"JSON-RPC Methods"},{"location":"witness/api/#geode_witness_vote","text":"Submits a signed Vote message in EIP712 format.","title":"geode_witness_vote"},{"location":"witness/api/#endpoint","text":"https://witness-geode-mainnet.ata.network:3350/v0/geode_witness_vote","title":"Endpoint"},{"location":"witness/api/#return-code","text":"Returns an integer representing the status of the operation. Return Code Description 0 Success 1 SignatureFailure 2 ProposalNotActive 3 AlreadyVote 4 MissingWorkspace 5 IncorrectChainId 6 InternalError 7 WorkspaceDataError 8 ChainError 9 InsufficientBalance The function takes in a signed vote in EIP712 format.","title":"Return Code"},{"location":"witness/api/#data-format","text":"","title":"Data Format"},{"location":"witness/api/#request-format","text":"{ \"id\" : 0 , \"jsonrpc\" : \"2.0\" , \"method\" : \"geode_witness_vote\" , \"params\" : { \"vote\" : Sig ne dEIP 712 Vo te } }","title":"Request Format"},{"location":"witness/api/#signedeip712vote-format","text":"{ \"msg\" : EIP 712 Vo te , \"v\" : U 256 , \"r\" : H 256 , \"s\" : H 256 , } { type : \"object\" , properties : { msg : { type : \"object\" }, v : { type : \"string\" }, r : { type : \"string\" }, s : { type : \"string\" } }, required : [ \"msg\" , \"v\" , \"r\" , \"s\" ] }","title":"SignedEIP712Vote Format"},{"location":"witness/api/#eip712vote-format","text":"{ \"types\" : { \"EIP712Domain\" : EIP 712 Domai n Type , \"Vote\" : Vo te Type , }, \"domain\" : EIP 712 Domai n Da ta , \"primaryType\" : S tr i n g , \"message\" : Vo te , } { type : \"object\" , properties : { types : { type : \"object\" , properties : { EIP712Domain : { type : \"array\" , items : { name : \"string\" , type : \"string\" }, minItems : 4 , maxItems : 4 }, Vote : { type : \"array\" , items : { name : \"string\" , type : \"string\" }, minItems : 4 , maxItems : 4 }, }, required : [ \"EIP712Domain\" , \"Vote\" ] }, domain : { type : \"object\" , properties : { name : \"string\" , version : \"string\" , chainId : \"string\" , verifyingContract : \"string\" }, required : [ \"name\" , \"version\" , \"chainId\" , \"verifyingContract\" ] }, primaryType : { type : \"string\" }, message : { type : \"object\" } }, required : [ \"types\" , \"domain\" , \"primaryType\" , \"message\" ] }","title":"EIP712Vote Format"},{"location":"witness/api/#vote-format","text":"{ type : \"object\" , properties : { voter : \"string\" , proposal : \"string\" , option : \"number\" , timestamp : \"number\" }, required : [ \"voter\" , \"primaryType\" , \"domain\" , \"message\" ] }","title":"Vote Format"},{"location":"witness/api/#sample-json-rpc-request","text":"{ \"jsonrpc\" : \"2.0\" , \"method\" : \"geode_witness_vote\" , \"params\" :{ \"vote\" :{ \"msg\" :{ \"types\" :{ \"EIP712Domain\" :[ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"version\" , \"type\" : \"string\" }, { \"name\" : \"chainId\" , \"type\" : \"uint256\" }, { \"name\" : \"verifyingContract\" , \"type\" : \"address\" } ], \"Vote\" :[ { \"name\" : \"voter\" , \"type\" : \"uint256\" }, { \"name\" : \"proposal\" , \"type\" : \"uint256\" }, { \"name\" : \"option\" , \"type\" : \"uint32\" }, { \"name\" : \"timestamp\" , \"type\" : \"uint64\" } ] }, \"domain\" :{ \"name\" : \"Witness\" , \"version\" : \"0.1.0\" , \"chainId\" : \"42\" , \"verifyingContract\" : \"0xdEB55768F6D1a3E6771A4096531aD6ea258A925e\" }, \"primaryType\" : \"Vote\" , \"message\" :{ \"voter\" : \"0x0000000000000000000000007ef99b0e5beb8ae42dbf126b40b87410a440a32a\" , \"proposal\" : \"0x10002c\" , \"option\" : 2 , \"timestamp\" : 1617188809 } }, \"v\" : 28 , \"r\" : \"0x491b2a733067508f789bb4d180329b1fd9327d79a8135997eada08b3217cbb72\" , \"s\" : \"0x4e48960bef350ea161c997c3c2e881329de0d09d4fddb5781c6719308cc6b260\" } }, \"id\" : 73 }","title":"Sample JSON-RPC Request"},{"location":"witness/api/#sample-response","text":"{ \"jsonrpc\" : \"2.0\" , \"result\" : 0 , \"id\" : 73 }","title":"Sample Response"},{"location":"witness/api/#metamask-support","text":"You can use Metamask for signing and sending the message by refering here: Sign-Typed-Data-v4 .","title":"Metamask Support"},{"location":"witness/introduction/","text":"Introduction \u00b6 Automata Witness is a customizable voting service for decentralized applications. Witness provides a fully decentralized voting platform (with privacy features) across different blockchains. Features \u00b6 Privacy : You can choose different types of votes with different privacy levels e.g. Public (full disclosure of voter address and number of votes), Medium (only number of votes), and Private (only voting result is published \u2014 voter identities and number of votes are not). Low-cost : Voting is conducted off-chain so there is no gas cost and a wider range of token holders can participate in governance without being deterred by high gas fees. Chainhook : Trigger on-chain execution based on the voting results. Chainhook enables calling of the on-chain contract which was registered at proposal creation. Modularity : Each of these functions can be used as standalones, or together. If a project wants to use Witness as a signaling tool without on-chain execution, that is also possible. Platforms \u00b6 Witness currently supports the following with more to be added in future: Ethereum (Mainnet, Kovan Testnet) Binance Smart Chain (Mainnet, Testnet) Plasm Network (Dusty Testnet) Clover Finance (Testnet) Darwinia (Pangolin Testnet) Moonbase (Alpha Testnet) Polygon (Matic Mainnet) Avalanche (Mainnet) HECO (Mainnet, Testnet) Next, we will be adding other EVM-based chains and Substrate-based chains to the list. Feature Support \u00b6 Platform Private Voting Chainhook Public Voting Ethereum Mainnet Ethereum Kovan Testnet Binance Smart Chain Mainnet Binance Smart Chain Testnet Plasm Network Dusty Testnet Clover Finance Testnet Darwinia Pangolin Testnet Moonbase Alpha Testnet Polygon Avalanche HECO Mainnet HECO Testnet","title":"Introduction"},{"location":"witness/introduction/#introduction","text":"Automata Witness is a customizable voting service for decentralized applications. Witness provides a fully decentralized voting platform (with privacy features) across different blockchains.","title":"Introduction"},{"location":"witness/introduction/#features","text":"Privacy : You can choose different types of votes with different privacy levels e.g. Public (full disclosure of voter address and number of votes), Medium (only number of votes), and Private (only voting result is published \u2014 voter identities and number of votes are not). Low-cost : Voting is conducted off-chain so there is no gas cost and a wider range of token holders can participate in governance without being deterred by high gas fees. Chainhook : Trigger on-chain execution based on the voting results. Chainhook enables calling of the on-chain contract which was registered at proposal creation. Modularity : Each of these functions can be used as standalones, or together. If a project wants to use Witness as a signaling tool without on-chain execution, that is also possible.","title":"Features"},{"location":"witness/introduction/#platforms","text":"Witness currently supports the following with more to be added in future: Ethereum (Mainnet, Kovan Testnet) Binance Smart Chain (Mainnet, Testnet) Plasm Network (Dusty Testnet) Clover Finance (Testnet) Darwinia (Pangolin Testnet) Moonbase (Alpha Testnet) Polygon (Matic Mainnet) Avalanche (Mainnet) HECO (Mainnet, Testnet) Next, we will be adding other EVM-based chains and Substrate-based chains to the list.","title":"Platforms"},{"location":"witness/introduction/#feature-support","text":"Platform Private Voting Chainhook Public Voting Ethereum Mainnet Ethereum Kovan Testnet Binance Smart Chain Mainnet Binance Smart Chain Testnet Plasm Network Dusty Testnet Clover Finance Testnet Darwinia Pangolin Testnet Moonbase Alpha Testnet Polygon Avalanche HECO Mainnet HECO Testnet","title":"Feature Support"},{"location":"witness/user-guide/","text":"Getting started \u00b6 For Users \u00b6 First, choose the blockchain network that you wish to connect to. Then search for the project in the Search bar. Look for the proposal that you are interested in voting for. Attention Before voting, please ensure that: Your MetaMask wallet is connected to the corresponding network you are voting in. You can get necessary info about the blockchains we support here and follow these instructions to add to your MetaMask wallet Your account has the necessary number of ERC20/BEP20 tokens to qualify for the vote as specified by the block height in the snapshot . Note If you wish to get tokens for the testnet, please refer to the Getting tokens section for more information Once you have obtained tokens, you can participate in the vote by clicking on your option of choice. Currently, we are calculating the token balance for each voter based on the block height that each proposal mandates. The results of vote can be seen after the vote has concluded and finazlied. For Private Proposals: Only the final winning option will be shown For Medium Proposals: The number of votes for each option will be shown. For Public Proposals: The voter information will be transparent to the public. For Project Owners \u00b6 Project owners can create a workspace for hosting proposals. Project teams or community members can then proceed to create proposals. Currently the metadata is stored on the testnet of Automata Network. Connect to the testnet to create workspaces or propsals. Adding the Automata Network testnet to your network \u00b6 Add the Automata Network to your existing network using the following details: Field Value Network Name Automata Network New RPC URL https://rpcv3.ata.network/ Chain ID 86 Currency Symbol ATA The option to add network can be found by clicking on: Profile Picture >> Settings >> Networks >> Add Network or: Network name >> Custom RPC Connecting Your Metamask Wallet \u00b6 If you see Connect wallet or Not connected show up in your MetaMask, this means that you are not connected ! You can follow these steps to connect your wallet: Click on Connect wallet at the top right corner Click on MetaMask Select the account you wish to connect with MetaMask Connect your account Creating a workspace \u00b6 You can create a workspace from the landing page Witness . Tips Before creating a workspace for your token, please ensure the following: Your MetaMask wallet is connected to Automata Network Your account has the necessary ATA tokens If you do not have the necessary tokens, please refer to Getting tokens . Once ready, you can create a workspace by: Clicking on Create Choose the correct blockchain network for your workspace Fill in your workspace name Fill in your workspace specifications Enter your token contract hash Click on Create Creating a new proposal \u00b6 Head over to the workspace of a project you're interested in creating a proposal for. If the workspace has not been created yet, refer to Creating a Workspace . Tips Before creating a proposal, please ensure that: Your MetaMask wallet is connected to Automata Network Your account has the necessary ATA tokens If you do not have the necessary tokens, you can refer to Getting tokens . Once ready, you can create a proposal by: Clicking on New Proposal Fill in your proposal title Fill in content for your proposal Add / Edit / Remove your voting options Select the start and end date Click on Publish Chainhook \u00b6 This feature enables calling of the on-chain contract which was registered at proposal creation. Note this is still in beta so it's only enabled for selected platform currently. Each voting option can be followed with a chainhook or, you can create a chainhook by: Clicking on Add Chainhook followed by the option field Choose the smart contract language for your Chainhook Fill in the contract address where your Chainhook will take effect Fill in the function name Add arguments for your callback function Each argument is paired with the type and the value field Currently only uint256, uint256[], address, address[] are supported as argument types Follow the example for input value by hovering above the value field Appendix \u00b6 Setting up MetaMask \u00b6 MetaMask is a cryptocurrency wallet used to interact with the Ethereum blockchain. As it is required when using Automata Network, you can install the extension via the official download page here , or simply add the extension for your browser using the links below: Chrome Firefox Brave Edge Getting tokens \u00b6 Getting ERC20 tokens (Ethereum Kovan Network) \u00b6 To get your tokens, head over to our faucet at https://faucet.ata.network/ . Copy the address of your account in MetaMask by clicking on 'Copy to Clipboard' and then paste the address into the input field for your desired token. Click Submit . When receiving ERC-20 tokens, the relevant contract hash can be found right next to the words \"Ethereum Kovan Network\". You can copy this by clicking on the Copy button next to it. Getting BEP20 tokens in the Binance Smart Chain test network \u00b6 To get tokens in the BSC test network, you can search for the contract address using https://testnet.bscscan.com/ . Use the faucet https://testnet.venus.io/faucet or https://testnet.binance.org/faucet-smart to get tokens. Supported Chain Info \u00b6 Field Value Network Name BSC mainnet New RPC URL https://bsc-dataseed1.defibit.io/ Chain ID 56 Field Value Network Name BSC testnet New RPC URL https://data-seed-prebsc-1-s1.binance.org:8545/ Chain ID 97 Field Value Network Name Plasm Dusty testnet New RPC URL https://rpc.dusty.plasmnet.io:8545/ Chain ID 80 Field Value Network Name Clover testnet New RPC URL https://rpc.clover.finance/ Chain ID 1023 Field Value Network Name Dawinia Pangolin testnet New RPC URL https://pangolin-rpc.darwinia.network/ Chain ID 43 Field Value Network Name Moonbase Alpha testnet New RPC URL https://rpc.testnet.moonbeam.network/ Chain ID 1287 Field Value Network Name Polygon New RPC URL https://rpc-mainnet.matic.network Chain ID 137 Field Value Network Name Avalanche New RPC URL https://api.avax.network/ext/bc/C/rpc Chain ID 43114 Ethereum Mainnet and Kovan Testnet are not listed here since they are natively supported by Metamask Get supported by Witness \u00b6 We are open to onboard any EVM networks as our first batch of supported networks by Witness. The following details are required for us to complete the onboarding. The integration only involves small changes in Witness on our side. Chain ID JSON-RPC URL Blockchain Explorer URL (optional) Faucet (for testnet)","title":"User Guide"},{"location":"witness/user-guide/#getting-started","text":"","title":"Getting started"},{"location":"witness/user-guide/#for-users","text":"First, choose the blockchain network that you wish to connect to. Then search for the project in the Search bar. Look for the proposal that you are interested in voting for. Attention Before voting, please ensure that: Your MetaMask wallet is connected to the corresponding network you are voting in. You can get necessary info about the blockchains we support here and follow these instructions to add to your MetaMask wallet Your account has the necessary number of ERC20/BEP20 tokens to qualify for the vote as specified by the block height in the snapshot . Note If you wish to get tokens for the testnet, please refer to the Getting tokens section for more information Once you have obtained tokens, you can participate in the vote by clicking on your option of choice. Currently, we are calculating the token balance for each voter based on the block height that each proposal mandates. The results of vote can be seen after the vote has concluded and finazlied. For Private Proposals: Only the final winning option will be shown For Medium Proposals: The number of votes for each option will be shown. For Public Proposals: The voter information will be transparent to the public.","title":"For Users"},{"location":"witness/user-guide/#for-project-owners","text":"Project owners can create a workspace for hosting proposals. Project teams or community members can then proceed to create proposals. Currently the metadata is stored on the testnet of Automata Network. Connect to the testnet to create workspaces or propsals.","title":"For Project Owners"},{"location":"witness/user-guide/#adding-the-automata-network-testnet-to-your-network","text":"Add the Automata Network to your existing network using the following details: Field Value Network Name Automata Network New RPC URL https://rpcv3.ata.network/ Chain ID 86 Currency Symbol ATA The option to add network can be found by clicking on: Profile Picture >> Settings >> Networks >> Add Network or: Network name >> Custom RPC","title":"Adding the Automata Network testnet to your network"},{"location":"witness/user-guide/#connecting-your-metamask-wallet","text":"If you see Connect wallet or Not connected show up in your MetaMask, this means that you are not connected ! You can follow these steps to connect your wallet: Click on Connect wallet at the top right corner Click on MetaMask Select the account you wish to connect with MetaMask Connect your account","title":"Connecting Your Metamask Wallet"},{"location":"witness/user-guide/#creating-a-workspace","text":"You can create a workspace from the landing page Witness . Tips Before creating a workspace for your token, please ensure the following: Your MetaMask wallet is connected to Automata Network Your account has the necessary ATA tokens If you do not have the necessary tokens, please refer to Getting tokens . Once ready, you can create a workspace by: Clicking on Create Choose the correct blockchain network for your workspace Fill in your workspace name Fill in your workspace specifications Enter your token contract hash Click on Create","title":"Creating a workspace"},{"location":"witness/user-guide/#creating-a-new-proposal","text":"Head over to the workspace of a project you're interested in creating a proposal for. If the workspace has not been created yet, refer to Creating a Workspace . Tips Before creating a proposal, please ensure that: Your MetaMask wallet is connected to Automata Network Your account has the necessary ATA tokens If you do not have the necessary tokens, you can refer to Getting tokens . Once ready, you can create a proposal by: Clicking on New Proposal Fill in your proposal title Fill in content for your proposal Add / Edit / Remove your voting options Select the start and end date Click on Publish","title":"Creating a new proposal"},{"location":"witness/user-guide/#chainhook","text":"This feature enables calling of the on-chain contract which was registered at proposal creation. Note this is still in beta so it's only enabled for selected platform currently. Each voting option can be followed with a chainhook or, you can create a chainhook by: Clicking on Add Chainhook followed by the option field Choose the smart contract language for your Chainhook Fill in the contract address where your Chainhook will take effect Fill in the function name Add arguments for your callback function Each argument is paired with the type and the value field Currently only uint256, uint256[], address, address[] are supported as argument types Follow the example for input value by hovering above the value field","title":"Chainhook"},{"location":"witness/user-guide/#appendix","text":"","title":"Appendix"},{"location":"witness/user-guide/#setting-up-metamask","text":"MetaMask is a cryptocurrency wallet used to interact with the Ethereum blockchain. As it is required when using Automata Network, you can install the extension via the official download page here , or simply add the extension for your browser using the links below: Chrome Firefox Brave Edge","title":"Setting up MetaMask"},{"location":"witness/user-guide/#getting-tokens","text":"","title":"Getting tokens"},{"location":"witness/user-guide/#getting-erc20-tokens-ethereum-kovan-network","text":"To get your tokens, head over to our faucet at https://faucet.ata.network/ . Copy the address of your account in MetaMask by clicking on 'Copy to Clipboard' and then paste the address into the input field for your desired token. Click Submit . When receiving ERC-20 tokens, the relevant contract hash can be found right next to the words \"Ethereum Kovan Network\". You can copy this by clicking on the Copy button next to it.","title":"Getting ERC20 tokens (Ethereum Kovan Network)"},{"location":"witness/user-guide/#getting-bep20-tokens-in-the-binance-smart-chain-test-network","text":"To get tokens in the BSC test network, you can search for the contract address using https://testnet.bscscan.com/ . Use the faucet https://testnet.venus.io/faucet or https://testnet.binance.org/faucet-smart to get tokens.","title":"Getting BEP20 tokens in the Binance Smart Chain test network"},{"location":"witness/user-guide/#supported-chain-info","text":"Field Value Network Name BSC mainnet New RPC URL https://bsc-dataseed1.defibit.io/ Chain ID 56 Field Value Network Name BSC testnet New RPC URL https://data-seed-prebsc-1-s1.binance.org:8545/ Chain ID 97 Field Value Network Name Plasm Dusty testnet New RPC URL https://rpc.dusty.plasmnet.io:8545/ Chain ID 80 Field Value Network Name Clover testnet New RPC URL https://rpc.clover.finance/ Chain ID 1023 Field Value Network Name Dawinia Pangolin testnet New RPC URL https://pangolin-rpc.darwinia.network/ Chain ID 43 Field Value Network Name Moonbase Alpha testnet New RPC URL https://rpc.testnet.moonbeam.network/ Chain ID 1287 Field Value Network Name Polygon New RPC URL https://rpc-mainnet.matic.network Chain ID 137 Field Value Network Name Avalanche New RPC URL https://api.avax.network/ext/bc/C/rpc Chain ID 43114 Ethereum Mainnet and Kovan Testnet are not listed here since they are natively supported by Metamask","title":"Supported Chain Info"},{"location":"witness/user-guide/#get-supported-by-witness","text":"We are open to onboard any EVM networks as our first batch of supported networks by Witness. The following details are required for us to complete the onboarding. The integration only involves small changes in Witness on our side. Chain ID JSON-RPC URL Blockchain Explorer URL (optional) Faucet (for testnet)","title":"Get supported by Witness"},{"location":"xata/faq/","text":"FAQ \u00b6 Frequently asked questions. Would there be a XATA token? There is no XATA token launched at the moment. Please do no engage in any form of trade or liquidity farming with any XATA token out there at the moment. Are there any risks in providing to a liquidity pool like ATA/USDT? Yes. All liquidity farming activities are subjected to the risk of impermanent loss. You will need to do your own calculations as to whether yield farming and earning LP fees are more profitable than holding ATA itself to decide on the best choice of action. More information on impermanent loss can be found in this article: https://academy.binance.com/en/articles/impermanent-loss-explained How do I connect on my mobile browser? You will need to select wallet connect which will generate a QR code. Use your mobile Metamask app to scan the QR code to approve transactions on your mobile browser. Why does my transaction keep getting rejected? This might be due to the fact that you have not enough tokens to pay for fees, or that the network is congested at the moment. \u200b If you urgently need to access the network when it is congested, you can consider using other RPCs for each of these chains based on these articles: BSC RPCs: https://docs.binance.org/smart-chain/developer/rpc.html Polygon Aggregator RPC: https://blog.polygon.technology/polygon-rpc-gateway-will-provide-a-free-high-performance-connection-to-the-polygon-pos-blockchain/\u200b","title":"FAQ"},{"location":"xata/faq/#faq","text":"Frequently asked questions. Would there be a XATA token? There is no XATA token launched at the moment. Please do no engage in any form of trade or liquidity farming with any XATA token out there at the moment. Are there any risks in providing to a liquidity pool like ATA/USDT? Yes. All liquidity farming activities are subjected to the risk of impermanent loss. You will need to do your own calculations as to whether yield farming and earning LP fees are more profitable than holding ATA itself to decide on the best choice of action. More information on impermanent loss can be found in this article: https://academy.binance.com/en/articles/impermanent-loss-explained How do I connect on my mobile browser? You will need to select wallet connect which will generate a QR code. Use your mobile Metamask app to scan the QR code to approve transactions on your mobile browser. Why does my transaction keep getting rejected? This might be due to the fact that you have not enough tokens to pay for fees, or that the network is congested at the moment. \u200b If you urgently need to access the network when it is congested, you can consider using other RPCs for each of these chains based on these articles: BSC RPCs: https://docs.binance.org/smart-chain/developer/rpc.html Polygon Aggregator RPC: https://blog.polygon.technology/polygon-rpc-gateway-will-provide-a-free-high-performance-connection-to-the-polygon-pos-blockchain/\u200b","title":"FAQ"},{"location":"xata/farming-guide/","text":"Farming Guide \u00b6 Step-by-Step Guide to farming on XATA \u00b6 Step 1 : Visit the Farm Page \u00b6 You should be able to see the available farming pools by clicking on the 'Farm' tab in https://app.xata.fi/ Feel free to use the filter/search functions to find a pool for your favorite token, or the one you wish to stake. Step 2: Add Liquidity \u00b6 If you have not already done this, head over to our Liquidity Pool Guide to add liquidity to the token pair. Step 3: Stake LP tokens \u00b6 After adding liquidity, return to the Farm page to stake. Click on the 'Stake Tokens' button after opening a farm That's it, you're done! You should start seeing rewards in 'Rewards Earned' over time. Claim Rewards \u00b6 At any point in time, you can claim your rewards without unstaking, by clicking ' Harvest' after opening a farm. This will send all accumulated reward tokens to your wallet. Withdraw or exit the farm \u00b6 When you want to, you can unstake any amount of your LP tokens by clicking the 'Unstake Tokens' button. The remainder of your LP tokens will continue receiving rewards. If you wish to stop everything, you should click the 'Unstake All and Harvest' button instead. This will claim all rewards and unstake all of your LP tokens in the same transaction.","title":"Farming Guide"},{"location":"xata/farming-guide/#farming-guide","text":"","title":"Farming Guide"},{"location":"xata/farming-guide/#step-by-step-guide-to-farming-on-xata","text":"","title":"Step-by-Step Guide to farming on XATA"},{"location":"xata/farming-guide/#step-1-visit-the-farm-page","text":"You should be able to see the available farming pools by clicking on the 'Farm' tab in https://app.xata.fi/ Feel free to use the filter/search functions to find a pool for your favorite token, or the one you wish to stake.","title":"Step 1 : Visit the Farm Page"},{"location":"xata/farming-guide/#step-2-add-liquidity","text":"If you have not already done this, head over to our Liquidity Pool Guide to add liquidity to the token pair.","title":"Step 2: Add Liquidity"},{"location":"xata/farming-guide/#step-3-stake-lp-tokens","text":"After adding liquidity, return to the Farm page to stake. Click on the 'Stake Tokens' button after opening a farm That's it, you're done! You should start seeing rewards in 'Rewards Earned' over time.","title":"Step 3: Stake LP tokens"},{"location":"xata/farming-guide/#claim-rewards","text":"At any point in time, you can claim your rewards without unstaking, by clicking ' Harvest' after opening a farm. This will send all accumulated reward tokens to your wallet.","title":"Claim Rewards"},{"location":"xata/farming-guide/#withdraw-or-exit-the-farm","text":"When you want to, you can unstake any amount of your LP tokens by clicking the 'Unstake Tokens' button. The remainder of your LP tokens will continue receiving rewards. If you wish to stop everything, you should click the 'Unstake All and Harvest' button instead. This will claim all rewards and unstake all of your LP tokens in the same transaction.","title":"Withdraw or exit the farm"},{"location":"xata/introduction/","text":"XATA \u00b6 Learn more about XATA, a Fair Liquidity Provisioning protocol to minimize MEV. About XATA \u00b6 Note Since 2020, MEV has extracted over $730 millions from users, the upper boundaries of the figure is only expected to increase with the incredible velocity of DeFi. XATA is a Fair Liquidity Provisioning protocol that minimizes Maximal Extractable Value (MEV). Incubated by Automata Network\u2019s ecosystem, XATA provides multi-chain support for anti-front-running across various blockchains such as Polygon Network and Binance Smart Chain. Leveraging Automata Network's Conveyor , XATA does not require any miner bribe nor modification to address MEV. Features \u00b6 Powered by Conveyor, XATA creates an unbiased, front-running-free zone with ordered privacy. Private transactions are arranged in an unalterable order: Ordered privacy - Transaction ordering is not revealed unless it is determined and unalterable. No one, including hosting nodes, will know the ordering before it is decided. Gasless Transactions - Users can pay gas fee directly in the tokens to be swapped. Native tokens are no longer required when users are swapping tokens frequently. Chain Agnostic - XATA provides anti-front-running across multiple chains, including Polygon Network and Binance Smart Chain, with further support planned in the near future. No 3rd party involvement - As a stand-alone protocol, XATA does not require any additional miner bribe nor any prior modification on miners' part to work. Links What\u2019s Automata (IV): Conveyor How XATA works \u00b6 XATA arranges transactions in a determined, unbiased order. Users are able to view the amount of tokens saved from front-running, a direct and tangible effect of MEV protection. It is impossible for malicious actors to inject new transactions into XATA's output due to signature mismatch. It is also not possible to delete ordered transactions either, as transactions are broadcasted throughout the network. XATA is the very first liquidity provisioning protocol protected by Automata Network's Conveyor , which eliminates potential leakages from bots and miners. We envision users to benefit from and contribute to fair trading flow with XATA, while DEXes share users and volume in a constructive manner to push the boundary for DeFi. How to use XATA? \u00b6 To understand how XATA works in practice, check out this 2 minute video overview: Get started \u00b6 Follow our in-depth Guide to learn the basics of using XATA. Get involved \u00b6 We are on Telegram - Join the conversation here on telegram now! Get the details \u00b6 Learn the fundamentals of MEV at MEV Wiki Find out how much MEV has been stolen from you on MEV Tax . Resources \u00b6 Twitter Tegegram Medium","title":"Introduction"},{"location":"xata/introduction/#xata","text":"Learn more about XATA, a Fair Liquidity Provisioning protocol to minimize MEV.","title":"XATA"},{"location":"xata/introduction/#about-xata","text":"Note Since 2020, MEV has extracted over $730 millions from users, the upper boundaries of the figure is only expected to increase with the incredible velocity of DeFi. XATA is a Fair Liquidity Provisioning protocol that minimizes Maximal Extractable Value (MEV). Incubated by Automata Network\u2019s ecosystem, XATA provides multi-chain support for anti-front-running across various blockchains such as Polygon Network and Binance Smart Chain. Leveraging Automata Network's Conveyor , XATA does not require any miner bribe nor modification to address MEV.","title":"About XATA"},{"location":"xata/introduction/#features","text":"Powered by Conveyor, XATA creates an unbiased, front-running-free zone with ordered privacy. Private transactions are arranged in an unalterable order: Ordered privacy - Transaction ordering is not revealed unless it is determined and unalterable. No one, including hosting nodes, will know the ordering before it is decided. Gasless Transactions - Users can pay gas fee directly in the tokens to be swapped. Native tokens are no longer required when users are swapping tokens frequently. Chain Agnostic - XATA provides anti-front-running across multiple chains, including Polygon Network and Binance Smart Chain, with further support planned in the near future. No 3rd party involvement - As a stand-alone protocol, XATA does not require any additional miner bribe nor any prior modification on miners' part to work. Links What\u2019s Automata (IV): Conveyor","title":"Features"},{"location":"xata/introduction/#how-xata-works","text":"XATA arranges transactions in a determined, unbiased order. Users are able to view the amount of tokens saved from front-running, a direct and tangible effect of MEV protection. It is impossible for malicious actors to inject new transactions into XATA's output due to signature mismatch. It is also not possible to delete ordered transactions either, as transactions are broadcasted throughout the network. XATA is the very first liquidity provisioning protocol protected by Automata Network's Conveyor , which eliminates potential leakages from bots and miners. We envision users to benefit from and contribute to fair trading flow with XATA, while DEXes share users and volume in a constructive manner to push the boundary for DeFi.","title":"How XATA works"},{"location":"xata/introduction/#how-to-use-xata","text":"To understand how XATA works in practice, check out this 2 minute video overview:","title":"How to use XATA?"},{"location":"xata/introduction/#get-started","text":"Follow our in-depth Guide to learn the basics of using XATA.","title":"Get started"},{"location":"xata/introduction/#get-involved","text":"We are on Telegram - Join the conversation here on telegram now!","title":"Get involved"},{"location":"xata/introduction/#get-the-details","text":"Learn the fundamentals of MEV at MEV Wiki Find out how much MEV has been stolen from you on MEV Tax .","title":"Get the details"},{"location":"xata/introduction/#resources","text":"Twitter Tegegram Medium","title":"Resources"},{"location":"xata/liquiditypool-guide/","text":"Swap & Liquidity Pool Guide \u00b6 Connecting Your Wallet \u00b6 Note Please note: Currently, XATA only supports the Polygon(MATIC) network & Binance Smart Chain(BSC). Support for other chains will be launched very soon. For this guide, we will be using Metamask with a Polygon wallet address to connect to XATA. Please ensure that you have these ready: Metamask extension installed to your chrome browser. Wallet address created on the Polygon Network - See this guide on how to set up a wallet and custom RPC for the Polygon Network. Ensure that you have some MATIC on your wallet address to pay for gas fees. Once you have prepared everything, let's begin conneting our wallet to XATA: Head over to XATA at app.xata.fi. Click on \u201cConnect to a Wallet\u201d on the top right hand corner. Select \u201cMetamask\u201d The Metamask extension prompt will appear. Ensure that your account is checked with a tick and click \"Next\". Another Metamask extension prompt will appear, then click on \"Connect\". If you have done everything right, the user\u2019s address and balance should appear on the top-right corner as shown in this image. Swapping Tokens \u00b6 Click on \"Swap\" at the top left hand corner. Select the tokens that you are swapping for. The token at the bottom is what you will receive for trading in the tokens at the top. The estimated output token amount will be calculated based on the token monetary value ratio from the liquidity pool. You can also click on the gear icon to adjust the \"Slippage Tolerance\" and \"Transaction Deadline\" & \"Multihop\" for your transaction if necessary. Slippage tolerance : The % of the price change that a user can tolerate. For instance, if the value were set at 0.5%, then the transaction will be reverted if the token price change is greater than 0.5%. Transaction deadline : The amount of time in seconds after the transaction is submitted. If a transaction were executed past the deadline, it will be reverted. Multihop : When a user is attempting to swap USDC for DAI, and such a LP pair does not exist, this trade must go through an intermediary token (USDT) from another existing LP pair. The trade route would look like this: USDC -> USDT -> DAI. Once you are ready, click on \"Swap\" and a prompt on XATA will appear. Click on \"Confirm Swap\" to proceed. Do take note that if you have not used these tokens on XATA before, you will need to approve each tokens when prompted before conducting the swap. Next, a Metamask extension prompt will popup to request for signature. Click \"Sign\" to proceed. Once this is done, your swap will be completed when the transaction is confirmed on the blockchain. You can also see how much MEV was protected in your trade using XATA. Liquidity Pools \u00b6 You are also given the option to provide liquidity to XATA by creating a LP (Liquidity Pool) token pair. Adding Liquidity \u00b6 To do this, please follow these steps: Click on \"Pool\" in the top left hand corner. Click on \"Add Liquidity\" Click on the dropdown arrow to select each tokens for your LP pair, then key in the quantity for each. If you have not used these tokens on XATA before, you will need to click on approve tokens for each of them before you can \"Create Pool & Supply\" Once both tokens are approved, click \"Supply\", then click \"Create Pool & Supply\" if you're creating a new liquidity pool. A Metamask extension prompt for a Signature Request will popup. Click \"Sign\" to complete the process. Once your transaction has been confirmed on the blockchain, you will receive your LP token as a representation of your equity of the pool. Removing Liquidity \u00b6 To remove liquidity, click on \u201cPool\u201d to view all your liquidity pools. Then click on \"Manage\" on the liquidity pool of your choice. Then click \"Remove\". Next, select the percentage of liquidity you would like to remove from your pool. Then click \"Approve\". A Metamask extension prompt will appear for an approval, Click on \"Sign\" to proceed. Once approved, you can now click on the \"Remove\" button to trigger another signature request. A Metamask extension prompt for signature request will popup. Click on \"Sign\" again to proceed. The final confirmation popup on XATA will appear. Click on \"Confirm\" to complete the process. Once your transaction is confirmed on the blockchain, you will receive your tokens from the removed liquidity pool.","title":"Swap & Liquidity Pool Guide"},{"location":"xata/liquiditypool-guide/#swap-liquidity-pool-guide","text":"","title":"Swap &amp; Liquidity Pool Guide"},{"location":"xata/liquiditypool-guide/#connecting-your-wallet","text":"Note Please note: Currently, XATA only supports the Polygon(MATIC) network & Binance Smart Chain(BSC). Support for other chains will be launched very soon. For this guide, we will be using Metamask with a Polygon wallet address to connect to XATA. Please ensure that you have these ready: Metamask extension installed to your chrome browser. Wallet address created on the Polygon Network - See this guide on how to set up a wallet and custom RPC for the Polygon Network. Ensure that you have some MATIC on your wallet address to pay for gas fees. Once you have prepared everything, let's begin conneting our wallet to XATA: Head over to XATA at app.xata.fi. Click on \u201cConnect to a Wallet\u201d on the top right hand corner. Select \u201cMetamask\u201d The Metamask extension prompt will appear. Ensure that your account is checked with a tick and click \"Next\". Another Metamask extension prompt will appear, then click on \"Connect\". If you have done everything right, the user\u2019s address and balance should appear on the top-right corner as shown in this image.","title":"Connecting Your Wallet"},{"location":"xata/liquiditypool-guide/#swapping-tokens","text":"Click on \"Swap\" at the top left hand corner. Select the tokens that you are swapping for. The token at the bottom is what you will receive for trading in the tokens at the top. The estimated output token amount will be calculated based on the token monetary value ratio from the liquidity pool. You can also click on the gear icon to adjust the \"Slippage Tolerance\" and \"Transaction Deadline\" & \"Multihop\" for your transaction if necessary. Slippage tolerance : The % of the price change that a user can tolerate. For instance, if the value were set at 0.5%, then the transaction will be reverted if the token price change is greater than 0.5%. Transaction deadline : The amount of time in seconds after the transaction is submitted. If a transaction were executed past the deadline, it will be reverted. Multihop : When a user is attempting to swap USDC for DAI, and such a LP pair does not exist, this trade must go through an intermediary token (USDT) from another existing LP pair. The trade route would look like this: USDC -> USDT -> DAI. Once you are ready, click on \"Swap\" and a prompt on XATA will appear. Click on \"Confirm Swap\" to proceed. Do take note that if you have not used these tokens on XATA before, you will need to approve each tokens when prompted before conducting the swap. Next, a Metamask extension prompt will popup to request for signature. Click \"Sign\" to proceed. Once this is done, your swap will be completed when the transaction is confirmed on the blockchain. You can also see how much MEV was protected in your trade using XATA.","title":"Swapping Tokens"},{"location":"xata/liquiditypool-guide/#liquidity-pools","text":"You are also given the option to provide liquidity to XATA by creating a LP (Liquidity Pool) token pair.","title":"Liquidity Pools"},{"location":"xata/liquiditypool-guide/#adding-liquidity","text":"To do this, please follow these steps: Click on \"Pool\" in the top left hand corner. Click on \"Add Liquidity\" Click on the dropdown arrow to select each tokens for your LP pair, then key in the quantity for each. If you have not used these tokens on XATA before, you will need to click on approve tokens for each of them before you can \"Create Pool & Supply\" Once both tokens are approved, click \"Supply\", then click \"Create Pool & Supply\" if you're creating a new liquidity pool. A Metamask extension prompt for a Signature Request will popup. Click \"Sign\" to complete the process. Once your transaction has been confirmed on the blockchain, you will receive your LP token as a representation of your equity of the pool.","title":"Adding Liquidity"},{"location":"xata/liquiditypool-guide/#removing-liquidity","text":"To remove liquidity, click on \u201cPool\u201d to view all your liquidity pools. Then click on \"Manage\" on the liquidity pool of your choice. Then click \"Remove\". Next, select the percentage of liquidity you would like to remove from your pool. Then click \"Approve\". A Metamask extension prompt will appear for an approval, Click on \"Sign\" to proceed. Once approved, you can now click on the \"Remove\" button to trigger another signature request. A Metamask extension prompt for signature request will popup. Click on \"Sign\" again to proceed. The final confirmation popup on XATA will appear. Click on \"Confirm\" to complete the process. Once your transaction is confirmed on the blockchain, you will receive your tokens from the removed liquidity pool.","title":"Removing Liquidity"},{"location":"xata/sdk/","text":"SDK \u00b6 The XATA-API module \u00b6 The source code for this module can be found here on Github , inside the ./src/xata-api directory . Each function within this module bundles the process of EIP712 signing, fee token calculation, and submitting meta transaction into a single workflow. The supported functions are the following: addLiquidity() swapExactTokensForTokens() swapTokensForExactTokens() removeLiquidity() Using this module, developers no longer required to manually construct a transaction request that looks like this: { \"method\" : \"POST\" , \"headers\" : { \"Content-Type\" : \"application/json\" }, \"body\" : \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"/v2/metaTx/swapTokensForExactTokens\\\",\\\"id\\\":1,\\\"params\\\":[\\\"137\\\",{\\\"types\\\":{\\\"EIP712Domain\\\":[{\\\"name\\\":\\\"name\\\",\\\"type\\\":\\\"string\\\"},{\\\"name\\\":\\\"version\\\",\\\"type\\\":\\\"string\\\"},{\\\"name\\\":\\\"chainId\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"verifyingContract\\\",\\\"type\\\":\\\"address\\\"}],\\\"Forwarder\\\":[{\\\"name\\\":\\\"from\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"feeToken\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"maxTokenAmount\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"deadline\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"nonce\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"data\\\",\\\"type\\\":\\\"bytes\\\"},{\\\"name\\\":\\\"hashedPayload\\\",\\\"type\\\":\\\"bytes32\\\"}]},\\\"domain\\\":{\\\"name\\\":\\\"ConveyorV2\\\",\\\"version\\\":\\\"1\\\",\\\"chainId\\\":\\\"0x89\\\",\\\"verifyingContract\\\":\\\"0xe4C5Cf259351d7877039CBaE0e7f92EB2Ab017EB\\\"},\\\"primaryType\\\":\\\"Forwarder\\\",\\\"message\\\":{\\\"from\\\":\\\"0x10D73FE8e15414E7F1468eeb7A5A61A1aeec00C8\\\",\\\"feeToken\\\":\\\"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\\\",\\\"maxTokenAmount\\\":\\\"0x01\\\",\\\"deadline\\\":\\\"0x6179545d\\\",\\\"nonce\\\":\\\"0x20\\\",\\\"data\\\":\\\"0xf208e6ab000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000f185900000000000000000000000000000000000000000000000000000000000000a000000000000000000000000010d73fe8e15414e7f1468eeb7a5a61a1aeec00c8000000000000000000000000000000000000000000000000000000006179545d00000000000000000000000000000000000000000000000000000000000000020000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f\\\",\\\"hashedPayload\\\":\\\"0x5d299a1b988679b037e32d430bf2fbf03d5eb93949968c076c745ff2ffc18fe3\\\"}},\\\"28\\\",\\\"0xd8d7fdacaec4de579ee45c079cea896b576e994539f7980ec2ffb0c268fc07e3\\\",\\\"0x30dec79f68543f5785931f729ced63aabf5bc26219a11031150bced204d78ece\\\"]}\" } \u200b Installation \u00b6 To use XATA-API module, you must first install the XATA SDK package from NPM . yarn add @xatadev/sdk We recommend you use Yarn to run the installation. If you prefer to use NPM (as some of us do!), just run the installation using this command: npm i @xatadev/sdk Warn It's best not to mix up the use of package managers to avoid resolution inconsistencies. Talk to your team and ask which package manager they are using. \u200b Getting Started \u00b6 To use the module, simply do the following 3 steps: Declare an instance of the XATA module. import { Xata } from '@xatadev/sdk' ; \u200b const xataApi = new Xata (); Initiate the instance const feeToken = '<0xAddress>' await xataApi . init ( web3Provider , feeToken ) // use this method to change the fee token const otherFeeToken = '<0xOtherAddress>' await xataApi . setFeeToken ( otherFeeToken ) Interact with XATA You may now interact with the XATA router using Uniswap-like functions. These functions return API responses like the one below: // response example { \"jsonrpc\" : \"2.0\" , \"result\" : { \"errorMessage\" : null , \"success\" : true , \"txnHash\" : \"0x3a130c90692053f412a26f6d7914bb7637f0193c0a7054621d3e3c3a7d13c24a\" }, \"id\" : 1 } We'll take a closer look at these functions in the following section. \u200b Router Methods \u00b6 Add Liquidity \u00b6 Adds liquidity to the pool. If liquidity for the supplied pair does not exist in the pool then this router will initiate liquidity creation automatically. await xataApi . addLiquidity ( < params > ) Parameter Type Description tokenA string Token A address tokenB string Token B address amountADesired ethers.BigNumber The amount of A added to the liquidity pool if the B/A price <= ( amountBDesired / amountADesired ) amountBDesired ethers.BigNumber The amount of B added to the liquidity pool if the A/B price <= ( amountADesired / amountBDesired ) amountAMin ethers.BigNumber Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired amountBMin ethers.BigNumber Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired user string The user's address. The liquidity provider and the recipient of LP tokens deadline BigNumber Unix timestamp after which the transaction is reverted gasLimit BigNumber Optional: Gas limit for calculating the token fee amount. This value may not be the actual gas limit used in the transaction gasPrice BigNumber Optional: Gas price for calculating the token fee amount. This value may not be the actual gas price used in the transaction Swap Exact Tokens For Tokens \u00b6 Swap an exact amount of input tokens for as many output tokens as possible. await xataApi . swapExactTokensForTokens ( < param > ) Parameter Type Description amountln ethers.BigNumber The amount of input tokens to send amountOutMin ethers.BigNumber The minimum amount of output tokens that must be received for the transaction not to revert. path address[] An array of token addresses. path.length >= 2 user address The user's address deadline unit256 Unix timestamp after which the transaction is reverted gasLimit BigNumber Optional: Gas limit for calculating the token fee amount. This value may not be the actual gas limit used in the transaction gasPrice BigNumber Optional: Gas price for calculating the token fee amount. This value may not be the actual gas price used in the transaction Swap Tokens For Exact Tokens \u00b6 Receive an exact amount of output tokens for as few input tokens as possible. await xataApi . swapTokensForExactTokens ( < params > ) Parameter Type Description amountOut ethers.BigNumber The amount of output tokens to receive amountInMax ethers.BigNumber The maximum amount of input tokens that must be sent for the transaction not to revert. path address[] An array of token addresses. path.length >= 2 user address The user's address deadline uint256 Unix timestamp after which the transaction is reverted gasLimit BigNumber Optional: Gas limit for calculating the token fee amount. This value may not be the actual gas limit used in the transaction gasPrice BigNumber Optional: Gas price for calculating the token fee amount. This value may not be the actual gas price used in the transaction Remove Liquidity \u00b6 Withdraws a pair of tokens by burning LP tokens. This method consists of a 2-steps flow; it requires the LP holders to first sign a permit message, allowing the router to burn LP tokens, then proceeds with the actual LP tokens removal. First, sign the message by calling the permitLP function. (No gas required) await xataApi . permitLP ( < params > ) Parameter Type Description pairAddr string The LP token address owner string The owner of the LP tokens. A.k.a. the user's address spender string The recipient address for the allowance. (XATA Router address) value ethers.BigNumber The liquidity value to approve nonce ethers.BigNumber The nonce used for signing the message deadline uint256 Unix timestamp after which the transaction is reverted It will return a Signature object that is required for removing liquidity. { \"v\" : nu mber , \"r\" : s tr i n g , \"s\" : s tr i n g } Once you receive the signature object from the permitLP then you can invoke the removeLiquidity function to withdraw tokens. await xataApi . removeLiquidity ( < params > ) Parameter Type Description tokenA string Token A address tokenB string Token B address liquidity ethers.BigNumber The amount of liquidity to remove amountAMin ethers.BigNumber The amount of tokenA that must be received before the transaction reverts amountBMin ethers.BigNumber The amount of tokenB that must be received before the transaction reverts user string The user's address. The liquidity provider and the recipient of LP tokens deadline BigNumber Unix timestamp after which the transaction is reverted sig SignatureLike A signature object received from permitLP() gasLimit BigNumber Optional: Gas limit for calculating the token fee amount. This value may not be the actual gas limit used in the transaction gasPrice BigNumber Optional: Gas price for calculating the token fee amount. This value may not be the actual gas price used in the transaction Relay Config \u00b6 When a transaction request is successfully sent to one of the API routers, the transaction is forwarded and processed by Geode \u2013 one of our technologies that can increase privacy and eliminate trading MEV. To do this, the XATA SDK stores the Geode relay configuration as part of the API module. ... [ ChainId . MATIC ] : 'https://conveyor-prod-matic.ata.network' , [ ChainId . BSC ] : 'https://conveyor-prod-bsc.ata.network' , ... Developers can freely customize these endpoints to meet their application needs. To customize it, set new endpoint value(s) for each chain that is supported by your app. You can find the config here. Using a Test Relay on Development \u00b6 XATA API works on production mode by default, and therefore the transaction request also gets forwarded to production-grade Geode. If you are under the development stage and want to test the transaction on a separate relay, you need to make a couple of changes. Update the relay configuration as in the previous section. What makes it different from the previous one is that you have to set the endpoint value(s) under the Environment.STAGING object instead of Environment.PRODUCTION . [ Environment . PRODUCTION ] : { ... [ ChainId . MATIC ] : 'https://conveyor-prod-matic.ata.network' , [ ChainId . BSC ] : 'https://conveyor-prod-bsc.ata.network' , ... }, [ Environment . STAGING ] : { ... [ ChainId . MATIC ] : 'https://your-test-relay.endpoint' , [ ChainId . BSC ] : 'https://your-test-relay.endpoint' , ... } Update the XATA initiation code on your app. // Add new Environment enum import import { Environment , XATA } from '@xatadev/sdk' \u200b const xataApi = new Xata (); const feeToken = '<0xAddress>' // Add 3rd param to override the SDK env mode await xataApi . init ( web3Provider , feeToken , Environment . STAGING );","title":"SDK"},{"location":"xata/sdk/#sdk","text":"","title":"SDK"},{"location":"xata/sdk/#the-xata-api-module","text":"The source code for this module can be found here on Github , inside the ./src/xata-api directory . Each function within this module bundles the process of EIP712 signing, fee token calculation, and submitting meta transaction into a single workflow. The supported functions are the following: addLiquidity() swapExactTokensForTokens() swapTokensForExactTokens() removeLiquidity() Using this module, developers no longer required to manually construct a transaction request that looks like this: { \"method\" : \"POST\" , \"headers\" : { \"Content-Type\" : \"application/json\" }, \"body\" : \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"/v2/metaTx/swapTokensForExactTokens\\\",\\\"id\\\":1,\\\"params\\\":[\\\"137\\\",{\\\"types\\\":{\\\"EIP712Domain\\\":[{\\\"name\\\":\\\"name\\\",\\\"type\\\":\\\"string\\\"},{\\\"name\\\":\\\"version\\\",\\\"type\\\":\\\"string\\\"},{\\\"name\\\":\\\"chainId\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"verifyingContract\\\",\\\"type\\\":\\\"address\\\"}],\\\"Forwarder\\\":[{\\\"name\\\":\\\"from\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"feeToken\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"maxTokenAmount\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"deadline\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"nonce\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"data\\\",\\\"type\\\":\\\"bytes\\\"},{\\\"name\\\":\\\"hashedPayload\\\",\\\"type\\\":\\\"bytes32\\\"}]},\\\"domain\\\":{\\\"name\\\":\\\"ConveyorV2\\\",\\\"version\\\":\\\"1\\\",\\\"chainId\\\":\\\"0x89\\\",\\\"verifyingContract\\\":\\\"0xe4C5Cf259351d7877039CBaE0e7f92EB2Ab017EB\\\"},\\\"primaryType\\\":\\\"Forwarder\\\",\\\"message\\\":{\\\"from\\\":\\\"0x10D73FE8e15414E7F1468eeb7A5A61A1aeec00C8\\\",\\\"feeToken\\\":\\\"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\\\",\\\"maxTokenAmount\\\":\\\"0x01\\\",\\\"deadline\\\":\\\"0x6179545d\\\",\\\"nonce\\\":\\\"0x20\\\",\\\"data\\\":\\\"0xf208e6ab000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000f185900000000000000000000000000000000000000000000000000000000000000a000000000000000000000000010d73fe8e15414e7f1468eeb7a5a61a1aeec00c8000000000000000000000000000000000000000000000000000000006179545d00000000000000000000000000000000000000000000000000000000000000020000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f\\\",\\\"hashedPayload\\\":\\\"0x5d299a1b988679b037e32d430bf2fbf03d5eb93949968c076c745ff2ffc18fe3\\\"}},\\\"28\\\",\\\"0xd8d7fdacaec4de579ee45c079cea896b576e994539f7980ec2ffb0c268fc07e3\\\",\\\"0x30dec79f68543f5785931f729ced63aabf5bc26219a11031150bced204d78ece\\\"]}\" } \u200b","title":"The XATA-API module"},{"location":"xata/sdk/#installation","text":"To use XATA-API module, you must first install the XATA SDK package from NPM . yarn add @xatadev/sdk We recommend you use Yarn to run the installation. If you prefer to use NPM (as some of us do!), just run the installation using this command: npm i @xatadev/sdk Warn It's best not to mix up the use of package managers to avoid resolution inconsistencies. Talk to your team and ask which package manager they are using. \u200b","title":"Installation"},{"location":"xata/sdk/#getting-started","text":"To use the module, simply do the following 3 steps: Declare an instance of the XATA module. import { Xata } from '@xatadev/sdk' ; \u200b const xataApi = new Xata (); Initiate the instance const feeToken = '<0xAddress>' await xataApi . init ( web3Provider , feeToken ) // use this method to change the fee token const otherFeeToken = '<0xOtherAddress>' await xataApi . setFeeToken ( otherFeeToken ) Interact with XATA You may now interact with the XATA router using Uniswap-like functions. These functions return API responses like the one below: // response example { \"jsonrpc\" : \"2.0\" , \"result\" : { \"errorMessage\" : null , \"success\" : true , \"txnHash\" : \"0x3a130c90692053f412a26f6d7914bb7637f0193c0a7054621d3e3c3a7d13c24a\" }, \"id\" : 1 } We'll take a closer look at these functions in the following section. \u200b","title":"Getting Started"},{"location":"xata/sdk/#router-methods","text":"","title":"Router Methods"},{"location":"xata/sdk/#add-liquidity","text":"Adds liquidity to the pool. If liquidity for the supplied pair does not exist in the pool then this router will initiate liquidity creation automatically. await xataApi . addLiquidity ( < params > ) Parameter Type Description tokenA string Token A address tokenB string Token B address amountADesired ethers.BigNumber The amount of A added to the liquidity pool if the B/A price <= ( amountBDesired / amountADesired ) amountBDesired ethers.BigNumber The amount of B added to the liquidity pool if the A/B price <= ( amountADesired / amountBDesired ) amountAMin ethers.BigNumber Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired amountBMin ethers.BigNumber Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired user string The user's address. The liquidity provider and the recipient of LP tokens deadline BigNumber Unix timestamp after which the transaction is reverted gasLimit BigNumber Optional: Gas limit for calculating the token fee amount. This value may not be the actual gas limit used in the transaction gasPrice BigNumber Optional: Gas price for calculating the token fee amount. This value may not be the actual gas price used in the transaction","title":"Add Liquidity"},{"location":"xata/sdk/#swap-exact-tokens-for-tokens","text":"Swap an exact amount of input tokens for as many output tokens as possible. await xataApi . swapExactTokensForTokens ( < param > ) Parameter Type Description amountln ethers.BigNumber The amount of input tokens to send amountOutMin ethers.BigNumber The minimum amount of output tokens that must be received for the transaction not to revert. path address[] An array of token addresses. path.length >= 2 user address The user's address deadline unit256 Unix timestamp after which the transaction is reverted gasLimit BigNumber Optional: Gas limit for calculating the token fee amount. This value may not be the actual gas limit used in the transaction gasPrice BigNumber Optional: Gas price for calculating the token fee amount. This value may not be the actual gas price used in the transaction","title":"Swap Exact Tokens For Tokens"},{"location":"xata/sdk/#swap-tokens-for-exact-tokens","text":"Receive an exact amount of output tokens for as few input tokens as possible. await xataApi . swapTokensForExactTokens ( < params > ) Parameter Type Description amountOut ethers.BigNumber The amount of output tokens to receive amountInMax ethers.BigNumber The maximum amount of input tokens that must be sent for the transaction not to revert. path address[] An array of token addresses. path.length >= 2 user address The user's address deadline uint256 Unix timestamp after which the transaction is reverted gasLimit BigNumber Optional: Gas limit for calculating the token fee amount. This value may not be the actual gas limit used in the transaction gasPrice BigNumber Optional: Gas price for calculating the token fee amount. This value may not be the actual gas price used in the transaction","title":"Swap Tokens For Exact Tokens"},{"location":"xata/sdk/#remove-liquidity","text":"Withdraws a pair of tokens by burning LP tokens. This method consists of a 2-steps flow; it requires the LP holders to first sign a permit message, allowing the router to burn LP tokens, then proceeds with the actual LP tokens removal. First, sign the message by calling the permitLP function. (No gas required) await xataApi . permitLP ( < params > ) Parameter Type Description pairAddr string The LP token address owner string The owner of the LP tokens. A.k.a. the user's address spender string The recipient address for the allowance. (XATA Router address) value ethers.BigNumber The liquidity value to approve nonce ethers.BigNumber The nonce used for signing the message deadline uint256 Unix timestamp after which the transaction is reverted It will return a Signature object that is required for removing liquidity. { \"v\" : nu mber , \"r\" : s tr i n g , \"s\" : s tr i n g } Once you receive the signature object from the permitLP then you can invoke the removeLiquidity function to withdraw tokens. await xataApi . removeLiquidity ( < params > ) Parameter Type Description tokenA string Token A address tokenB string Token B address liquidity ethers.BigNumber The amount of liquidity to remove amountAMin ethers.BigNumber The amount of tokenA that must be received before the transaction reverts amountBMin ethers.BigNumber The amount of tokenB that must be received before the transaction reverts user string The user's address. The liquidity provider and the recipient of LP tokens deadline BigNumber Unix timestamp after which the transaction is reverted sig SignatureLike A signature object received from permitLP() gasLimit BigNumber Optional: Gas limit for calculating the token fee amount. This value may not be the actual gas limit used in the transaction gasPrice BigNumber Optional: Gas price for calculating the token fee amount. This value may not be the actual gas price used in the transaction","title":"Remove Liquidity"},{"location":"xata/sdk/#relay-config","text":"When a transaction request is successfully sent to one of the API routers, the transaction is forwarded and processed by Geode \u2013 one of our technologies that can increase privacy and eliminate trading MEV. To do this, the XATA SDK stores the Geode relay configuration as part of the API module. ... [ ChainId . MATIC ] : 'https://conveyor-prod-matic.ata.network' , [ ChainId . BSC ] : 'https://conveyor-prod-bsc.ata.network' , ... Developers can freely customize these endpoints to meet their application needs. To customize it, set new endpoint value(s) for each chain that is supported by your app. You can find the config here.","title":"Relay Config"},{"location":"xata/sdk/#using-a-test-relay-on-development","text":"XATA API works on production mode by default, and therefore the transaction request also gets forwarded to production-grade Geode. If you are under the development stage and want to test the transaction on a separate relay, you need to make a couple of changes. Update the relay configuration as in the previous section. What makes it different from the previous one is that you have to set the endpoint value(s) under the Environment.STAGING object instead of Environment.PRODUCTION . [ Environment . PRODUCTION ] : { ... [ ChainId . MATIC ] : 'https://conveyor-prod-matic.ata.network' , [ ChainId . BSC ] : 'https://conveyor-prod-bsc.ata.network' , ... }, [ Environment . STAGING ] : { ... [ ChainId . MATIC ] : 'https://your-test-relay.endpoint' , [ ChainId . BSC ] : 'https://your-test-relay.endpoint' , ... } Update the XATA initiation code on your app. // Add new Environment enum import import { Environment , XATA } from '@xatadev/sdk' \u200b const xataApi = new Xata (); const feeToken = '<0xAddress>' // Add 3rd param to override the SDK env mode await xataApi . init ( web3Provider , feeToken , Environment . STAGING );","title":"Using a Test Relay on Development"},{"location":"xata/smart-contract/","text":"Smart Contracts \u00b6 What do these contracts do? \u00b6 Here are the official smart contract addresses for XATA on each network that we currently support. Please ensure that you are interacting with the correct contract addresses with your wallet to protect yourself from phishing attempts. Factory Contract - The \"Factory\" is responsible for creating new exchange contracts for each token pairs. Router Contract - The \"Router\" performs requirement checks needed for swapping tokens, adding liquidity, and removing liquidity. Official XATA Smart Contract Addresses \u00b6 Polygon Network \u00b6 Factory Contract: 0x5f8017621825BC10D63d15C3e863f893946781F7 Router Contract: 0xe4C5Cf259351d7877039CBaE0e7f92EB2Ab017EB Farm Contracts: ATA/USDT: 0x3dD417Ff4144bE35f203CB2CA569adF01Cd3574a Binance Smart Chain Network \u00b6 Factory Contract: 0x5f8017621825BC10D63d15C3e863f893946781F7 Router Contract: 0xe4C5Cf259351d7877039CBaE0e7f92EB2Ab017EB Farm Contracts: ATA/USDT: 0x3dD417Ff4144bE35f203CB2CA569adF01Cd3574a","title":"Smart Contracts"},{"location":"xata/smart-contract/#smart-contracts","text":"","title":"Smart Contracts"},{"location":"xata/smart-contract/#what-do-these-contracts-do","text":"Here are the official smart contract addresses for XATA on each network that we currently support. Please ensure that you are interacting with the correct contract addresses with your wallet to protect yourself from phishing attempts. Factory Contract - The \"Factory\" is responsible for creating new exchange contracts for each token pairs. Router Contract - The \"Router\" performs requirement checks needed for swapping tokens, adding liquidity, and removing liquidity.","title":"What do these contracts do?"},{"location":"xata/smart-contract/#official-xata-smart-contract-addresses","text":"","title":"Official XATA Smart Contract Addresses"},{"location":"xata/smart-contract/#polygon-network","text":"Factory Contract: 0x5f8017621825BC10D63d15C3e863f893946781F7 Router Contract: 0xe4C5Cf259351d7877039CBaE0e7f92EB2Ab017EB Farm Contracts: ATA/USDT: 0x3dD417Ff4144bE35f203CB2CA569adF01Cd3574a","title":"Polygon Network"},{"location":"xata/smart-contract/#binance-smart-chain-network","text":"Factory Contract: 0x5f8017621825BC10D63d15C3e863f893946781F7 Router Contract: 0xe4C5Cf259351d7877039CBaE0e7f92EB2Ab017EB Farm Contracts: ATA/USDT: 0x3dD417Ff4144bE35f203CB2CA569adF01Cd3574a","title":"Binance Smart Chain Network"}]}